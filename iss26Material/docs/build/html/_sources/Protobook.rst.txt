.. role:: red  
.. role:: blue 
.. role:: brown 
.. role:: magenta       
.. role:: remark
.. role:: worktodo
.. role:: slide 
.. role:: slide1
.. role:: slide2
.. role:: slide3         
.. role:: slide4   
.. role:: slidekp

.. _Sito Web Attività Progettuale : https://www.unibo.it/it/studiare/dottorati-master-specializzazioni-e-altra-formazione/insegnamenti/insegnamento/2024/468018
.. _Sito Web corso ISS2025: https://www.unibo.it/it/studiare/dottorati-master-specializzazioni-e-altra-formazione/insegnamenti/insegnamento/2024/468003
.. _Lectures2025: ../LectureBologna2025.html
.. _Sprint review : https://www.agileway.it/sprint-review-meeting/
.. _template: _static/templateToFill.html
.. _Conway Life: https://it.wikipedia.org/wiki/Gioco_della_vita
.. _Conway Life play: https://playgameoflife.com/
.. _ConwayLife.py: https://github.com/anatali/protobook/blob/main/material/source/code/ConwayLife.py  
.. _conway25Gemini.js: https://github.com/anatali/protobook/blob/main/material/source/code/conway25JsGemini.js
.. _robot reali: _static/devsDdr.html

.. _UTF-8: https://en.wikipedia.org/wiki/UTF-8
.. _fire-and-forget: https://medium.com/mandiri-engineering/fire-and-forget-e59b745c9f97
.. _Publish–subscribe: https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern
.. _interaction patterns: https://docs.oracle.com/cd/E24001_01/doc.1111/e17363/chapter05.htm


.. _Small world network: https://en.wikipedia.org/wiki/Small-world_network
.. _sei gradi di sperazione: https://it.wikipedia.org/wiki/Sei_gradi_di_separazione
.. _sinergetica : https://en.wikipedia.org/wiki/Synergetics_(Haken)
.. _laser: https://it.wikipedia.org/wiki/Laser
.. _Model-driven engineering:  https://en.wikipedia.org/wiki/Model-driven_engineering

.. _Akka: https://akka.io/
.. _Modello computazionale ad attori: https://en.wikipedia.org/wiki/Actor_model
.. _Akka Actors: https://doc.akka.io//docs/akka/current/typed/guide/actors-motivation.html
.. _Domain Specific Language: https://www.jetbrains.com/mps/concepts/domain-specific-languages/

.. _Teoria delle reti: https://www.isc.cnr.it/public-outreach/divulgazione/scienza-della-complessita-e-teoria-delle-reti/
.. _Legge di potenza: https://it.wikipedia.org/wiki/Legge_di_potenza
.. _Willard Van Orman Quine: https://it.wikipedia.org/wiki/Willard_Van_Orman_Quine
.. _Ipotesi Sapir-Whorf: https://it.wikipedia.org/wiki/Ipotesi_di_Sapir-Whorf

.. _Qubit: https://it.wikipedia.org/wiki/Qubit
.. _Funzioni serverless: https://it.wikipedia.org/wiki/Function_as_a_service
.. _Agenti: https://it.wikipedia.org/wiki/Agente_intelligente
.. _Microservizi: https://en.wikipedia.org/wiki/Microservices
.. _Meccanica quantistica: https://it.wikipedia.org/wiki/Meccanica_quantistica

.. _Edsger Dijkstra: https://it.wikipedia.org/wiki/Edsger_Dijkstra
.. _Gemello Digitale: https://it.wikipedia.org/wiki/Gemello_digitale
.. _Internet of Things: https://en.wikipedia.org/wiki/Internet_of_things
.. _Model driven engineering: https://en.wikipedia.org/wiki/Model-driven_engineering
.. _Ontologia: https://it.wikipedia.org/wiki/Ontologia

.. _Gerarchia di Chomsky: https://it.wikipedia.org/wiki/Gerarchia_di_Chomsky
.. _Macchina astratta: https://it.wikipedia.org/wiki/Macchina_astratta

.. _Alan Kay: https://en.wikipedia.org/wiki/Alan_Kay
.. _Computer a DNA: https://it.wikipedia.org/wiki/Computer_a_DNA
.. _Natural computing: https://en.wikipedia.org/wiki/Natural_computing
.. _Quantum computing: https://en.wikipedia.org/wiki/Quantum_computing
.. _Quantum gates: https://en.wikipedia.org/wiki/Quantum_logic_gate
.. _Rule 110: https://en.wikipedia.org/wiki/Rule_110
.. _previsione di Wolff, Anthropic: https://www.dday.it/redazione/55487/wolff-anthropic-la-figura-del-programmatore-e-al-capolinea-come-cambiera-in-futuro-lo-sviluppo-del-software

.. _sinergetica: https://en.wikipedia.org/wiki/Synergetics_(Haken)
.. _Il Sorprendente Segreto della Sincronizzazione: https://www.youtube.com/watch?v=p4jwj8IJjNg
.. _Stigmergia: https://it.wikipedia.org/wiki/Stigmergia

.. _CCS: https://en.wikipedia.org/wiki/Calculus_of_communicating_systems
.. _CSP: https://en.wikipedia.org/wiki/Communicating_sequential_processes
.. _Pi calcolo: https://it.wikipedia.org/wiki/Pi_calcolo
.. _Alan M. Turing: https://it.wikipedia.org/wiki/Alan_Turing
.. _Marvin Minsky: https://en.wikipedia.org/wiki/Marvin_Minsky
.. _Counter machine: https://en.wikipedia.org/wiki/Counter_machine
.. _John von Neumann: https://it.wikipedia.org/wiki/John_von_Neumann
.. _David Hilbert: https://it.wikipedia.org/wiki/David_Hilbert
.. _Kurt Gödel: https://it.wikipedia.org/wiki/Kurt_G%C3%B6del
.. _Teorema di Rice: https://it.wikipedia.org/wiki/Teorema_di_Rice
.. _Niklaus Wirth: https://it.wikipedia.org/wiki/Niklaus_Wirth

.. _Linguaggio assembly: https://it.wikipedia.org/wiki/Linguaggio_assembly

.. _mshistory: _static/docs/msoIEEE.pdf
.. _Microservices: https://en.wikipedia.org/wiki/Microservices
.. _Fallacies: https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing

.. _OpenAPI: https://it.wikipedia.org/wiki/Specifiche_OpenAPI

.. _Raspberry Pi: https://it.wikipedia.org/wiki/Raspberry_Pi

.. _Qaksyntax: _static/docs/Qactork_xtext.pdf
.. _Macchina di Moore: https://it.wikipedia.org/wiki/Macchina_di_Moore
.. _tuProlog: https://amsacta.unibo.it/id/eprint/5450/7/tuprolog-guide.pdf

.. _Xtext grammar: https://eclipse.dev/Xtext/documentation/301_grammarlanguage.html
.. _Xtext tutorial: https://eclipse.dev/Xtext/documentation/102_domainmodelwalkthrough.html

.. _Software testing : https://en.wikipedia.org/wiki/Software_testing 
.. _Automated-Testing-Plan FAQ : http://sqa.fyicenter.com/FAQ/Automated-Testing-Plan/
.. _JUnit : https://www.html.it/articoli/junit-unit-testing-per-applicazioni-java/
.. _Junit FAQ : http://sqa.fyicenter.com/FAQ/JUnit/What_Is_JUnit_.html
.. _Software testing IBM : https://www.ibm.com/it-it/topics/software-testing
.. _Software testing quotes : https://softwaretestingfundamentals.com/software-testing-quotes/
.. _User Stories : https://en.wikipedia.org/wiki/User_story
.. _UML : https://it.wikipedia.org/wiki/Unified_Modeling_Language
.. _Profili UML : https://en.wikipedia.org/wiki/Profile_(UML)
.. _MDE : https://en.wikipedia.org/wiki/Model-driven_engineering

.. _gRPC Remote Procedure Call: https://it.wikipedia.org/wiki/gRPC
.. _SOAP: https://it.wikipedia.org/wiki/SOAP
.. _URL: https://it.wikipedia.org/wiki/Uniform_Resource_Locator
.. _WebSocket: https://it.wikipedia.org/wiki/WebSocket
.. _javalin: https://javalin.io/

.. _Spring Boot: https://spring.io/projects/spring-boot
.. _Jetty: https://it.wikipedia.org/wiki/Jetty
.. _vert.x: https://www.baeldung.com/vertx
.. _AsyncAPI Studio: https://studio.asyncapi.com/
.. _Modelina: https://modelina.org/
.. _AsyncAPI Generator: https://www.asyncapi.com/tools/generator
.. _Microcks: https://microcks.io/

.. _Clean Architecture: https://clevercoder.net/2018/09/08/clean-architecture-summary-review/
.. _Opinionated vs. Non-Opinionated Frameworks: https://dev.to/muhammadmedhat/opinionated-vs-non-opinionated-frameworks-understanding-the-difference-2379
.. _WsContext: https://javalin.io/documentation#wscontext
.. _WsMessageContext: https://javalin.io/documentation#wscontext:~:text=Copy-,WsMessageContext,-message()&text=Copy-,WsMessageContext,-message()
.. _io.javalin.http.Context: https://javalin.io/documentation#context

.. _Principle of least astonishment: https://en.wikipedia.org/wiki/Principle_of_least_astonishment
.. _CompletableFuture Java: https://www.baeldung.com/java-completablefuture
.. _CountDownLatch: https://www.baeldung.com/java-countdown-latch

.. _Java record: https://www.baeldung.com/java-16-new-features#records-jep-395
.. _ExecutorService: https://www.baeldung.com/java-executor-service-tutorial
.. _canvas: https://www.w3schools.com/html/html5_canvas.asp

.. _Sito Web Attività Progettuale : https://www.unibo.it/it/studiare/dottorati-master-specializzazioni-e-altra-formazione/insegnamenti/insegnamento/2024/468018
.. _Sito Web corso ISS2025: https://www.unibo.it/it/studiare/dottorati-master-specializzazioni-e-altra-formazione/insegnamenti/insegnamento/2024/468003
.. _Lectures2025: ../LectureBologna2025.html
.. _Sprint review : https://www.agileway.it/sprint-review-meeting/
.. _template: _static/templateToFill.html
.. _Conway Life: https://it.wikipedia.org/wiki/Gioco_della_vita
.. _Conway Life play: https://playgameoflife.com/
.. _robot reali: _static/devsDdr.html

.. _rst editor: http://rst.ninjs.org/

.. _mosquittoOnly.yml: _static/mosquittoOnly.yml 
.. _gradle-tutorial: _static/GradleTutorialForCompleteBeginners.pdf

.. _Domain Driven Design : https://it.wikipedia.org/wiki/Domain-driven_design
.. _gradle: https://gradle.org/ 
.. _GradleIntro: ../../../../GradleIntro/userdocs/Gradle.intro.html
.. _IntelliJ: https://www.jetbrains.com/idea/
.. _template: _static/templateToFill.html
.. _Eclipse IDE for Java and DSL Developers: https://www.eclipse.org/downloads/packages/
.. _Basic Git commands: https://confluence.atlassian.com/bitbucketserver/basic-git-commands-776639767.html
.. _Video on GIT: https://www.youtube.com/watch?v=HVsySz-h9r4
.. _github: https://github.com/
.. _opinionated: https://govdevsecopshub.com/2021/02/26/opinionated-software-what-it-is-and-how-it-enables-devops/

.. _SpringBoot: https://spring.io/projects/spring-boot
.. _SCRUM : https://it.wikipedia.org/wiki/Scrum_(informatica)
.. _SCRUM Guide :   https://scrumguides.org/

.. _Design Pattern : https://it.wikipedia.org/wiki/Design_pattern
.. _DevOps : https://it.wikipedia.org/wiki/DevOps

========================================
Protobook
========================================
Questo testo è stato redatto usando RestructredText e Sphinx e 
generato con **make html** o **make latexpdf**


.. https://www.redhotcyber.com/post/google-distilling-step-by-step-come-ottimizzare-modelli-linguistici-di-grandi-dimensioni-per-luso-pratico/

 

.. .. contents:: Indice
..   :depth: 2


======================================
Preludio
======================================
 
L'idea di **Ingegneria** pone enfasi sulla 

.. code::

  costruzione consapevole e motivata di artefatti basata su analisi, progettazione, 
  sviluppo,  distribuzione e manutenzione di prodotti

Gli *ingegneri del software* sono abituati ad avvelersi di molti diversi strumenti per costruire 
:ref:`Sistemi software`: linguaggi di programmazione, framework, librerie, ambienti di sviluppo, etc.

Oggi esiste un nuovo, potente strumento: le Chat basate su *Intelligenza Artificiale- (**IA**). 

Sempre più spesso, le IA generative (come ChatGPT, Gemini, Claude, ecc.) vengono utilizzate per assistere 
gli sviluppatori nel processo di scrittura del codice, nella generazione di documentazione e molto altro.

Ad esempio, posso chiedere a ChatGPT di generare un programma  che realizza il gioco 
`Conway Life`_. A tal fine imposto il seguente **prompt**:

.. code-block:: text

  "Genera un programma che implementa il gioco di Conway Life.
   Il programma deve utilizzare una griglia 10x10 e visualizzare 
   lo stato della griglia ad ogni iterazione. 
   Includi commenti esplicativi nel codice."

- Il risultato di questa rochiesta a **ChatGpt** è un programma *Python- riportato in  `ConwayLife.py`_.
  
  
  
  .. .. raw:: html

     .. Clicca sul link per vedere il codice sorgente:
     

  .. .. literalinclude:: ./code/hello.txt
    :download:`Vedi il codice sorgente <./code/hello.txt>`
    :encoding: utf-8



  .. literalinclude:: ./code/ConwayLife.py
    :language: python
    :caption: Visualizza ConwayLife.py
    :download:`Vedi il codice sorgente (ConwayLife.py) <code/ConwayLife.py>`
    :encoding: utf-8

  .. seealso::

     


Posso anche ottenere una versione in JavaScript, specificando questa rihiesta nel prompt. Il file `conway25Gemini.js`_.
riporta il risultato del codice generato da **Gemini**.

Modificando ulteriormente il prompt, è possibile generare programmi che eseguono il gioco in un browser web,
utilizzando ``HTML5`` e `canvas`_ per la visualizzazione grafica o che utilizzano librerie grafiche come *Pygame- 
per una visualizzazione più avanzata in Python.  

.. WebGL
 
-----------------------------------------
C'è ancora possibilità di lavoro?
-----------------------------------------

E' noto che quando una attività diventa riproducibile da una macchina, cessa di avere valore per gli
esseri umani e, automaticamente cessano di avere valore le persone che continuano a 
svolgere quell'attività.

Dunque, la professione del costruttore di software rischia di essere messa in crisi.
Proviamo a chiedere alla IA 'cosa ne pensa':

.. code-block:: text

  "L'avvento della IA generativa potrebbe mettere in crisi la professione 
   del programmatore di computer. 
   Vorrei avere una panoramica delle ragioni che possono rendere meno probabile 
   questo fenomeno  o, meglio, le attività nel campo della costruzione del software 
   che possono ancora essere svolte in modo migliore da un essere umano"

.. note:: Risponde Gemini 
  
   È vero che l'avvento dellIA Generativa** ha sollevato preoccupazioni sulla professione di programmatore. 

   Tuttavia, la maggior parte degli esperti concorda che l'IA sia destinata a diventare uno 
   strumento di potenziamento piuttosto che un sostituto completo, soprattutto nelle fasi 
   più critiche e astratte del ciclo di vita del software.


   Ecco una panoramica delle attività in cui l'essere umano mantiene un vantaggio distintivo 
   e in cui è meno probabile che venga sostituito dall'IA.
   
 
  **Comprensione del Dominio e Astrazione**
 
  L'IA generativa (come ChatGPT o Gemini o Copilot) eccelle nella **traduzione sintattica** (scrivere codice da istruzioni chiare), ma fallisce nella **comprensione semantica** profonda del dominio aziendale o scientifico.

  - **Identificazione del Problema Reale:** Un ingegnere del software umano è fondamentale per interagire con il cliente, 
    comprendere i requisiti ambigui, definire i *casi limite* (edge cases) e distinguere ciò che il cliente *vuole* 
    da ciò di cui il cliente *ha bisogno*. L'IA può scrivere codice per una funzione, ma non può ancora guidare una 
    riunione di *discovery* per definire i modelli di business.
  - **Architettura e Design a Livello Olistico** : L'IA può generare codice per singoli componenti o `Microservizi`_, 
    ma la creazione di unarchitettura software** coerente, scalabile, e che rispetti vincoli di costo e tempo 
    (*Design Patterns, Olarchia, Coreografia vs. Orchestrazione*) richiede un giudizio e una visione sistemica 
    che l'IA non possiede.

   
  **Gestione della Complessità e Integrazione**
   
  I sistemi software reali sono raramente applicazioni *greenfield* (nuove da zero); 
  sono complessi intrecciati di sistemi legacy, API di terze parti e vincoli operativi.

  - **Integrazione di Sistemi Legacy:** Il codice generato dall'IA è spesso ottimale, ma si scontra con la necessità di integrarsi con un codice legacy vecchio di 20 anni, spesso non documentato e con *side effects- non ovvi. Solo un umano può **decifrare e manutenere** in modo sicuro queste interfacce complesse.
  - **Debug di Sistemi Distribuiti:** Identificare la causa radice di un *bug* 
    in un sistema distribuito (che coinvolge rete, database, latenza e interazioni asincrone) 
    richiede ragionamento causale e ipotesi basate su esperienza, non solo sul pattern matching del codice.

   
  **Fattore Umano ed Etica**
   
  La programmazione non è solo un esercizio tecnico, ma un atto sociale, etico e di gestione del rischio.

  - **Responsabilità Etica e Legale:** Chi è responsabile se un codice generato dall'IA causa danni (es. in un sistema finanziario o medico)? L'ingegnere umano mantiene la **responsabilità finale** per la validazione, il test e l'implementazione sicura del codice.
  - **Leadership e Mentoring:** L'IA non può gestire un team, mediare conflitti, fare *mentoring- a sviluppatori junior, o difendere una decisione tecnica davanti a stakeholder non tecnici. Queste sono soft skills cruciali nella professione.
   
  **Attività Specifiche in cui l'Umano eccelle**

  Ecco le aree dove il programmatore sposta il suo valore aggiunto:

  .. list-table:: 
    :widths: 28,72
    :width: 100%

    *
      - **Area di Attività**      
      - **Ruolo Umano Distintivo**
    *
      - *Ingegneria dei Requisiti*      
      - Interazione diretta con gli utenti, conversione di necessità vaghe in specifiche 
        tecniche formali (definizione dell'obiettivo).
    *
      - *Architettura Software*     
      - Selezione del paradigma (OOP, Funzionale, Olonico), progettazione di schemi di 
        database e definizione delle interfacce tra i macro-servizi.
    *
      - *Validazione e Test Strategico*      
      - Non solo scrivere unit test (che l'IA può fare), 
        ma definire **scenari di test complessi** e non banali, test di carico e strategie di *chaos engineering*. 
    *
      - *Sicurezza e Hardening*      
      - Identificazione di vulnerabilità logiche e attacchi a livello di business. 
        L'IA può scrivere codice, ma un umano deve garantire la **robustezza contro gli intenti malevoli**. 
    *
      - *Innovazione e Ricerca*      
      - L'IA è addestrata su dati esistenti (ciò che è stato fatto). 
        La creazione di **nuovi algoritmi**, paradigmi o linguaggi di programmazione per risolvere problemi non ancora risolti 
        sembra richiedere ancora creatività umana.
    
  In conclusione, l'IA Generativa solleverà il programmatore dai compiti di scrittura di 
  codice *boilerplate* e di *routine* (codifica), ma amplificherà la necessità di concentrarsi 
  sulla **soluzione dei problemi**, sulla **gestione della complessità** e sul **giudizio etico-architetturale**. 

  La professione non scompare, ma si **eleva** da programmatore a **ingegnere del software di sistema**.
  
  
  .. (si veda anche la recente previsione di *Wolff*, di *Anthropic*)




=========================================
Cosa si intende per Sistema 
=========================================

**Overview**

Si introduce il concetto fondamentale di sistema non come una definizione formale univoca, 
ma come un insieme organizzato di elementi interconnessi volti a raggiungere uno scopo specifico. 
Questo capitolo funge da ponte concettuale per passare dalla visione del software come semplice algoritmo 
alla comprensione dei moderni ecosistemi distribuiti.
I punti salienti del capitolo includono:

- Tassonomia dei sistemi: Viene proposta una classificazione basata sulla prevedibilità e sulla linearità, distinguendo tra sistemi semplici (prevedibili e lineari), complicati (decomponibili e analizzabili da esperti), complessi (caratterizzati da emergenza e non linearità) e caotici (impossibili da prevedere a lungo termine).
- Classificazione per natura: si distinguono diverse tipologie di enti sistemici, dalle macchine (sistemi chiusi e deterministici) ai sistemi cibernetici (regolati dal feedback), fino agli agenti (autonomi e orientati a obiettivi) e agli organismi (sistemi aperti, dinamici e capaci di autorganizzazione).
- Prospettive di descrizione: Un sistema può essere analizzato attraverso una visione BlackBox (focalizzata sull'interazione e sulle interfacce pubbliche), una visione WhiteBox (che ne esamina struttura, comportamento e interazioni interne) o una visione sistemica.
- Il principio "More is different": Viene enfatizzato che, con l'aumento della dimensione e delle interconnessioni, 
  il sistema acquisisce proprietà globali non riducibili alla somma delle singole parti (proprietà emergenti). 
  Per l'ingegnere del software, ciò significa che il focus non è su cosa fanno i componenti, ma come interagiscono.
- Sistemi complessi e software moderno: Il software contemporaneo è descritto come un ecosistema di servizi e attori che possiede le stesse proprietà dei sistemi complessi naturali: distribuzione, autonomia, adattabilità e sensibilità alla topologia delle reti.
- Teoria delle reti e Sinergetica: Vengono introdotti strumenti formali come la teoria dei grafi e la sinergetica di Haken per modellare l'auto-organizzazione e comprendere le dinamiche collettive (come la sincronizzazione e la resilienza) nei sistemi distribuiti.

In sintesi, il capitolo stabilisce che la costruzione di sistemi software moderni richiede di superare 
l'approccio riduzionista a favore di una visione olistica, 
indispensabile per progettare comportamenti emergenti e robustezza in ambienti dinamici.

----


Il termine 'sistema' deriva da una parola greca che significa "ciò che è posto insieme" o "un insieme organizzato".

Non esiste una singola definizione formale universalmente accettata di **"sistema”** poichè
la parola evoca un concetto categoriale che assume significati diversi in fisica, ingegneria, biologia,
sociologia, informatica.

.. (:math:`σύστημα`) 

Un prima, possibile definizione 'informale' può essere:

.. code::

  Un sistema è un insieme di elementi interconnessi o interagenti,  
  organizzati in modo coerente per raggiungere un determinato scopo  
  (o per svolgere una funzione specifica).`


----------------------------------------------------
Descrivere e classificare
----------------------------------------------------
Descrivere significa **selezionare e organizzare informazione**
per rappresentare un oggetto o un sistema **in modo utile**, spesso *compattato*,
privilegiando **relazioni e regole** rispetto a elenchi e dettagli.

Una descrizione può assumere la forma di una **classificazione**, cioè:

.. code:: text

  classificare = assegnare ogni elemento di un insieme 
  a una categoria, in base a criteri scelti.

Dobbiamo essere consapevoli che
ogni classificazione è **costruita**, e 
dipende dagli **scopi** e dalla **cultura** dell'osservatore.
Non esistono categorie “naturali” e assolute:
*decidere cosa distinguere e aggregare* è sempre **interpretazione**.
Le categorie non “esistono” nelle cose. Le creiamo noi per raggiungere uno scopo.

Nel tentativo di comprendere il mondo, si è affermata una tassonomia molto diffusa che distingue 
i sistemi in *semplici, complicati, complessi e caotici*. 
Questa classificazione permette di riconoscere la *natura* di un sistema 
e di scegliere gli strumenti più adatti per analizzarlo o progettarlo.

Questa tassonomia serve non tanto per incasellare i sistemi, quanto per:
guidare il modo in cui li **modelliamo**, quali strumenti formali utilizziamo 
e quali aspettative abbiamo sul loro comportamento.

A ciascuna delle categorie possiamo far corrispondere una diversa classe di fenomeni 
e diverse possibili azioni di governo.

.. _Sistemi semplici:

----------------------------------------------------
Sistemi semplici 
----------------------------------------------------

**Caratteristica**: comportamento prevedibile, descrivibile con poche regole lineari; facile da modellare e prevedere.

I sistemi semplici provocano fenomeni semplici. Il principio causa-effetto indica, 
a partire dall'effetto, qual è la causa che lo determina.

**Azioni**: Un'azione di intervento sul sistema consiste nell'applicare un protocollo risolutivo predefinito.
E' il regno delle persone **executive** che applicanon **Best Practices**.
*Esempio*: hostess di un aereo.

.. _Sistemi complicati:

----------------------------------------------------
Sistemi complicati 
----------------------------------------------------
**Caratteristica**:  Molti elementi e molte relazioni, ma ingegnerizzabile— decomponibile, prevedibile;
molte possibili casue per un dato fenomeno.

Questi sistemi provocano fenomeni complicati, per i quali occorre studio e analisi.

**Azioni**: Un'azione di intervento consiste nell'analizzare le possibili cause, pianificare l'intervento
risolutivo e realizzarlo.
Sono necessarie persone **expert** capaci di definire a priori
un modello di funzionamento, in base al quale pianificare l'intevento.
*Esempio*: pilota di un aereo a motore.

.. _Sistemi complessi:

----------------------------------------------------
Sistemi complessi 
----------------------------------------------------

**Caratteristica**:  Molti elementi, relazioni non lineari, adattamento, emergenza; 
il comportamento non è predicibile solo dalle parti, ma emerge dalle interazioni.

Un sistema complesso non può essere 'controllato'; può al massimo essere 'perturbato'.

**Azioni**:  Un'azione di intervento non può essere basata su un modello a-priori, ma richiede l'azione come 
scelta/scommessa, apprendimento (degli effetti) e adattamento continuo (**try and learn**). 
*Esempio*: pilota di un aliante.

E' l'azione (**agency**) costruttiva a generare conoscenza. Quando non si conosce il
modello di comportamento di un fenomeno, **agire** significa sperimentare e questo 
per gli esseri umani (dice il biologo *Stuart Kauffman*) significa generare nuovi artefatti e modelli
chiamando in causa competenze e approcci diversi, con una proliferazione di attività eterogenee.

.. _Sistemi caotici:

----------------------------------------------------
Sistemi caotici 
---------------------------------------------------- 

**Caratteristica**:  Estremamente sensibile alle condizioni iniziali (effetto farfalla); 
può essere anche “semplice” dal punto di vista strutturale, ma 
impossibile da prevedere a lungo termine.

Per i sistemi che provocano fenomeni caotici non c'è mai ripetizione di alcuna traiettoria 
e non è possibile apprendimento.

**Azioni**:  L'unica strategia è azione-adattamento continuo.
*Esempio*: pilota che cerca di atterrare in condizioni meteo avverse.

+++++++++++++++++++++++++++++++++++++++++
Macchine, agenti, organismi
+++++++++++++++++++++++++++++++++++++++++

Per un ingegnere (del software, ma non solo) è anche utile introdurre una ultriore distinazione/classificazione
tra sistemi, distinguendo tra *macchine, agenti, agenti intelligenti e organismi*.
Ma prima, premettiamo alcune puntualizzazioni:

- **Le categorie non sono necessariamente disgiunte né nette**: un sistema può trovarsi “a metà” tra macchina e agente 
  oppure tra agente e agente intelligente, a seconda delle caratteristiche reali.
- **Dipendenza dalla scala di osservazione**: un “organismo” visto dall'esterno può mostrarsi come “molti agenti intelligenti” 
  o come “un agente intelligente”: la classificazione dipende da **chi osserva**, **come osserva**, e **perché**.
- **Arbitrarietà e finalità**: come per ogni classificazione, le categorie riflettono aspettative progettuali o analitiche: 
  cambiano se vogliamo modellare un software, un sistema biologico, un network sociale, un ecosistema.
- **Pericolosità di antropomorfismi**: attribuire “intelligenza”, “vita”, “autonomia” a sistemi software è 
  spesso metaforico: bisogna chiarire cosa intendiamo con quei termini, per evitare ambiguità o aspettative irrealistiche.

.. _Macchina:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Macchina
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Una macchina è un sistema chiuso, deterministico e creato artificialmente per raggiungere un obiettivo specifico.

Sistema fatto di parti che esistono l'una per l'altra.

Spesso non varia il proprio comportamento se non in modi predeterminati.

Le relazioni tra le parti sono lineari e l'analisi è di tipo scompositivo (riduzionistico).
La modifica di una macchina è di tipo reattivo (si aggiunge o toglie una parte)

.. _Sistema cibernetico:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Sistema cibernetico
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un sistema cibernetico è un sistema che regola il proprio comportamento tramite meccanismi di controllo e retroazione (feedback), 
adattandosi alle variazioni dell'ambiente per mantenere uno stato o conseguire uno scopo.


Il termine cibernetica deriva da una parola greca che significa “timoniere”, “colui che guida”.

Norbert Wiener (1894-1964), matematico statunitense, è considerato il padre della cibernetica.
Per Wiener, ciò che accomuna sistemi naturali e artificiali è la capacità di:

.. code::

  percepire → confrontare → correggere

Il ciclo percezione → controllo → azione → percezione è l'essenza del sistema cibernetico,
che offre modelli generaleidi regolazione e controllo capaci di unificare 
biologia, ingegneria, matematica, neuroscienze,
formalizzando il concetto di **feedback**.**

.. kybernḗtēs

.. _Agente:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Agente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Sistema (hardware-software) che interagisce con un ambiente: percepisce input (sensori o messaggi), 
produce output (attuatori o messaggi), ha un ciclo percezione - azione.

Opera in modo autonomo e prende decisioni senza essere controllato.

Ogni agente è un sistema cibernetico avanzato.
Non ogni sistema cibernetico è un agente.

L'idea di Russell & Norvig è
che un agente sia un sistema che mappa percezioni in azioni per massimizzare una misura di performance.

Questa definizione generalizza l'idea cibernetica:
i sistemi di Wiener erano soprattutto regolatori;
gli agenti introducono scelte orientate al futuro.

Occorrono precise assunzioni:

- Esistenza di un **ambiente con regolarità**: se l'ambiente fosse completamente caotico 
  *nessuna strategia sarebbe possibile*
- Esistenza di **obiettivi** (**telos** Aristotelico) e metriche di successo: un agente senza obiettivo è una macchina.
  Gli obiettivi possono esseere espliciti (goal logici), normativi, 
  funzioni di utilità nella Reinforcement Learning (RL)
- Capacità di **previsione** e (spesso) **modello del mondo**: 
  **modelli espliciti** (mondo rappresentato → GOFAI), 
  **stimatori statistici** (policy without model → RL),
  **pattern reattivi** (modello implicito → `Stigmergia`_)
  
  Il modello può essere **interno o distribuito**.
  Nelle società di agenti l'ambiente stesso può essere *parte della memoria collettiva*.

.. _Agente intelligente:


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Agente intelligente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un agente dotato di capacità di decisione flessibile, adattamento, ragionamento o apprendimento: 
cioè un sistema che, oltre a reagire, elabora conoscenza, valuta opzioni, può perseguire obiettivi.

Risulta efficace in una varietà di situazioni/ambienti.

Una defizione data da **Albus** nel 1991 è: agente capce di agire in modo appropriato in un abiente incerto
(ma regolare) dove le azioni appropriate sono quelle che aumentano la possibilià di successo.

.. _Organismo:


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Organismo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un organismo è un sistema aperto, dinamico che interagisce con l'ambiente e si adatta ad esso.

Sistema (vivente) le cui parti esistono anche l'una per mezzo dell'altra.

Esibisce *autopoiesi, omeostasi, adattamento evolutivo, autorganizzazione*: 
un insieme di sottosistemi integrati, capace di mantenerne l'identità, di auto-regolarsi, di evolvere.

Le relazioni tra le parti sono non lineari, con feedback complessi e l'analisi è di tipo olistico 
(si privilegia il tutto).

La modifica di una organismo è di tipo proattivo/evolutivo (si auto-organizza).


 



.. _Come si descrive un sistema:

---------------------------------------------
Come si descrive un sistema 
---------------------------------------------

La descrizione di un sistema può essere affrontata da diverse prospettive: una visione interna
(analitica o **WhiteBox**  o *come è fatto*), 
una visione esterna (o **BlackBox** o *come si usa*) 
e una visione **globale** o *sistemica* per sistema complessi,
che descrive le proprietà 'emergenti'.

.. _Visione BlackBox:

++++++++++++++++++++++++++++++++++++++++
Visione BlackBox
++++++++++++++++++++++++++++++++++++++++

La 'visione' dall'esterno di un sistema è lagata al modo con cui è possibile interagire 
(scambiare informazione) con il sistema.

.. L'atto di nascondere i dettagli implementativi ed esporre solo il comportamento essenziale è noto 
   come **Astrazione** o Occultamento dell'Informazione (**Information Hiding**).

- La semantica Black Box di un **sistema fisico**  è la funzione matematica o l'equazione differenziale 
  che lega l'Input all'Output nel tempo.  

  Una funzione del tipo ``O(t) = f(I(t))`` definisce il 
  significato del sistema per l'osservatore.
  Questo approccio è fondamentale per la Progettazione di *Sistemi di Controllo*, dove il controllore 
  (l'osservatore) deve interagire con la Black Box basandosi esclusivamente 
  sui segnali di ingresso e uscita per manipolare il suo comportamento.

- La semantica Black Box di un **sistema software**, è legata all'output emesso dal sistema
  sollecitato da un certo input; un osservatore del sistema non è interessato  
  quanti thread Java, quali protocolli di routing o quali algoritmi 
  il sistema utilizza internamente.

  L'interazione è legata
  al concetto di **Interfaccia Pubblica** del sistema 
  (ad esempio, le API REST di un servizio, la *Interface- di un object*, la *signature*- di una funzione). 
  Questa interfaccia funge da contratto tra il sistema e il mondo esterno, stabilendo l'unico 
  modo permesso per scambiare informazioni.

  L'atto di nascondere i dettagli implementativi ed esporre solo il comportamento essenziale è noto 
  come **Astrazione** o Occultamento dell'Informazione (**Information Hiding**).

.. _Visione WhiteBox:

++++++++++++++++++++++++++++++++++++++++
Visione WhiteBox
++++++++++++++++++++++++++++++++++++++++

Per descrivere un sistema 'dall'interno' occorrono **almeno tre dimensioni**: 
la dimensione **strutturale**, la dimensione della **interazione** e la dimensione 
del **comportamento** dei singoli componenti.

.. list-table:: 
  :widths: 15,40,45
  :width: 100%

  *
    - **Struttura**      
    - Descrive la disposizione fisica o logica degli elementi; i nodi e i collegamenti. 
      Risponde a: Quanti sono? Come sono connessi?
    - Distingue tra sistemi semplici (poche connessioni) e sistemi complicati o complessi (molte connessioni). 
  *
    - **Comportamento** 
    - Descrive Le regole interne e le capacità di elaborazione di ogni singolo elemento del sistema. 
      Risponde a: Cosa fa ogni parte?
    - Distingue i componenti rigidi/prevedibili da quelli autonomi/adattativi (essenziale per l'autoorganizzazione).
  *
    - **Interazione** 
    - Descrive la natura, la forza e la frequenza degli scambi di informazione/energia tra i componenti. 
      Risponde a: Come si influenzano a vicenda?
    - Cruciale per distinguere complicato (interazioni lineari e fisse) da complesso (interazioni non lineari e dinamiche) e caotico (estrema sensibilità).

.. Al fine di descrivee la natura (complesso, caotico, autoorganizzato) in modo completo
   di un sistema, è utile includere una **quarta dimensione** che è il risultato delle prime tre:

++++++++++++++++++++++++++++++++++++++++
Visione sistemica
++++++++++++++++++++++++++++++++++++++++

Questo livello descrive le proprietà che appaiono solo quando il sistema viene visto nel suo insieme,
quali la resilienza, l'adattabilità, il grado di prevedibilità e le proprietà emergenti.

E' un livello di descrizione tipico dei sistemi complessi, indipendente dal tipo di componente. Pone
il focus su pattern di interazione, topologie, coordinazione, flussi informativi.

.. _More is different:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
More is different
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Quando un sistema cresce in dimensione, diventa diverso in natura. 
*Philip W. Anderson* sintetizza gia nel 1972 questa idea con il celebre motto **“More is different”**.
L'aumento del numero di elementi porta all'emergere di proprietà globali non prevedibili analizzando 
i singoli componenti.

Le proprietà di un insieme di molti elementi non sono riducibili alla somma delle proprietà dei singoli elementi.

Tali proprietà richiedono un diverso linguaggio descrittivo, focalizzato sulle interazioni 
e sugli schemi collettivi, aprendo la strada a una visione sistemica del software.
Per sistemi complessi software — come gli ecosistemi di servizi distribuiti o gli insiemi massivi di attori — 
questa visione è oggi indispensabile per comprendere e progettare comportamenti emergenti, robustezza e adattamento.


La frase di Anderson diventa anche un principio di progettazione:

Quando i componenti diventano molti, ciò che conta non è cosa fanno, ma come interagiscono

 
-----------------------------------------------------------------
Perchè i sistemi complessi
-----------------------------------------------------------------

Per un ingegnere del software è necessario avere consapevolezza di cosa sia un sistema complesso
perchè:

- i sistemi software moderni non sono solo più macchine gerarchiche e deterministiche:
  sono ecosistemi di servizi, microservizi, agenti, attori, componenti autonomi.
- il software moderno è quindi distribuito, eterogeneo, autonomo, adattivo, connesso in rete: 
  cioè possiede molte delle proprietà osservate nei sistemi complessi naturali.

Mentre il 'pensiero sistemico' iniziò la sua ascesa negli anni Venti del secolo scoro, 
la scienza ha cominciato a parlare esplicitamente e a fondo di "sistemi complessi" con le teorie di *Prigogine* 
(anni Settanta) 
e con l'emergere della matematica non lineare (caos, frattali, dinamica dei sistemi, 
formalizzata dagli anni Ottanta in poi), portando alla nascita della **Scienza della Complessità** negli anni Novanta.

Si può usare la metafora di una montagna: per molti anni la scienza ha concentrato l'attenzione sulla "**fisica dell'ordine**" 
(sistemi semplici) e sulla "**fisica del disordine**" (sistemi con moltissime variabili non correlate), 
lasciando la "complessità organica" (la vetta del monte) in gran parte inesplorata fino alla fine del ``XX`` secolo. 

La possibilità di *scalare la vetta della complessità* si è aperta con l'avvento dei computer e delle nuove 
tecniche matematiche, che hanno permesso di esplorare la "scala mesoscopica" dei fenomeni biologici e sociali.

Alcuni tratti ricorrenti in questo nuovo campo disciplinare sono riassunti nella tabella che segue:

.. list-table::
   :header-rows: 1
   :widths: 25 75  

   - - Tratto distintivo
     - Significato
 
   - - Molte entità interagenti
     - Un sistema è composto da un gran numero di componenti autonomi che agiscono localmente.

       **Esempi:** Formicai, reti di microservizi, reti neurali biologiche o artificiali.
   - - Interazioni non lineari
     - Le interazioni non si sommano in modo proporzionale: piccole cause possono produrre grandi effetti e viceversa.
       
       **Esempi:** Mappa logistica, epidemie, amplificazione in reti sociali.
   - - Retroazioni (feedback)
     - Gli effetti delle azioni dei componenti ritornano a influenzarli, creando cicli di amplificazione o stabilizzazione.
       
       **Esempi:** Controllo ormonale, circuiti di feedback nei sistemi autonomi e nei sistemi ecologici.
   - - Auto-organizzazione
     - L'ordine globale emerge spontaneamente dalle interazioni locali, senza un controllo centralizzato.
       
       **Esempi:** Sincronizzazione delle lucciole, flocking degli uccelli, clustering spontaneo in robotica swarm.
   - - Transizioni ordine/disordine
     - Il sistema può passare bruscamente da stati stabili a stati caotici o viceversa, spesso in corrispondenza di soglie critiche.
       
       **Esempi:** Transizioni di fase nella materia, collasso di reti infrastrutturali, criticalità auto-organizzata.
   - - Emergenza di pattern globali
     - Comportamenti collettivi non prevedibili dalle singole parti, ma derivanti dalle loro interazioni.
       
       **Esempi:** Pattern del Game of Life, onde di traffico, comportamenti collettivi nei social network.

Inoltre:

.. list-table::
   :header-rows: 1
   :widths: 25 75  

   - - Tratto distintivo
     - Significato
  
   - - Adattamento
     - Il sistema modifica la propria struttura o comportamento in risposta all'ambiente o a pressioni interne.
       
       **Esempi:** Algoritmi genetici, ecosistemi, sistemi software self-adaptive.
   - - Sensibilità alla topologia delle interazioni
     - La forma della rete di connessioni influisce profondamente sulla dinamica del sistema.
       
       **Esempi:** Reti small-world (diffusione rapida), reti scale-free (robuste ma fragili ai nodi-hub), reti multilivello.

   - - Dinamiche collettive lontane dall'equilibrio
     - Il sistema opera in condizioni non stazionarie, mantenute da flussi costanti di energia, materia o informazione.
    
       **Esempi:** Reazioni chimiche oscillanti (Belousov–Zhabotinsky), mercati finanziari, sistemi distribuiti event-driven.


+++++++++++++++++++++++++++++++++++++++
La sinergetica
+++++++++++++++++++++++++++++++++++++++

Una delle cornici interpretative fondamentali per comprendere la natura dei sistemi complessi
è la sinergetica_, introdotta da **Hermann Haken**, l'invetore del *Laser*.

La sinergetica descrive come l'auto-organizzazione emerga tramite parametri d'ordine, 
modi instabili e il principio di asservimento, secondo cui il comportamento collettivo domina 
e coordina quello dei singoli componenti.
E' uno dei “ponti” più eleganti tra: 

- fenomeni fisici quali: auto-organizzazione, emergenza, dinamiche collettive, transizioni ordine/disordine,
  asservimento

e 

 - l'ingegneria di sistemi autonomi e distribuiti, in cui un insieme di microservizi o attori autonomi 
   può generare spontaneamente *parametri d'ordine* quali sincronizzazione, consenso, oscillazioni, propagazioni,
   *asservimento* tramite orchestrazione e coreografia, *transizioni critiche* collegabili
   alla resilienza dei microservizi, ai circuit breakers, alle cascading failures, alle reti scale-free.

Il video: `Il Sorprendente Segreto della Sincronizzazione`_ fornisce una panoramica di alcuni 
interessanti (e fondamentali) fenomeni di sincornizzazione naturale.
Se ne consiglia vivamente la visione.

++++++++++++++++++++++++++++++++++++++
Teoria delle reti
++++++++++++++++++++++++++++++++++++++

Un modo ritenuto efficace per descrivere sistemi (complessi) e la loro dimensione 
globale/emergente è ricorrere ai modelli di rete (o teoria dei grafi). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Griglie e grafi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Una **griglia**, o reticolo regolare (lattice), è un tipo specifico di grafo caratterizzato da una 
topologia altamente regolare e locale.:

- ogni nodo è collegato allo stesso numero fisso di vicini (es. ``4`` in una griglia ``2D``, ``6`` in una 3D)
- l'informazione si diffonde lentamente e in modo prevedibile
- non mostrano un'emergenza forte o un comportamento a "piccolo mondo";
  descrivono sistemi complicati o al massimo semplici-complessi. 

Un **grafo** generico non ha restrizioni sulla sua topologia

- il numero di connessioni per nodo varia enormemente
- possono esistere "salti" o hub che collegano nodi lontani
- descrivono sistemi complessi e autoorganizzati. 
  Mostrano emergenza, resilienza e vulnerabilità (dipendente dalla topologia).

La teoria delle reti basata su grafi è la **grammatica formale della complessità**, e permette di spostare la discussione 
dalla specificità dei componenti (Java, router, gene) alla topologia che determina il comportamento globale 
(complesso, autoorganizzato, caotico).

Ad esempio, modelli che descrivono come l'organizzazione (l'ordine) emerge in reti complesse sono:


1. **Reti Casuali** (*Erdős-Rényi*)

  Queste reti servono da base di confronto. Le connessioni sono disposte in modo puramente casuale.

  - **Limitazione**: Non descrivono adeguatamente la maggior parte dei sistemi reali 
    (Internet, reti biologiche, reti sociali) che hanno strutture molto più organizzate.

2. **Reti a Piccolo Mondo** (*Watts e Strogatz*)

  Le `Small world network`_ hanno un alto coefficiente di clustering (i miei amici sono amici tra loro, 
  come nelle reti sociali) ma anche una corta distanza media tra i nodi 
  (di veda la proprietà dei `sei gradi di sperazione`_).

  - **Significato**: Favoriscono la diffusione efficiente dell'informazione o delle malattie.

3. **Reti Scale-Free** (*Barabási-Albert*) 

  Questo è il modello che meglio descrive Internet e molte reti biologiche.

  - **Caratteristica**: La distribuzione dei gradi dei nodi segue una legge di potenza. 
    Ci sono pochissimi nodi con un numero estremamente elevato di collegamenti (gli hub) 
    e molti nodi con pochissimi collegamenti.
  - **Meccanismo**: Nascono da un meccanismo di **preferential attachment**
    (effetto San Matteo: "i ricchi diventano più ricchi").

  - Proprietà Emergenti:

    - **Robustezza**: La rete è estremamente resistente al fallimento casuale dei nodi 
      (perché la maggior parte dei nodi non sono hub).
    - **Vulnerabilità**: È estremamente vulnerabile a un attacco mirato contro gli hub.



==============================================
Modelli formali
==============================================

**Per descrivere qualcosa occorre un linguaggio.**

La necessità di modellare l'imprevedibile e l'emergente ha richiesto, nel caso dei sistemi
fisici,  nuovi strumenti matematici e, nel caso dei sistemi software, nuovi paradigmi computazionali.

.. una volta appurato che molta parte del software moderno possiede le stesse proprietà osservate 
  nei sistemi complessi naturali.

Per i **sistemi fisici**, la *nuova matematica* è basata su dinamica non lineare (attrattori, biforcazioni, caos),
automi cellulari e sistemi discreti, teoria dei frattali, teoria delle reti complesse,
sinergetica.
Questi formalismi non sostituiscono la matematica classica, ma la estendono e la rendono applicabile 
a fenomeni emergenti con molti gradi di libertà.

In modo analogo, per i **sistemi software**
l'approccio  classico alla progettazione e costruzione di sistemi (OOP + `UML`_ + programmazione sequenziale/imperativa) 
risulta insufficiente per affrontare problemi in cui vi sono molti componenti che operano
come enti autonomi che interagiscono scambiandosi messaggi, in assenza di memoria comune.

Al concetto di **oggetto** come tipico componente-base per  molti linguaggi general purpose (**GPL**) 
**occorre affiancare** oggi concetti quali  **attore** e **agente** come enti autonomi che interagiscono a messaggi.
Questi concetti permettono di 'disgregare' le tradizionali **architetture monolitiche** dei sistemi a favore
di archietture distribuite, quali quelle, oggi molto diffuse,  basate su 
**microservizi**.

.. _Il motto di Alan Kay:

-----------------------------------------
Il motto di Alan Kay
-----------------------------------------

Come ingegneri del software, è ncessario capire i dettagli e le motivazioni della continua evoluzione
dei linguaggi di programmazione, assumendo il quadro concettuale di riferimento enfatizzato da `Alan Kay`_ 
(il promotore del linguaggio **Smalltalk**, uno dei progenitori della *OOP*):

.. code::

  Un linguaggio di programmazione è come ali per i nostri pensieri, 
  ma è anche le catene che non ci permettono  di volare più in alto.

Questo riassume l'idea che i linguaggi (di programmazione, ma non solo) ci consentono di **esprimere concetti** che altrimenti 
sarebbero inesprimibili (le **ali**), ma le loro limitazioni intrinseche (la loro sintassi/semantica) possono 
impedirci (le **catene**) di concepire soluzioni più radicali o potenti .

------------------------------------------------------
Dai modelli ai linguaggi
------------------------------------------------------

L'evoluzione dei linguaggi di programmazione (``LdP``) si fonda  su una lunga storia di idee matematiche 
che hanno cercato di definire in modo preciso che cosa significhi **calcolare**. 
Prima ancora che il software esistesse come disciplina autonoma, matematici, logici e filosofi 
si trovarono di fronte a un quesito fondamentale: 
**esiste un limite intrinseco a ciò che una procedura meccanica può fare?**

La risposta a questa domanda richiedeva di esplicitare che cosa fosse, esattamente, 
una “procedura meccanica”. Ovvero: un **modello formale** del calcolo.

È in questo contesto che nasce, negli **anni '30** del Novecento, la **Macchina di Turing** 
(proposta da `Alan M. Turing`_), 
insieme ad altri formalismi equivalenti proposti quasi in parallelo:

- il :math:`\lambda` **calcolo** di Alonzo Church,
- le **funzioni ricorsive** di Gödel, Herbrand e Kleene,
- i **sistemi di riscrittura** di Post e Markov.

Pur diversi nella forma, questi modelli condividono una sorprendente convergenza: 
definiscono tutti la stessa classe di funzioni calcolabili. Da qui il **teorema di Church-Turing** 
e la tesi filosofica omonima: tutte le nozioni ragionevoli di “calcolo effettivo” coincidono.

Questa prima stagione dei formalismi nasce dunque **prima dei linguaggi di programmazione**, 
e non per scopi ingegneristici, ma **per rispondere a domande di logica matematica e fondamenti**: 
cosa può essere calcolato? cosa non può esserlo? cosa significa *“algoritmo”*?

I primi linguaggi di programmazione, come ``Fortran``, ``Lisp``, ``Algol``, arriveranno *dopo*, 
come reinterpretazione pragmatica dei formalismi astratti. 
In alcuni casi (come ``Lisp``) il riferimento alla teoria è diretto; 
in altri (come ``C`` o ``Java``) è implicito.

-----------------------------------------------
Macchine astratte
-----------------------------------------------

.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - Spesso si qualifica il comportamento di un componente facendo riferimento a tipi diversi di 
      :blue:`macchine astratte`, iniziando dalla 
      `Turing Machine`_ (**TM**), che individua, in stile imperativo, le mosse-base (*primitive*) 
      di un automa che permette di :remark:`realizzare qualunque calcolo` (!).
    - .. image:: ./_static/img/TuringMachine.PNG
        :width: 100%
        :align: center
      
      .. Si veda `Raspberry Pi TM`_


Un tipo meno potente di macchina astratta rispetto alla **TM** è il `pushdown automaton`_ (**PDA**) che però è l'automa 
di riferimento per il riconoscimento delle frasi di un inguaggio con *sintassi context-free*, di tipo 2 nella 
`gerarchia di Chomsky`_ , che introdurremo nella sezione :ref:`Macchine astratte per riconoscere linguaggi`. 

 
------------------------------------------------------
La Macchina di Minsky
------------------------------------------------------

La macchina di Turing (TM) definisce un insiene di mosse con riferimento a un nastro e una testina.
Una classe di macchine astratte che si dimostrano equivalente alla TM è quella
delle macchine a registro o `Counter machine`_.
Una macchina di questa classe possiede un numero finito (``N``) di registri (contatori)
(chiamati ``R_1, R_2,..., R_N``).

La *Macchina di Minsky* è stata proposta da 
`Marvin Minsky`_ nel **1961**, dimostrando 
soli due registri (``N=2``) bastano per
simulare qualsiasi TM (e quindi eseguire qualsiasi algoritmo).

La *Macchina di Minsky* è caratterizzata da solo due tipi di istruzioni:

  .. list-table:: 
    :widths: 35,65
    :width: 100%
      
    - - **INC(R_i, j)**
      - Incrementa il registro ``R_i di 1. Salta all'istruzione j``. (Senza condizione)
    - - **DEC_JUMP(R_i, j, k)**
      - Se il registro ``R_i > 0, decrementalo di 1 e salta all'istruzione j``. 
        Altrimenti (se ``R_i = 0``), salta all'istruzione ``k``


Notiamo come questo modo di esprimere le operazioni elementari che stanno alla base del calcolo
è più vicina alla nostra idea di computer come macchina capace di eseguire un insieme di 
mosse elementari, funzionando come **interprete** del `Linguaggio assembly`_.


------------------------------------------------------
Problemi non riducibili (Indecidibili)
------------------------------------------------------

Vi sono problemi per cui è stato dimostrato che una TM (o formulazioni equivalenti) **non** 
può produrre una risposta in un tempo finito. Tra i più noti di questi ricordiamo:

-  Il Problema dell'Arresto (**Halting Problem**): 
   Data una descrizione di un programma (o TM) e il suo input, esisterà un algoritmo in grado di 
   determinare se quel programma terminerà (si arresterà) o continuerà a funzionare indefinitamente 
   (loop infinito)?
- Il Problema della Decidibilità (**Entscheidungsproblem**): 
  Esiste un algoritmo che possa decidere, data una proposizione logica espressa nella logica del primo ordine, 
  se quella proposizione è universalmente valida (vera in ogni modello)?
- Equivalenza dei Linguaggi Liberi dal Contesto (**CFG Equivalence**):
  Date due grammatiche libere dal contesto (CFG), generano esattamente lo stesso linguaggio?  

L'*Entscheidungsproblem* fu posto da `David Hilbert`_ nel ``1928``. Sotto la guida di *Hilbert*, 
`John von Neumann`_, nei suoi anni giovanili, si fece portabandiera dell'approccio assiomatico della matematica,
riconoscendo subito il valore dei contributi di   `Kurt Gödel`_ (Teoremi di incompletezza )
che evidenziarono l'impossibilità di conseguire una dimostrazione completa della coerenza 
dell'aritmetica nel contesto del pensiero matematico.


L'indecidibilità di un problema ``P_2`` viene di solito dimostrata riducendolo a un problema ``P_1`` 
che è già noto come indecidibile.

La maggior parte delle prove di indecidibilità nel campo dei linguaggi di programmazione o 
delle proprietà dei programmi fa riferimento a un potente strumento formale basato sul concetto di riduzione: 
il `Teorema di Rice`_.

+++++++++++++++++++++++++++++++++++++
Il Teorema di Rice
+++++++++++++++++++++++++++++++++++++

Il Teorema afferma che:

Qualsiasi proprietà *non banale* sul linguaggio (o sulla funzione) calcolato da una 
Macchina di Turing è indecidibile.

- **Proprietà**: Una caratteristica che un programma può avere 
  (es. "termina sempre", "stampa sempre 10 numeri", "non entra mai in loop").
- **Non banale**: Una proprietà che non è posseduta da tutti i programmi né da nessun programma. 
  (Ad esempio, "essere un programma" è banale; "essere un programma che calcola :math:`\pi` è non banale).


Esempio: Vogliamo dimostrare che decidere se un programma ``C++`` stamperà "Hello World" è indecidibile.

Definiamo la proprietà ``P``: "Il programma stampa 'Hello World'.
``P`` è non banale (esiste un programma che lo fa, e uno che non lo fa).
Per il Teorema di Rice, la decisione se un dato programma possiede la proprietà ``P`` è indecidibile. 
Non si può costruire un algoritmo generale per questo.


.. - Il Problema di Corrispondenza di Post (Post Correspondence Problem, PCP):

.. una macchina a registro utilizza più registri con indirizzo univoco per memorizzare interi non negativi

.. https://en.wikipedia.org/wiki/Counter_machine


------------------------------------------------------
Cosa significa 'costruire'
------------------------------------------------------
Dunque, i formalismi servono non solo per costruire, ma anche per **sapere cosa possiamo o non possiamo ottenere**:

Questi limiti sono fondamentali per gli ingegneri: **modellano il territorio** in cui è possibile progettare.


Sulla base dei concetti introdotti, possiamo cercare di catturare meglio il significato del temine *'costruire'*
nell'ambito del software:


.. code::

  Costruire significa combinare elementi di base secondo regole definite 
  per ottenere nuove entità o comportamenti.
  Quando queste combinazioni sono lineari, otteniamo strutture prevedibili.
  Quando invece le interazioni tra componenti generano proprietà non deducibili  
  dai singoli, la costruzione diventa sorgente di complessità ed emergenza.

Notiamo che gli elementi-base nella costruzione di sistemi software sono le istruzioni interpretabili
da un computer, che , per la tesi di Church Turing, definiscono anche di fatto ciò che è 'costruibile'
mediante il softwware.


.. _Computazionalmente completo:

+++++++++++++++++++++++++++++++++++++++++++
Computazionalmente completo
+++++++++++++++++++++++++++++++++++++++++++

In informatica teorica si usa spesso il concetto di **Turing completezza**:

.. note::
 
  Un linguaggio è Turing-completo (*Computazionalmente completo*) se può simulare qualsiasi macchina di Turing.

Questo significa che:

- può **leggere** e **scrivere** memoria arbitraria
- può eseguire **controllo del flusso** (cicli, ramificazioni, ricorsione)
- può comporre operazioni in modo **illimitato**


I GPL conservano queste proproetà anche quando offrono la capacità di 
costruire sistemi basati su componenti quali oggetti attori, etc.
Ciascun componente viene *alla fine* eseguito 
(grazie ai compilatori e interpreti)
da istruzioni macchina e dunque mantiene la Turing-completezza del sistema.

Ci sono modelli di calcolo o anche:ref:`Domain-Specific Languages (DSL)`  **deliberatamente** non universali, 
per tre motivi principali:

- **Verificabilità** : SL reattivi senza ricorsione → analisi statica garantita            
- **Sicurezza**:   Smart Contracts (e.g., Tezos Michelson) → prevenzione infinite loops 
- **Semplificazione concettuale**  DSL dichiarativi per configurazione (SQL senza ricorsione)           


.. _Teoria Algoritmica dell'Informazione:

------------------------------------------------------
Teoria Algoritmica dell'Informazione
------------------------------------------------------

La **Teoria Algoritmica dell'Informazione** (**AIT**) può essere vista come la versione "metrica" 
della teoria di Turing. 
Se Turing si occupava di ciò che può essere fatto (**possibilità**), la AIT si occupa di quanto costa farlo 
in termini di bit (**complessità**). In sintesi:

.. list-table:: 
    :widths: 50,50
    :width: 100%
      
    - - **Teoria della Computabilità**
      - **Teoria Algoritmica dell'Informazione**
    - - Si chiede: "Esiste un algoritmo per questo?"
      - Si chiede: "Qual è l'algoritmo più breve per questo?"
    - - Si concentra sull'esistenza del calcolo.
      - Si concentra sulla compressione del calcolo.
    - - Risultato chiave: Il Problema dell'Arresto.
      - Risultato chiave: L'Incomputabilità della Complessità.

Fondata negli anni '60 da *Andrej Kolmogorov*, *Gregory Chaitin* e *Ray Solomonoff*, 
la **AIT** definisce l'informazione non come una probabilità statistica (come faceva Shannon), 
ma come **struttura e contenuto**.  Riportiamone i punti salienti:

Questa transizione dalla filosofia di Platone alla **Teoria Algoritmica dell'Informazione (AIT)** è il coronamento logico del tuo ragionamento. Se Platone cercava l'essenza delle cose nel mondo delle Idee, l'AIT la cerca nella **lunghezza del programma più breve** capace di generare quella cosa.

Fondata negli anni '60 da **Andrej Kolmogorov**, **Gregory Chaitin** e **Ray Solomonoff**, 
questa teoria definisce l'informazione non come una probabilità statistica (come faceva Shannon), 
ma come **struttura e contenuto**.

Riportiamo i punti concettuali salienti:
 

 

- **La Complessità di Kolmogorov**

    Il concetto cardine è che la complessità di un oggetto (come una configurazione del gioco :ref:`Conway Game of Life`) 
    è definita dalla **lunghezza del programma più breve che lo può produrre**.

    K(s) = min { |p| : U(p) = s }

    Dove s è la stringa, p è il programma e U è una macchina di Turing universale.

    * **Bassa Complessità (Senso):** Una griglia piena di "Block" stabili ha una  molto bassa, 
      perché si può scrivere: `"Disegna un quadrato ogni 5 pixel"`.
    * **Alta Complessità (Caos):** Una griglia di rumore casuale ha una K altissima, perché l'unico modo 
      per descriverla è elencare lo stato di ogni singolo cella: `"Cella 1 viva, 2 morta, 3 morta..."`.

 

- **La Casualità come Incomprimibilità**

  Per l'AIT, un oggetto è **casuale** se non può essere compresso.
  Se non trovi un algoritmo più breve della stringa stessa per descriverla, allora quella stringa non ha "senso" 
  o "struttura" logica; è rumore puro.

  Questo si ricollega al fatto che il "senso" emerge quando l'osservatore trova una **compressione algoritmica** 
  (una regola) in ciò che vede. Vedere un "Glider" è un atto di compressione: invece di 5 bit sparsi, 
  si 'vede' un'unica "entità" che si muove.

 

- **L'Induzione di Solomonoff e il Rasoio di Occam**

  Solomonoff ha usato l'AIT per formalizzare matematicamente il Rasoio di Occam. La teoria dice che:

  "Tra tutte le ipotesi che spiegano i dati osservati, quella più probabile è la più corta 
  (quella con la minore complessità algoritmica)."

  Nel :ref:`Conway Game of Life`, se si vede uno schema che sembra muoversi, 
  il cervello sceglie l'ipotesi "È un oggetto semovente" perché è algoritmicamente più semplice che pensare 
  "Sono centinaia di pixel indipendenti che cambiano stato per puro caso in modo coordinato". 
  **Il 'sensoì è la spiegazione più economica.**

 
- **Il Numero Omega di Chaitin**
 
  Gregory Chaitin ha portato la teoria verso l'ignoto con , la "probabilità di arresto". :math:`\Omega`
  è un numero reale che esprime la probabilità che un programma generato casualmente si fermi.

  - :math:`\Omega` è **incalcolabile** e racchiude in sé la soluzione a ogni problema matematico.
  - Rappresenta il limite estremo della conoscenza: esiste una saggezza (informazione) che nessuna logica può estrarre in modo sistematico.

    **Senza un osservatore che cerchi la compressione, l'universo è solo una stringa incomprimibile di bit casuali.**

 
- **Il Problema della "Non-Computabilità"**
 
  Un punto critico discusso nella letteratura del 2025 è che la complessità di Kolmogorov è non computabile 
  (non esiste un algoritmo generale per trovarla sempre). 
  Questo riflette l'idea di Dennett secondo cui non esiste una "prospettiva divina" per identificare tutti i pattern; 
  la loro scoperta dipende dalla nostra capacità (limitata ma efficace) di trovare scorciatoie matematiche 
  e predittive nel caso dei dati.

 
- **La Complessità di Kolmogorov come Misura della Realtà**
 
  - **Definizione di Pattern**: Negli studi recenti, un pattern dennettiano è definito come una descrizione 
    compressa dei dati. Se un sistema ha una complessità di Kolmogorov \(K(x)\) significativamente inferiore 
    alla lunghezza dei dati grezzi, allora quel sistema contiene un "real pattern".
  - **Ontologia algoritmica**: La realtà di un'entità (come un "glider" nel Gioco della Vita) non dipende 
    dalla sua sostanza, ma dal fatto che l'algoritmo per descrivere il sistema diventa drasticamente 
    più corto se includiamo quel pattern nella nostra "ontologia".

 
- **Il Modello del "Minimum Description Length" (MDL)**
 
  Nel volume del 2026 di Dennett *Real Patterns in Science and Nature* (MIT Press), i ricercatori utilizzano 
  il principio del *Minimum Description Length* per risolvere il dibattito tra realismo e strumentalismo: 

  - **Pattern e Rumore**: MDL permette di bilanciare la precisione (aderenza ai dati) e la semplicità 
    (brevità della descrizione).
  - **Criterio di Oggettività**: Un pattern è considerato "reale" se e solo se la sua inclusione nel modello 
    riduce la lunghezza totale della descrizione, pur "pagando" il costo di ignorare un po' di rumore. 

+++++++++++++++++++++++++++++++++++++++++++++++
Applicazione all'Intelligenza Artificiale 
+++++++++++++++++++++++++++++++++++++++++++++++

Ricerche pubblicate tra il 2025 e l'inizio del 2026 collegano i pattern di Dennett al funzionamento 
dei Large Language Models (LLM): 

- **Emergenza**: Le capacità di ragionamento "zero-shot" dei modelli transformer sono interpretate 
  come l'estrazione di pattern reali (strutture semantiche e logiche) da moltitudini di dati grezzi.
- **Codifica Predittiva**: La mente umana e l'IA sono viste come "motori di compressione" 
  che estraggono pattern reali per minimizzare l'errore di previsione, una tesi che unifica 
  l'epistemologia di Dennett con le neuroscienze computazionali moderne. 




------------------------------------------------------
Perché la storia non si è fermata a Turing
------------------------------------------------------

Con l'evoluzione dei computer, è diventato evidente che i sistemi reali non si riducono a 
funzioni matematiche che trasformano un input in un output. 


+++++++++++++++++++++++++++++++++++++++++++++++
Evoluzione del concetto di Ccmputazione 
+++++++++++++++++++++++++++++++++++++++++++++++

Dal ``1940`` al ``1970``, il computer era visto essenzialmente come l'implementazione fisica della Macchina di Turing 
o della Macchina di Von Neumann. A un computer veniva affidato il compito di eseguire un **Algoritmo**,
cioè una sequenza finita e ben definita di istruzioni per risolvere un problema specifico o eseguire un calcolo.

Un computer classico (CPU) opera eseguendo istruzioni codificate (linguaggio macchina), 
agendo come un **interprete di un linguaggio formale**. 
Ogni livello software (dal linguaggio di alto livello fino al microcodice) è un'astrazione 
che viene *interpretata in istruzioni più fondamentali* (elementi di base).

Dopo il ``1970``, con l'avvento dei sistemi interattivi, delle reti e di Internet,
i problemi da risolvere non erano più solo di calcolo, ma di organizzazione e interazione con il mondo reale, 
con gli utenti e con altre macchine. Vi sono state 'forze' che hanno sprinto 
verso nuove frontiere: 

- **Complessità Crescente**: I programmi sono diventati troppo grandi per essere gestiti come un unico algoritmo, 
  portando alla necessità di modularità, astrazione e occultamento dell'informazione, come negli oggetti software
  e nei (micro)servizi.

- **Requisiti di Interazione**: L'informatica si è spostata dal calcolo puro all'interazione continua 
  (sistemi operativi, reti, database, interfacce utente). 
  La "correttezza" non è solo la correttezza algoritmica, ma la correttezza comportamentale in un ambiente dinamico.

- **Ingegneria del Software**: Si è riconosciuta la necessità di discipline ingegneristiche per gestire 
  l'intero ciclo di vita del software, superando la sola logica algoritmica.

Emergono nuove esigenze:

- **concorrenza** e processi che evolvono in parallelo;
- **comunicazione** tra entità autonome;
- **distribuzione** e assenza di una memoria centrale;
- **mobilità** di codici e canali;
- **stocasticità** e incertezza;
- **comportamenti globali emergenti** da interazioni locali.

La *Macchina di Turing* non basta più per descrivere questi fenomeni. 
Non è sbagliata: è solo **inadatta** al nuovo dominio.



.. Oggi, l'algoritmo è il "motore logico" necessario, ma il sistema software è la "struttura complessa" 
    che rende quel motore utilizzabile e funzionale nel mondo reale.

Il concetto di computazione si è amplia progressivamente, passando dall'idea di calcolo 
simbolico/algoritmico a nuove forme, quali:

- **Computazione come processo strutturato** (anni 60-80) in cui La computazione non è più solo trasformazione di simboli, 
  ma organizzazione di processi concettuali, legati alla evoluzione del software (Programmazione strutturata, oop, etc.).
- **Computazione come concorrenza e comunicazione** (anni 70-oggi) in cui computazione diventa interazione, non più solo calcolo
  e calcolare significa “scambiare informazione”, non eseguire funzioni matematiche
- **Computazione come sistema complesso** (anni 90-oggi) in cui la la computazione viene vista come 
  entità che cooperano o competono, eventi asincroni, comportamento emergente, auto-organizzazione

I paradimgi computazionali oggi studiati 
dal `Natural computing`_ , vengono astratti da fenomenic naturali diversi come 
l'auto-organizzazione, l'evoluzione Darwiniana, il comportamento di gruppo (Swarm intelligence),
il sistema immunitario, fino alla idea (*Zuse-Fredlink*) che l'informazione 
sia più fondamentale della materia o dell'energia e che l'universo stesso sia un computer 
quantistico (*Seth LLyod*) che computa il suo proprio comportamento.



.. Tenendo conto poi della ricerca nella :ref:`Comutazione quantistica<Il computer quantistico>`,
   *Computazione biologica- (`Computer a DNA`_), Computation neurale (reti neurali profonde),
  *Computazione naturale- (`Natural computing`_ ) l'idea di computazione diventa più ampia:
   Computare significa *evolvere fisicamente secondo regole informazionali*.

Si assiste così a una esplosione di nuovi formalismi, ognuno dei quali nasce per rispondere a una “forza storica” precisa:

- **la concorrenza** → `CCS`_ (Milner) e `CSP`_ (Hoare), :math:`\pi`-calcolo (`Pi calcolo`_);
- **il comportamento reattivo** → automi, transizione di stato, model checking;
- **la computazione distribuita** → Actor Model (Hewitt, Agha), Join Calculus;
- **la mobilità** → Mobile Ambients (Cardelli), :math:`\pi`-calcolo mobile;
- **il caso e la variabilità** → :math:`\pi`-calcolo stocastico (Priami), Markov Processes;
- **la computazione globale** → Field Calculus, Aggregate Computing (Beal, Viroli).

In ognuno di questi casi, il formalismo nasce *prima* dei linguaggi di programmazione che ne derivano.
Ad esempio:

- **Lisp** come incarnazione del :math:`\lambda`-calcolo;
- **Erlang, Akka, Orleans** come discendenti dell'Actor Model;
- **Go, Rust async, CSP libraries** ispirate a CSP;
- **Proto, Scafi** ispirati al Field Calculus;
- **AmbientTalk, Klaim** ispirati alla mobilità dei processi.

 
++++++++++++++++++++++++++++++++++++++++++++++++++
Verso la definizione di 'sistemi che calcolano'
++++++++++++++++++++++++++++++++++++++++++++++++++

Una estrema sintesi dell'evoluzione storica è che si passa:

1. **dal calcolo come trasformazione di funzioni**,
2. **al calcolo come parallelismo  e interazione**,
3. **al calcolo come comportamento collettivo**,
4. **al calcolo come fenomeno emergente**.

Questo cambiamento è profondamente legato alla trasformazione dell'ingegneria del software:
oggi non costruiamo più singoli algoritmi, ma **sistemi distribuiti**,  **microservizi**, 
**reti di attori**, **sistemi complessi software**.



++++++++++++++++++++++++++++++++++++++++++++++++++
Alcuni dei promotori
++++++++++++++++++++++++++++++++++++++++++++++++++

Dalla *Macchina di Turing* ai calcoli concorrenti, fino ai modelli per sistemi complessi, 
la storia dei formalismi è la storia dell'evoluzione della computazione stessa: 
da operazioni meccaniche a fenomeni collettivi autonomi.

Ricordiamo alucni degli studiosi che hanno aperto le diverse strade che oggi possiamo percorrere:  

- **Alan Turing**,  la computazione come processo meccanico sequenziale.
- **Alonzo Church**,  la computazione come trasformazione simbolica (:math:`\lambda`-calcolo).
- **Stephen Kleene**, **Gödel**, **Herbrand**, computazione come ricorsione.
- **Emil Post**, **Markov**, riscrittura e manipolazione di stringhe.
- **Robin Milner**, **Tony Hoare**, processi concorrenti e comunicazione.
- **Carl Hewitt**, **Gul Agha**, attori come entità autonome.
- **Luca Cardelli**, **Andrew Gordon**, mobilità e confini (*Ambient Calculus*).
- **Luca Cardelli**, **Gierz**, **Milner**, transizioni di stato e sistemi dinamici.
- **Radhika Nagpal**, **Beal**, **Viroli**, computazione di campo e self-organization.
- **Christopher Langton**, **Stuart Kauffman**, **Per Bak**, sistemi complessi e auto-organizzazione.

Queste figure non hanno solo inventato formalismi: 
hanno introdotto **nuovi modi di pensare** il calcolo.



+++++++++++++++++++++++++++++++++++++++++
Oltre la macchina di Von Neumann
+++++++++++++++++++++++++++++++++++++++++

GPU TPU?

L'architettura di Von Neumann — processore centrale (CPU) + memoria separata + esecuzione sequenziale di istruzioni — 
rimane il modello di riferimento per la maggior parte dei computer moderni.
Tuttavia, pone limiti ben noti:

-  buona flessibilità generale
-  colli di bottiglia nell'accesso alla memoria
-  limitata parallelizzazione
-  inefficienza energetica con carichi massivamente paralleli

Da qui deriva la nascita di **nuove architetture**, orientate a superarne i limiti su compiti specifici.
Non è questa le sede per entrare nei dettagki di queste nuove architetture. Riportiamo solo un
quadro sintetico delle alternative oggi più diffuse:

  .. list-table:: 
    :widths: 25,25,25,25
    :width: 100%
      
    - - **Architettura**
      - **Paradigma**
      - **Applicazioni**
      - **Limitazioni**
    - - **GPU**
      - SIMD/SIMT massivo
      - Grafica, ML, fisica
      - Poco efficiente per logica complessa
    - - **TPU**
      - Matrici / systolic arrays
      - Inferenza e training AI
      - Poco efficiente per logica complessa
    - - **Quantum**
      - Superposizione e entanglement
      - Problemi esponenziali selezionati
      - Rumore, scalabilità, algoritmi specifici



.. _Quantum computer:

+++++++++++++++++++++++++++++++
Quantum computer
+++++++++++++++++++++++++++++++

La computazione legata sulle leggi  della `Meccanica quantistica`_ 
(avanzata da *Richard Feynman* nel ``1982`` e poi formalizata da  *David Deutsch* nel ``1985``)
ha promosso lo sviluppo del  **Computer Quantistico (QC)** e del `Quantum computing`_.


Una convergenza di idee emerse tra la fine degli anni '70 e l'inizio degli anni '80,
è culminata con l'indicazione di *Richard Feynman* (``1982``) che un computer basato sulle leggi della 
meccanica quantistica potesse essere lo strumento necessario per simulare altri sistemi quantistici.

Su qusta base, 
nel ``1985``, *David Deutsch*  formalizzò l'idea di una Macchina di Turing Universale Quantistica, 
dimostrando che i principi quantistici potevano essere applicati all'elaborazione dell'informazione,
aprendo la via all'idea di **Computer Quantistico (QC)**.

Nel ``1994``, *Peter Shor* sviluppò
di un algoritmo quantistico in grado di fattorizzare numeri interi in modo esponenzialmente 
più veloce dei migliori algoritmi classici.

Da quello momento, la ricerca nel campo del calcolo quantistico è progredita rapidamente,
portando allo sviluppo di prototipi di computer quantistici e alla sperimentazione di 
algoritmi quantistici per problemi specifici.

Mentre la programmazione classica lavora con istruzioni che cambiano lo stato da ``0`` a ``1`` o viceversa, 
la programmazione quantistica lavora con i **qubit**:

- Un qubit esiste in una sovrapposizione di stati, una combinazione probabilistica di 0 e 1.
- Programmare un QC significa controllare e manipolare queste probabilità per allineare gli stati 
  quantistici in modo che, al momento della misurazione, lo stato desiderato (la soluzione) 
  abbia la probabilità massima.


Ciò che rende il computer quantistico qualitativamente diverso da un computer classico
è l'**entanglement**.

L'entanglement è una correlazione quantistica che si verifica quando lo stato di due o più qubit 
è così profondamente legato che non è possibile descrivere lo stato di ciascun qubit indipendentemente, 
anche se sono separati da grandi distanze.

Quando un algoritmo quantistico crea entanglement tra ``N`` qubit, non sta semplicemente lavorando su ``N`` 
bit indipendenti. Sta lavorando su un unico stato quantistico collettivo che può codificare 
``2^N`` combinazioni classiche contemporaneamente.

Questo significa che, grazie all'entanglement, le porte quantistiche (**Quantum Gates**) 
applicate durante l'elaborazione 
modificano simultaneamente tutte e ``2^N`` le possibili soluzioni. 
Questo è il fondamento del parallelismo quantistico che accelera esponenzialmente la risoluzione 
di alcuni problemi.

La programmazione quantistica viene eseguita utilizzando linguaggi o framework come Qiskit (IBM) o Cirq (Google), 
che traducono istruzioni ad alto livello  in circuiti di *Quantum Gates*.

Ovviamente, la computazione quantistica apre nuove prospettive e nuovi campi di ricerca teorica 
e applicate.
Tuttavia, allo stato attuale,
il computer quantistico non sostituisce quello classico, ma fornisce una capacità di calcolo 
qualitativamente diversa per specifiche classi di problemi.




Il calcolo di un QC è probabilistico, unitario e non clonabile (No-Cloning Theorem).

alla *programmazione quantistica* basata su linguaggi o framework come **Qiskit** (IBM) o **Cirq** (Google), 
che traducono istruzioni ad alto livello in circuiti di `Quantum Gates`_.

.. note::
  La crescente miniaturizzazione dei transistor che compongono un computer  'classico'
  implica l'insorgere di alcuni fenomeni spiegabili solo con la `Meccanica quantistica`_.
  Ricordiamo al proposito il **Tunneling Quantistico**:

  - responsabile di correnti di dispersione (**leakage current**), che generano calore e sprecano energia.
  - usato per spostare gli elettroni dentro e fuori le "floating gate" che
    intrappolando elettroni in modo da paermettere 
    la memorizzazione dei dati nelle **memorie flash** (usate negli ``SSD`` e nei telefoni).

..  La computazione quantistica apre nuove interessanti prospettive e nuovi campi di ricerca teorica 
   e applicate, che non è possibile approfondire in questa sede. 
   Tuttavia, allo stato attuale, il **QC** non sostituisce quello classico, ma fornisce una capacità di calcolo 
   qualitativamente diversa per specifiche classi di problemi.



-----------------------------------------------
Modelli formali: necessari ma non sufficienti
-----------------------------------------------

I modelli formali sono importanti perché
isolano l'essenza concettuale dei sistemi permettendo di capirli, 
compararli e verificarli in modo rigoroso e universale.

I modelli formali sul calcolo non sono sufficienti perché non dicono **come** realizzare efficientemente 
un sistema: sono i **linguaggi di programmazione** che colmano il divario, traducendo principi astratti 
in meccanismi concreti, efficienti e utilizzabili nella pratica.


Consideriamo, ad esempio, il il **processo**, spesso introdotto come concetto fondamentale legato 
alla computazione. 

In **CSP**, :math:`\pi calcolo` **calcolo**, ecc.:

- ciò che esiste sono **processi matematici**, non thread o coroutine;
- un processo è un'entità astratta, definita da un insieme di transizioni o eventi;
- lo stato del processo cambia tramite regole formali (“esegue un evento”, “comunica”, “si sincronizza”).

In questi modelli:

- **non esistono stack**,
- **non esistono scheduler**,
- **non esiste il concetto di sospensione volontaria** come `yield` o `await`,
- **non c'è distinzione tra thread pesante o coroutine leggera**.

CSP dice:

- Esistono processi che comunicano per canali, in modo sincrono.

Il :math:`\pi`-calcolo dice:

- I processi possono scambiarsi anche canali, supportando mobilità.

Ma nessuno dei due dice:

* come si deve gestire lo stack,
* come evitare di creare migliaia di thread pesanti,
* come sospendere una funzione senza bloccare un thread OS.

Per implementare *processi concettuali* a basso costo, servivano meccanismi pragmatici.
Tradizionalmente, il concetto di processo è realizzato usando 
*Thread* del sistema operativo o *Thread più leggeri* gestiti da *scheduler*.
Tuttavia questi, di solito: **i)** richiedono molta memoria (stack da ~1 MB) **ii)**
sono gestiti da kernel **iii)** hanno costi elevati di switching.

La possibilità pratica di attivare processi si riduce quindi a poche migliaia di *Thread* in uno stesso
sistema, mentre molte applicazioni moderne richiedono **decine o centinaia di migliaia di attività concorrenti**.

Meccanismi implementativi quali le **callback**
o le **promesse/future** si sono rivelati non ideali 
(problema del "callback hell" e della frammentazione del codice).

Un concetto/meccanismo che risale agli albori dell'informatica — 
introdotto negli **anni '60** come meccanismo di cooperazione tra routine — 
poi quasi dimenticato con l'affermarsi dei *thread di sistema*
è quello di **coroutine**.

Questo meccanismo viene oggi riscoperto e potenziato perché fornisce una soluzione più leggera, 
espressiva ed efficiente alla crescente esigenza di concorrenza su larga scala.

.. _La coroutine un nuovo vecchio concetto:

-----------------------------------------------
La coroutine un nuovo vecchio concetto
-----------------------------------------------

La “rinascita” delle coroutine nasce dagli stessi problemi che avevano motiva la loro invenzione 
negli anni '60:

- la necessità di gestire altissima concorrenza
  (i thread OS sono troppo pesanti per scalare a centinaia di migliaia o milioni di attività)
- la necessità di scrivere codice asincrono leggibile
  (superare callback hell, future annidati, codice frammentato)
- la necessità di modelli di concorrenza più sicuri
  (riduzione di deadlock e race, privilegiando message passing)

Introdotte in linguaggi pionieristici come **Simula 67** (uno dei padri della **OOP** e 
dei primi concetti di concorrenti cooperativi), **Modula-2** e **Modula-3** 
(di `Niklaus Wirth`_, padre Anche del linguaggio **Pascal** )
e alcune versioni evolute del *Lisp*,
il concetto è stato oggi riscoperto e potenziato perché fornisce una soluzione più leggera, 
espressiva ed efficiente alla crescente esigenza di concorrenza su larga scala.

Esso ritorna in linguaggi come:

- Go (goroutine, 2009)
- Kotlin (coroutine suspend, 2017)
- Python async/await (2015)
- Java virtual threads (Loom), che di fatto sono coroutine del linguaggio (2023)
- C# async/await (2012)
- JavaScript async/await (2017)


--------------------------------------------------------
Un esempio: CSP e GO
--------------------------------------------------------

**CSP** (*Communicating Sequential Processes*) è un modello formale introdotto da **Tony Hoare (1978)** 
per descrivere sistemi concorrenti.
È usato per *specificare, analizzare e verificare- protocolli di comunicazione tra processi.

Riportimo un quadro sintetico delle idee fondamentali di CSP

-  Comunicazione sincrona per messaggi
-  Canali come entità di prima classe
-  Composizione parallela dei processi
-  Nessuna memoria condivisa
-  Sincronizzazione implicita nella comunicazione
-  Modello matematico verificabile

++++++++++++++++++++++++++++++++++++++++++
CSP: Processi sequenziali
++++++++++++++++++++++++++++++++++++++++++


Le caratteristiche chiave di CSP (in sintesi) sono:



  .. list-table:: 
    :widths: 25,75
    :width: 100%
      
    - - **Caratteristica**
      - **Descrizione**
    - - Processi sequenziali
      - Il sistema è formato da **processi**, ciascuno dei quali è sequenziale: esegue azioni una dopo l'altra.
    - - Comunicazione per canali
      - 
       
        - La comunicazione è **sincrona**: chi invia e chi riceve devono essere entrambi pronti 
          → la comunicazione “si completa insieme”.
        - Il canale è un'astrazione matematica: niente buffer (di default).

          Esempio :

        .. code::

          P = c ! x     // processo P invia x sul canale c
          Q = c ? y     // processo Q riceve un valore su c
 

        La comunicazione avviene solo quando entrambi i processi sono pronti.
    - - Composizione concorrente
      - La concorrenza si ottiene tramite **composizione parallela**:

        .. code::

          P || Q
        

        P e Q eseguono in parallelo e devono *sincronizzarsi* sugli eventi comuni.
    - - Scelta
      - Ci sono due tipi di scelta:

        - **Scelta esterna** (determinata dall'ambiente)
        - **Scelta interna** (non osservabile)
    - - Verifica formale
      - CSP fornisce un *algebra formale* per ragionare su:

        - deadlock
        - livelock
        - race conditions
        - equivalenza comportamentale

        È molto usato in contesti safety-critical.

 

++++++++++++++++++++++++++++++++++++++++++
 Come CSP ha influenzato Go
++++++++++++++++++++++++++++++++++++++++++

Il linguaggio **Go**, creato da Google (Pike, Thompson, Griesemer), 
incorpora esplicitamente concetti provenienti da CSP.

La frase di Rob Pike è celebre:

**Do not communicate by sharing memory; instead, share memory by communicating.**


Go reinterpreta CSP in modo **pragmatico**, rendendolo adatto alla programmazione industriale.
Le principali differenze sono riassunte nella seguente tabella:

.. code::

  | Elemento         | CSP                      | Go                             |
  | ---------------- | ------------------------ | ------------------------------ |
  | Comunicazione    | Sincrona                 | Sincrona + buffer (asincrona)  |
  | Semantica        | Matematica, formale      | Pratica, implementativa        |
  | Processi         | Astratti, infiniti       | Goroutine, mappate su thread   |
  | Verifica formale | Centrale                 | Non è obiettivo del linguaggio |
  | Scopo            | Specifica e modellazione | Programmazione applicativa     |

Go **si ispira** a CSP, ma **non è una sua implementazione formale**.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Go-routine come "processi CSP"
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Le **goroutine** sono entità concorrenti leggere, analoghe ai *processi di CSP*:
indipendenti, sequenziali, comunicano tramite canali.

 
I canali di Go sono ispirati direttamente ai canali CSP
  

Nei canali Go:

.. code::

  ch := make(chan int)
 

la comunicazione può essere **bloccante** (sincrona), come in CSP.

.. code::

  ch <- x   // invio
  y := <-ch // ricezione
 

Il completamento avviene solo quando entrambi sono pronti (*sincronizzazione implicita*, come in CSP).

Ma Go introduce una differenza importante: i canali **possono essere bufferizzati**:

.. code::

  make(chan int, 10)
 

Dunque in Go, la comunicazione può essere anche *asincrona*, quindi più flessibile.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Select 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La Select di Go deriva dalla scelta esterna di CSP

.. code::

  select {
    case x := <-ch1:
        ...
    case ch2 <- y:
        ...
    default:
        ...
  }
 
Questo è la versione di Go dell'operatore di *scelta esterna di CSP*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Composizione concorrente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La frase CSP: ```P || Q```

diventa in Go:

.. code::

  go f()   // esegue f in parallelo
 

La concorrenza nasce dalla creazione di *goroutine* indipendenti.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Assenza di memoria condivisa “esplicita”
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Go permette la memoria condivisa, ma lo *stile idiomatico* promuove il modello CSP:

- evitare il locking manuale
- preferire canali ai mutex

 

.. Go reinterpreta CSP in modo **pragmatico**, rendendolo adatto alla programmazione industriale.

 


------------------------------------------------------------------------
Famiglie di formalismi
------------------------------------------------------------------------

Nel corso della storia dell'informatica teorica, i formalismi si sono evoluti in risposta 
a esigenze sempre nuove: definire cosa significhi calcolo, modellare la concorrenza, 
gestire sistemi distribuiti non affidabili, comprendere il ruolo della mobilità, 
descrivere l'emergenza di comportamenti globali.

Questa evoluzione ha dato vita a una serie di *famiglie* di formalismi, ciascuna caratterizzata 
da un'idea guida, da un ambito di applicazione privilegiato e da risultati teorici 
che ne precisano potere espressivo e limiti.

L'insieme delle famiglie  mostra come i formalismi non siano strumenti puramente accademici:
sono la **grammatica fondamentale** con cui l'ingegneria del software comprende e progetta sistemi 
sempre più complessi, autonomi, distribuiti e adattivi.

Ogni famiglia è nata in risposta a una tensione storica concreta, e ogni risultato teorico 
ha contribuito a definire il perimetro del possibile e dell'impossibile in informatica.

Vediamo una sintetica panoramica di queste principali famiglie.
 
+++++++++++++++++++++++++++++++++++++++++++++
Formalismi funzionali
+++++++++++++++++++++++++++++++++++++++++++++



La prima grande famiglia è quella dei formalismi funzionali, nata negli **anni '30** con Alonzo Church e la definizione 
del :math:`\lambda` **calcolo**. L'idea fondamentale è che la computazione possa essere vista 
come *applicazione di funzioni a valori*, senza memoria mutabile né effetti collaterali.

Questa visione è profondamente radicata nella logica matematica e nella teoria delle funzioni ricorsive.

Questa famiglia di formalismi serve principalmente a:

I formalismi funzionali servono principalmente a:

- descrivere la computazione in modo puramente simbolico,
- ragionare su trasformazioni e riduzioni,
- garantire proprietà come la *referential transparency*,
- dimostrare equazioni e invarianti senza preoccuparsi dello stato.

Sono fondamentali per discipline come la programmazione funzionale, gli strumenti di ottimizzazione 
dei compilatori e i linguaggi basati su funzioni pure (``Haskell``, ``ML``).

*Principali risultati teorici*

- **Equivalenza Church–Turing**: il :math:`\lambda`-calcolo è Turing-completo.
- **Teorema di Church–Rosser (confluenza)**: l'ordine di riduzione delle espressioni non influisce sul risultato finale (se questo esiste).
- **Indecidibilità della normalizzazione**: non si può decidere in generale se un termine del :math:`\lambda`-calcolo ha una forma normale.
- **Sistema di tipi**: introduzione dei tipi semplici (Church) e dei sistemi polimorfi, fondamentali per linguaggi moderni.

Questi risultati fondano l'intera disciplina della programmazione funzionale moderna.


+++++++++++++++++++++++++++++++++++++++++++++
Formalismi concorrenti
+++++++++++++++++++++++++++++++++++++++++++++ 



A partire dagli **anni '60 e '70**, con lo sviluppo dei sistemi time-sharing, emerge il problema 
della **concorrenza**. Robin Milner, Tony Hoare ed altri introducono formalismi che trattano 
i processi *non* come funzioni, ma come entità dinamiche in comunicazione.

Nascono così **CSP**, **CCS** e, più tardi, il :math:`\pi` **calcolo**.

Questa famiglia di formalismi serve principalmente a:

Questi formalismi servono a:

- modellare processi che evolvono in parallelo,
- formalizzare comunicazioni sincrone/asincrone,
- verificare sicurezza (deadlock-freedom) e liveness,
- definire equivalenze comportamentali (bisimulazione),
- ragionare sul nondeterminismo operativo.

Sono indispensabili per sistemi real-time, middleware concorrenti, modelli actor 
e linguaggi come ``Erlang``, ``Occam``, ``Go`` (canali CSP-like).

*Principali risultati teorici*

- **Bisimulazione** (Milner, Park): due processi sono equivalenti se non distinguibili da un osservatore esterno.
- **Teoria delle transizioni strutturali**: permette di definire formalmente il comportamento di 
  processi complessi con regole modulari.
- :math:`\pi` **calcolo Turing-completo** con scambio dinamico di canali.
- **Risultati di impossibilità**: certi pattern di mobilità non sono esprimibili in CCS senza estensioni.

Questi risultati segnano il passaggio decisivo dal calcolo come funzione al calcolo come *interazione*.

 
+++++++++++++++++++++++++++++++++++++++++++++
Formalismi distribuiti
+++++++++++++++++++++++++++++++++++++++++++++



Con lo sviluppo delle reti (ARPANET, Internet) emerge la necessità di modellare sistemi 
in cui nessun processo possiede un punto di vista globale. *Hewitt* introdusse l'**Actor Model** 
già negli **anni '70**

.. , mentre negli **anni '90** nascono il **Join Calculus** e la teoria dei protocolli di consenso.

Questa famiglia di formalismi serve principalmente a:

- modellare comunicazione asincrona senza memoria condivisa;
- trattare fallimenti, partizioni di rete, ritardi imprevedibili;
- descrivere algoritmi distribuiti e protocolli;
- caratterizzare il comportamento di  microservizi e cluster.

*Principali risultati teorici*

- **Teorema FLP (Fischer-Lynch-Paterson)**: impossibile garantire consenso deterministico 
  in un sistema asincrono con un fallo possibile.
- **Teorema CAP**: impossibile garantire contemporaneamente **Consistenza, Disponibilità e Tolleranza alla Partizione**.
- **Determinismo con attori isolati**: gli attori sono Turing-completi ma con un forte controllo sull'interferenza.

Questi risultati hanno avuto impatto diretto sul design dei sistemi cloud e delle architetture a 
 microservizi.

 
+++++++++++++++++++++++++++++++++++++++++++++
Formalismi per la mobilità
+++++++++++++++++++++++++++++++++++++++++++++



L'attenzione alla **mobilità** (di codice, processi, canali) emerge negli **anni '90** con gruppi 
come quello di *Luca Cardelli* e *Andrew Gordon*. Nascono così formalismi come il **Mobile Ambients** e 
le estensioni mobili del :math:`\pi`-calcolo.

Questa famiglia di formalismi serve principalmente a:

- descrivere sistemi che cambiano struttura dinamicamente;
- modellare agenti mobili, protocolli ad hoc, migrazione di processi;
- rappresentare reti pervasive o IoT.

*Principali risultati teorici*

- **Il mobile** :math:`\pi` **calculus** è più espressivo di **CCS**;
- **alcune proprietà di sicurezza sono indecidibili** in ambienti mobili;
- **gerarchie di potere espressivo** tra modelli nominali e strutturali;
- **equivalenza con automi di mobilità** in vari casi.

Questi formalismi sono fondamentali nella modellazione di sistemi IoT e mobile-cloud.

 
+++++++++++++++++++++++++++++++++++++++++++++
Formalismi stocastici
+++++++++++++++++++++++++++++++++++++++++++++



La necessità di modellare comportamenti probabilistici, biologici o di rete porta alla 
nascita (**anni 2000**) del :math:`\pi` **calcolo stocastico**, delle **CTMC** (*continuous-time Markov chain*)
e **DTMC** (*Discrete-time Markov chain*),
dei modelli Markoviani e dei sistemi probabilistici.

Questa famiglia di formalismi serve principalmente a:

- descrivere sistemi soggetti a rumore, variabilità o fallimenti probabilistici;
- associarne tempi medi, probabilità di stati, rischi;
- supportare model checking probabilistico.

*Principali risultati teorici*

- **ergodicità** e **stazionarietà** delle catene di Markov;
- **decidibilità** del model checking probabilistico su ``DTMC/CTMC`` finite;
- **indecidibilità** per modelli con memoria illimitata;
- **calcolo Turing-completo** in alcune estensioni probabilistiche del :math:`\lambda`-calcolo.

Questi formalismi sono oggi fondamentali per sistemi autonomi, robotics e protocolli di rete.

 
+++++++++++++++++++++++++++++++++++++++++++++
Formalismi field-based e global behavior
+++++++++++++++++++++++++++++++++++++++++++++



Dagli **anni 2000-2010** nasce una nuova esigenza: modellare **comportamenti globali emergenti** 
a partire da moltissime entità locali. 
È la famiglia dei formalismi “a campo”, come il **Field Calculus**, il linguaggio **Proto**, 
e le estensioni **aggregate computing**.

Questa famiglia di formalismi serve principalmente a:

- descrivere sistemi auto-organizzanti;
- modellare propagazione, stabilizzazione e gradienti;
- controllare comportamenti globali senza un coordinatore centrale;
- formalizzare sistemi complessi su larga scala: swarm robotics, reti self-organizing, large IoT.

*Principali risultati teorici*

- **equivalenza del field calculus** con un :math:`\lambda` **calcolo distribuito** strutturato su spazio e tempo;
- **teoremi di stabilizzazione** in presenza di mobilità e fallimenti;
- **limiti della computazione spaziale**: impossibile ottenere global properties con vicinato insufficiente;
- **convergenza garantita** per classi di programmi auto-stabilizzanti.

Questa famiglia rappresenta il ponte più diretto tra sistemi complessi naturali e sistemi complessi software.

 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Formalismi per sistemi complessi e dinamiche non lineari
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Modelli come **automi cellulari**, **agent-based models**, **reti complesse** e **sistemi dinamici non lineari** 
derivano da un'altra tradizione: fisica, biologia, teoria del caos. Il tema centrale è la *dinamica collettiva*.

Questa famiglia di formalismi serve principalmente a:

- analizzare emergenze non lineari;
- studiare caos, biforcazioni, auto-organizzazione;
- modellare popolazioni di agenti, ecosistemi artificiali, fenomeni di sincronizzazione.

*Principali risultati teorici*

- **Turing-completezza** dell'automa cellulare `Rule 110`_;
- **Teorema di Li-Yorke**: il caos è inevitabile in certi sistemi dinamici;
- **criticitá auto-organizzata** (Bak, Tang, Wiesenfeld) produce distribuzioni a legge di potenza;
- **limiti alla predicibilità** (sensibilità alle condizioni iniziali).

Questi formalismi ispirano tecniche di simulazione su larga scala e modelli per “sistemi complessi software”.

 
 


 


 



.. Oltre i design pattern


===========================================
I linguaggi
===========================================

E' importante avere chiara la distinzione tra *linguaggio naturale* e *linguaggio di programmazione*
e il ruolo che questo può avere nella definizione e costruzione di oggetti e 'sistemi artificiali'.


-----------------------------------------
Linguaggi naturali
-----------------------------------------

Il linguaggio naturale (**LN**) come l'italiano, l'inglese, ecc. è lo strumento primario 
degli esseri umani per interagire con il mondo e per *categorizzarlo*.
Il suo ruolo non è solo descrittivo, ma anche costitutivo e sociale, in quanto
un ``LN`` non è un semplice specchio che riflette oggetti esistenti. 

Un ``LN`` è piuttosto un filtro categoriale che organizza e rende gestibile un flusso continuo di percezioni. 
Le impostazioni filosofiche estreme suggeriscono che l'esistenza degli "oggetti" come li conosciamo 
(con i loro confini e le loro identità) è un prodotto di questo filtro linguistico.
In questa visione, gli oggetti non esistono "in sé" ma solo come costrutti mentali e si pone il problema di 
cosa sia "reale".

Nonostante la sua potenza, il linguaggio naturale presenta alcune caratteristiche limitative:

#. **Vaghezza e Ambiguità**: Molte parole hanno confini sfocati (*fuzzy boundaries*). 
   Non esiste un confine netto che determini, ad esempio, quando un "cespuglio" diventi un "albero" 
   o quando un "sasso" sia abbastanza grande da essere chiamato "roccia". Questo è il limite della precisione.

#. **Dipendenza dal Contesto**: La descrizione di un oggetto è sempre incompleta e dipendente dal contesto. 
   Descrivere un "tavolo" in fisica richiede la massa e la composizione molecolare;
   descriverlo in un negozio di mobili richiede lo stile e il prezzo. Nessuna descrizione è totale.

#. **Problema del Riferimento**: Il linguaggio non può esaurire tutte 
   le proprietà di un oggetto. Possiamo solo riferirci a un sottoinsieme di proprietà (**l'intensione**) 
   per identificare la collezione di oggetti (**l'estensione**).

.. Si pensi ad esempio alla frase: "Ho visto un uomo col cannocchiale".

Gli oggetti reali (**things-in-themselves**) possono esistere fisicamente (cioè, esistono atomi e onde), 
ma la loro divisione in categorie discrete e utilizzabili (es. "pianta", "bottiglia", "confine", "matrimonio") 
è un atto imposto dal linguaggio e dalla cultura.

Per molti, non c'è un modo "oggettivo" di dividere il mondo in oggetti. 
L'atto di riferimento linguistico a un oggetto è sempre vincolato al sistema linguistico e concettuale 
che stiamo usando (la cosiddetta *underdetermination of reference* del filosofo  `Willard Van Orman Quine`_).
 
In ogni caso, diverse evidenze empiriche indicano che
un ``LN`` influenza o orienta l'attenzione e la cognizione, rendendo più facile o frequente pensare in certi modi. 
Ad esempio, il linguaggio fornisce le categorie che gli umani usano   
per interpretare e comunicare la realtà dello spazio e del tempo e queste sono diverse in
contesti culturali diversi (`Ipotesi Sapir-Whorf`_).

Tuttavia, l'ambiguità delle frasi dei linguaggi naturali 
(ad esempio: *"Ho visto un uomo su una pianta col cannocchiale"*)
sono caratteristiche intrinseche e necessarie per la flessibilità e l'espressione umana
e può anche essere vista come un vantaggio:

1. **Efficienza e Velocità di Trasmissione**. utilizzando la conoscenza condivisa e il contesto.
2. **Creatività, Espressione Artistica e Ironia**. Nuovi significati e usi delle parole emergono 
   proprio grazie alla loro flessibilità e ambiguità, consentendo al linguaggio di evolvere 
   per adattarsi a nuove realtà sociali e tecnologiche.
3. **Flessibilità e Adattabilità Sociale**. 

   - Mantenere relazioni positive, di negoziare o di evitare il conflitto.
   - Identificazione del Contesto (Pragmatica): L'ambiguità ci costringe a interagire 
     con l'ambiente e con l'altro per risolverla. 
   - Il processo di disambiguazione contestuale è una funzione cruciale della nostra 
     intelligenza e della nostra capacità di adattarci a situazioni diverse.

-----------------------------------------
I Large Language Models
-----------------------------------------

Gli ormai onnipresenti **Large Language Models** (**LLM**) si fondano su concetti di statistica e probabilità 
applicate al linguaggio naturale.

Un **LLM** è una rete neurale trasformatrice (**Transformer**), addestrata su miliardi di parole e testi 
provenienti da Internet, libri e altre fonti.

Il modello non lavora su singole lettere o parole intere, ma su **token**
(una parola intera, una parte di una parola, un segno di punteggiatura o uno spazio).

.. Ogni *token- viene convertito in una rappresentazione numerica (un vettore di numeri) che ne cattura 
   il significato e il contesto. Questa conversione è fondamentale perché i calcoli neurali operano
   solo sui numeri.

Quando il modello elabora un *token* nel **prompt** dato in input dall'utente, non lo guarda isolatamente, 
ma valuta quanto sono importanti tutti gli altri token nel prompt per "dare significato" al token corrente.
Questo modo di procedere è denominato **attenzione** e costruisce una
rappresentazione numerica finale del prompt che include il contesto e l'importanza di ogni parte 
del testo di input.

L'ultima rappresentazione numerica del prompt funge da stato iniziale. 
A partire da questo stato, il modello fa una **previsione del token successivo**
utilizzando una tecnica chiamata campionamento stocastico o **sampling** 
(spesso controllato da un parametro denominato **Temperatura**).

Il processo si ripete, ma questa volta, il nuovo input per la previsione successiva è 
l'intero prompt più il token appena generato.

Con questo modo di procedere, un **LLM** non "capisce" nel senso umano. 
Il suo successo deriva dalla sua capacità di:

- **Imitare la Sintassi e la Semantica del Testo Umano**: Avendo analizzato enormi quantità di testo, 
  ha imparato quali sequenze di parole sono statisticamente coerenti e significative.
- **Mantenere il Contesto**: Grazie al meccanismo di attenzione, ogni token generato è coerente 
  non solo con l'ultima parola, ma con l'intero contesto del prompt e della conversazione precedente.





.. _Linguaggi di programmazione:

-------------------------------------------------
Linguaggi di programmazione
-------------------------------------------------

I linguaggi di programmazione (**LdP**) sono costruiti per essere l'esatto opposto dei linguaggi naturali 
in termini di precisione e ambiguità.

Questi linguaggi 'artificiali' non si preoccupano di come l'essere umano percepisce il mondo esterno. 
La loro `ontologia`_ (gli oggetti che esistono) è definita esplicitamente dal programmatore:

- Gli oggetti sono tipi di dati (``Int, String, Person``).
- Lo spazio e il tempo sono gestiti da astrazioni matematiche precise (indirizzi di memoria, timestamp, cicli di CPU).
- Non c'è spazio per la "percezione" individuale dei concetti.

Se si usa un ``LdP``, l'hardware sottostante (il *computer*) esegue la logica allo stesso modo; 
ciò che cambia è l'efficienza e la facilità con cui l'umano esprime quella logica nel linguaggio usato.

++++++++++++++++++++++++++++++++++++++
Una frase misteriosa
++++++++++++++++++++++++++++++++++++++

Supponiamo che un esploratore abbia trovato una incisione rupestre che si presenta come segue:


  .. image:: ./_static/img/FraseEnigmatica.jpg 
    :align: center
    :width: 60%

Cosa dovrà fare l'esploratore per comprenderne il significato? Certo dovrà occuparsi di sintassi e di semantica.

.. _Sintassi e semantica:

++++++++++++++++++++++++++++++++++++++++++++
Sintassi e semantica
++++++++++++++++++++++++++++++++++++++++++++

Ogni frase di un ``LdP`` ubbidisce a una precisa sintassi, espressa da regole definite
con notazioni formali.

La frase di un LdP ha sempre una interpretazione univoca che permette al computer di
**agire** in un unico modo: questo modo di agire costituisce la **semantica** della frase.

- **Sintassi**: Riguarda le regole strutturali che definiscono se una frase è legalmente formata 
  (es. le parentesi sono bilanciate? I punti e virgola sono al posto giusto?). 
  Se una frase non rispetta la sintassi, è un errore e il computer non può agire.

- **Semantica**: Riguarda il significato della frase sintatticamente corretta e le azioni che ne derivano.
  La semantica è, in sostanza, la descrizione rigorosa e formale dell'effetto che l'esecuzione di una frase 
  ha sullo stato della macchina.


.. _Linguaggi per descrivere linguaggi:

++++++++++++++++++++++++++++++++++++++++++++
Linguaggi per descrivere linguaggi
++++++++++++++++++++++++++++++++++++++++++++

C'è una connessione fondamentale tra linguaggi, macchine e la necessità di 
notazioni formali per definire e studiare i linguaggi in modo non ambiguo.

Un **computer** è un sistema fisico. Ogni istruzione di un ``LdP`` si traduce in una serie di transizioni 
di stato all'interno di circuiti e memoria.
Il **linguaggio macchina** di un computer è direttamente 
**interpretabile** dalla CPU. Tutto il codice di alto livello deve essere ricondotto 
a questo linguaggio di basso livello per l'esecuzione.

Prima che il computer possa eseguire le frasi di un ``LdP``, deve **riconoscere** tali frasi (fare il **parsing**)
cioè  determinare se la frase costituisce una sequenza di simboli valida di quel linguaggio.

Per descrivere le forme lecite assumbili dalle frasi di un ``LdP`` (**sintassi**) si usano
notazioni (dunque ulteriori linguaggi) dette **Grammatiche Formali** costituite da un
sistema di regole  che delineano matematicamente un insieme (di solito infinito) 
di sequenze finite di simboli (*stringhe*) appartenenti ad un *alfabeto- anch'esso finito.

.. _Macchine astratte per riconoscere linguaggi:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Macchine astratte per riconoscere linguaggi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La `Gerarchia di Chomsky`_ è un insieme di classi di grammatiche formali che generano linguaggi formali.
Un concetto fondamentale nell'informatica teorica
è la corrispondenza tra la **Gerarchia di Chomsky**   e 
una **Gerarchia di Macchine Astratte** in grado di riconoscere i linguaggi.

.. note::

  In informatica, una `Macchina astratta`_ è un modello teorico di sistema computazionale.

  La corrispondeza tra tipi di grammatiche e macchine astratte in grado di riconescere 
  i linguaggi generati può essere riassunta come segue:


  .. list-table:: 
    :widths: 15,25,40,20
    :width: 100%
      
    - - **Tipo di Chomsky**
      - **Nome Grammatica**
      - **Macchina Astratta**
      - **Complessità di Riconoscimento**
    - - **Tipo0**
      - Unrestricted 
      - Macchina di Turing 
      - Indecidibile 
    - - **Tipo1**
      - Context-Sensitive
      - Macchina di Turing Limitata Linearmente (LBA) 
      - Decidibile 
    - - **Tipo2**
      - **Context-Free**
      - Automa a Pila (Pushdown Automaton, PDA) 
      - Decidibile, Tempo Polinomiale 
    - - **Tipo3**
      - **Regular**
      - Automa a Stati Finiti (Finite Automaton, FA) 
      - Decidibile, Tempo Lineare 

Il riconoscimento delle frasi di un ``LdP`` deve avvenire rapidamente. 
Quindi la sintassi di tutti gli ``LdP`` oggi uso è descritta grammatiche **Context-Free** o **Regular**.

.. La sintassi deve essere definita in modo che l'algoritmo di parsing 
 (implementato nel compilatore o nell'interprete) sia determinista e abbia una complessità 
 temporale gestibile (idealmente O(n) rispetto alla lunghezza n del codice).



++++++++++++++++++++++++++++++++++++
La analisi sintattica
++++++++++++++++++++++++++++++++++++

Le **grammatiche formali** definiscono in modo non ambiguo e matematicamente rigoroso quali sequenze di simboli 
(parole chiave, identificatori, operatori, ecc.) costituiscono un programma sintatticamente corretto.

.. note::

  La notazione più fondamentale è la *Forma di Backus-Naur* (**BNF**) e la *BNF Estesa* (**EBNF**).
  Questa notazione definisce la sintassi attraverso un insieme di regole di produzione. Ad esempio

  .. code::

    <assegnazione> ::= <variabile> = <espressione> ;
    <espressione>  ::= <termine> | <espressione> + <termine>


  Le grammatiche sono essenziali per la costruzione dei traduttori (**compilatori** e **interpreti**):

  - *Analisi Lessicale* (**Lexing**): Il testo viene scomposto in **token** (simboli terminali).
  - *Analisi Sintattica* (**Parsing**): Il *parser* utilizza le regole della grammatica 
    per verificare se la sequenza di *token* è strutturalmente corretta. 
    Se le regole vengono soddisfatte, il parser costruisce un 
    **Albero Sintattico Astratto** (**AST**), che è la rappresentazione strutturata del codice 
    che verrà poi usata per definire la semantica (il significato e l'azione) del programma.

.. Il parsing deve avvenire rapidamente. 
  La sintassi deve essere definita in modo che l'algoritmo di parsing 
  (implementato nel compilatore o nell'interprete) sia determinista e abbia una complessità 
  temporale gestibile (idealmente O(n) rispetto alla lunghezza n del codice).



Sono stati creati tool che generano automaticamente un *parser* partendo dalla specifica 
di un linguaggio di programmazione descritta con la **BNF**, ad esempio **Yacc** 
(*Yet Another Compiler Compiler*).

++++++++++++++++++++++++++++++++++++
Descrivere la semantica
++++++++++++++++++++++++++++++++++++

Si distinguono diversi tipi di semantica formale, ciascuno con i suoi metodi e applicazioni specifiche.

.. note::

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Semantica Operazionale
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  La semantica operazionale (**Operational Semantics**) definisce il significato di un programma descrivendo come viene eseguito. 
  L'attenzione è posta sui passaggi elementari di calcolo che un'istruzione innesca.

  - *Formalismo Principale*: Regole di transizione.
  - *Utilità principale*:  Progettazione di interpreti e macchine virtuali

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Semantica Denotazionale
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  La semantica denotazionale (**Denotational Semantics**) definisce il significato di un programma associando (o "denotando") 
  a ogni costrutto una funzione matematica pura. 

  - *Formalismo Principale*: Teoria dei Domini e Punti Fissi (Fixed Points).
  - *Utilità principale*: Dimostrazione di equivalenza tra programmi  

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Semantica Assiomatica
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  La semantica assiomatica (**Axiomatic semantics**) definisce il significato di un programma specificando le proprietà logiche che devono 
  essere vere prima e dopo l'esecuzione dell'istruzione. 

  - *Formalismo Principale*: La Logica di Tony Hoare.
  - *Utilità principale*: Verifica e validazione di programmi

Il tipo di semantica più utilizzato nella pratica ingegneristica e didattica della programmazione è la 
**Semantica Operazionale**, per i seguenti motivi:

#. **Corrispondenza Diretta con l'Implementazione**: Le regole della semantica operazionale 
   (es. "Quando incontri un'istruzione IF, valuta prima la condizione, se è vera esegui il blocco 'then', 
   altrimenti il blocco 'else'") sono quasi un blueprint diretto per l'implementazione di un interprete 
   o di un compilatore. È la forma più vicina a come una macchina esegue i calcoli.

#. **Facilità di Comprensione e Debug**: I programmatori sono abituati a tracciare l'esecuzione del codice passo dopo passo, 
   proprio come farebbe un debugger. La semantica operazionale formalizza questa tracciabilità, 
   rendendo intuitivo capire cosa accadrà ad ogni istruzione.

#. **Definizione di Standard**: Molte specifiche di linguaggi di programmazione, come C, C++, e Java 
   (in termini di esecuzione della Java Virtual Machine o JVM), si basano implicitamente o esplicitamente 
   su un modello operazionale per definire il comportamento del linguaggio in vari scenari.

------------------------------------------------------
Compilatori e interpreti
------------------------------------------------------


Un **compilatore** è un programma che traduce l'intero codice sorgente di un LdP ad alto livello in un 
programma equivalente in linguaggio macchina (o in un formato eseguibile intermedio), 
prima della sua esecuzione.

Un **interprete** è un programma che esegue direttamente il codice sorgente istruzione per istruzione, 
traducendo e valutando le frasi  una dopo l'altra.

Molti LdP usano approcci ibridi, come:

- Java → compilazione in bytecode + interpretazione/ottimizzazione **JIT** (*Just-In-Time Compilation*)
- Python → bytecode + interprete (CPython)
- JavaScript → interprete + compilazione dinamica **JIT** nei browser



.. _General Processing Programming Languages:
 
------------------------------------------
General Processing Programming Languages
------------------------------------------


.. General Processing Programming Languages

Il numero totale di linguaggi di programmazione (inclusi linguaggi esoterici, accademici e non più in uso) 
è stimato in circa ``2500``.

.. list-table::
  :widths: 45,55
  :width: 100%
  
  * - .
      
      .. image:: ./_static/img/historyHLPL.PNG
         :width: 100%
         :align: center
    - La figura  mostra una visione sintetica dello sviluppo nel tempo di questa evoluzione linguistica,
      con riferimento ad alcuni dei linguaggi più noti.

      ---
    
      L'avvento della programmazione ad oggetti sembra avere segnato il culmine di questo processo; 
      un motivo può certo essere il raggiungimento di una sufficiente maturità nella capacità espressiva 
      in ciascuna delle :ref:`Dimensioni` citate.


Tuttavia, il numero di Linguaggi di Programmazione Generale (**GPL**) attivamente utilizzati in 
ambiente industriale è molto più limitato, 
probabilmente tra ``20`` e ``50``. Solo una decina di questi domina oltre l'``80%`` del mercato dello sviluppo;
tra essi vi sono:

**Python, Java, Javascript, C, C++, C#, TypeScript, GO**

Questi ``GPL`` sono quasi sempre utilizzati 
in combinazione con **framework** e **librerie** che non solo forniscono funzionalità/utlilità
ma che possono anche alzare il livello di astrazione.
Doiscutermeo questo aspetto più avanti, nella sezione :ref:`L'astrazione`.

.. per mitigare l':ref:`Abstraction Gap`, avvicinandoli ai concetti di :ref:`DSL interni<Il Ruolo dei Domain-Specific Languages (DSL)>`  
  (ad esempio, Django in Python, Spring in Java).

+++++++++++++++++++++++++++++++++++++++++
Stili (paradigni) di programmazione
+++++++++++++++++++++++++++++++++++++++++


I linguaggi di programmazione possono essere raggruppati in stili o paradigmi, 
che definiscono il **modo concettuale** in cui si struttura un programma per risolvere un problema.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Paradigma Imperativo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Il paradigma imperativo si concentra sul come un programma debba operare. Si basa sul concetto di **stato** e 
su istruzioni (o comandi) che modificano sequenzialmente tale stato (variabili, memoria). 
Il codice descrive una serie di **azioni esplicite** che il computer deve eseguire.

Come Linguaggio Rappresentativo possiamo citare il **C**.

**Caratteristiche:**
   - **Stato Mutabile:** Le variabili possono essere modificate.
   - **Flusso di Controllo:** Utilizzo massiccio di costrutti come *if/else*, *for*, *while*, ....
   - **Procedure/Funzioni:** Raggruppano istruzioni per il riutilizzo.
 
.. _Paradigma Orientato agli Oggetti (OOP):
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Paradigma Orientato agli Oggetti (OOP)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

Derivato dal paradigma imperativo, l'Object Oriented Programming (**OOP**) organizza il software attorno a **oggetti**, 
che combinano **dati** (attributi) 
e le **funzioni** (metodi) che operano su quei dati. L'obiettivo è modellare entità del mondo reale.

Come Linguaggio Rappresentativo possiamo citare il **C++** o **Java**.

**Caratteristiche:**
   - **Inscapsulamento** (Encapsulation): Raggruppamento di dati e metodi che operano su di essi.
   - **Ereditarietà** (Inheritance):  Le nuove classi ereditano le proprietà delle classi esistenti.
   - **Polimorfismo** (Polymorphism):  Oggetti diversi possono rispondere allo stesso input in modi diversi.
   - **Astrazione** (Abstraction):  Nascondere la complessità implementativa all'utente.

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Paradigma Funzionale (FP)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

Il paradigma funzionale tratta il calcolo come la valutazione di **funzioni matematiche** 
(non nel senso di procedure imperative). Si concentra sul **cosa** calcolare, evitando cambiamenti 
di stato e dati mutabili. Promuove l'uso di **funzioni pure**.

Come Linguaggio Rappresentativo possiamo citare il **Lisp/Scheme** o **Haskell**.

**Caratteristiche:**
   - **Immutabilità:** I dati non cambiano una volta creati.
   - **Funzioni Pure:** Una funzione restituisce sempre lo stesso output per lo stesso input e non produce effetti collaterali (non modifica lo stato esterno).
   - **Funzioni di Ordine Superiore:** Funzioni che accettano altre funzioni come argomenti o le restituiscono come risultato.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Paradigma Logico (Dichiarativo)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

Questo paradigma si basa sulla **logica formale**. Il programmatore **non** specifica 
*come* trovare la soluzione, ma descrive il problema in termini di **fatti** e **regole**. 
Il motore di esecuzione (l'interprete *risolutore*) cerca le risposte che soddisfano queste regole.

Come Linguaggio Rappresentativo possiamo citare il **Prolog**

**Caratteristiche:**
   - **Asserzioni (Facts):** Dichiarazioni vere sul dominio del problema.
   - **Regole (Rules):** Definizioni di nuove verità basate su fatti esistenti.
   - **Query:** Domande poste al sistema per dedurre nuove informazioni.
   - **Backtracking:** Il meccanismo di ricerca automatico per trovare le soluzioni.



.. note:: 

  Molti linguaggi moderni (come *Python, JavaScript e Scala*) sono **multi-paradigma**, 
  supportando elementi di imperativo, OOP e funzionale.


.. _Gli attori come nuovo paradigma?:

------------------------------------------
Gli attori come nuovo paradigma?
------------------------------------------

L'**Actor Model**, ideato da *Carl Hewitt* nel ``1973`` e reso popolare da linguaggi come **Erlang** e 
framework come **Akka** (implementato in *Scala* e *Java*), offre una filosofia di calcolo 
che molti vedono come un nuovo stile di programmazione per l'era del multicore e del cloud.

Il focus non è più su cosa fare (Funzionale) o come cambiare lo stato (Imperativo), 
ma su come le entità computazionali (Attori) interagiscono 
in un ambiente massivamente concorrente e potenzialmente fallibile.

In un modello computazionale ad attori, la priorità è la comunicazione e la gestione dei messaggi.

 
- **Inscapsulamento Forte e Isolamento**
  Ogni Attore è un'entità completamente 
  incapsulata. È "strutturalmente" un contenitore di stato e comportamento, ma il suo stato 
  è rigorosamente isolato. Questo significa che la struttura interna di un Attore 
  non è visibile o accessibile all'esterno. L'unico modo per interagire è attraverso 
  l'invio di messaggi asincroni.

- **Il Messaggio come contratto**
  L'attenzione si sposta sulla definizione dei messaggi 
  che verranno scambiati. Questi messaggi definiscono l'interfaccia pubblica e 
  il contratto di **interazione** tra gli Attori. La logica del sistema diventa una complessa 
  rete di conversazioni e risposte a messaggi, piuttosto che una gerarchia di chiamate a metodi sincroni.

- **Concorrenza per Composizione**
  Invece di preoccuparsi di *Lock* e *Thread* per gestire la concorrenza all'interno 
  di un singolo componente  ci si concentra su come comporre Attori indipendenti 
  che lavorano in parallelo e coordinano il loro lavoro tramite lo scambio di messaggi.


Un linguaggio come **Akka** non solo sposta il focus sull'interazione, ma fornisce anche gli strumenti e i 
modelli comportamentali intrinseci (isolamento, asincronicità, supervisione) che risolvono 
le sfide più difficili della creazione di moderni  `Microservizi`_ resilienti e scalabili.


-------------------------------------------
Non determinismo
-------------------------------------------
 
Se una qualche frase di un ``LdP`` induce un computer ad agire in due o più modi
diversi, si ha una esecuzione non deterministica.

Esempi di forme di non determinsimo si hanno:

- `Edsger Dijkstra`_ ha definito un costrutto teorico che introduce la **scelta non-deterministica**
  (usato per prove formali di correttezza)

  .. code::

    if C1 -> S1 [] C2 -> S2 fi. 

  Se entrambe le condizioni (``C_1`` e ``C_2``) sono vere, il sistema sceglie non deterministicamente 
  se eseguire ``S_1`` o ``S_2``.  
- in **Prolog**: La semantica di Prolog non specifica l'ordine in cui il motore di inferenza 
  deve provare le regole o i fatti per soddisfare un goal. 
  Il motore sceglie non deterministicamente (anche se le implementazioni reali seguono un ordine predefinito) 
  un percorso, e se fallisce, "torna indietro" (**backtracking**) e prova un'alternativa.

- In **Akka**: L'ordine in cui gli attori ricevono i messaggi e l'esatto momento in cui elaborano i messaggi 
  è non-deterministico. 
  
  Ad esempio, se l'Actor ``A`` invia due messaggi all'Actor ``B``, non c'è garanzia 
  che ``B`` elabori il Messaggio ``1`` prima del Messaggio ``2`` se c'è traffico di rete o ritardi. 
  Questo non-determinismo può essere visto come un forza del modello, poiché costringe gli sviluppatori a scrivere 
  codice resiliente a qualsiasi temporizzazione.

------------------------------------------------------
Influenza di un LdP sul progettista del software
------------------------------------------------------

Come già evidenziato da :ref:`Il motto di Alan Kay`, la struttura di un ``LdP`` può influenzare 
notevolmente il modo in cui il programmatore modella e 
risolve un problema. Ad esempio:

- **Prolog** (Logico): Incoraggia a pensare in termini di fatti e regole di deduzione, costringendo 
  il programmatore a definire cosa è vero.
- **Java/C++** (OOP): Incoraggia a modellare il mondo in termini di oggetti, classi e relazioni gerarchiche.
- **Lisp/Scala/Haskell** (Funzionale): Incoraggia a pensare in termini di trasformazione di dati 
  immutabili e composizione di funzioni, riducendo gli effetti collaterali.
- **Akka** (Attori): Incoraggia a pensare a un sistema come una collezione di (Micro)servizi 
  che interagiscono usando Messaggi ed Eventi
   
La scelta del linguaggio impone un modello mentale e un modello di oggetto specifico:

- **OOP**: induce a pensare: "Quali entità esistono nel  sistema e quali azioni possono 
  eseguire su sé stesse?" Questo porta a un modello in cui lo stato (la realtà modellata) 
  è distribuito e potenzialmente volatile.

- **FP**: inducea pensare: "Quali trasformazioni (funzioni) devo applicare a un insieme di dati 
  immutabili per ottenere il risultato desiderato?" 
  Questo porta a un modello più robusto per la gestione della complessità e della concorrenza.

- **Actor**: inducea pensare: "Quali attori esistono nel sistema e quali messaggi
  si devono scambiare e in quale modo?" Questo porta a un modello di sistema a (nano/micro)servizi
  come avremo modo di approfondire in seguito.


Il linguaggio non ha creato alcun oggetto reale, 
ma la sua struttura ha creato la sua rappresentazione digitale (*Funzione, Classe, Actor*) 
e ha dettato la logica di sistema (mutazione di stato vs. trasformazione pura vs. scambio di messaggi) 
che il software seguirà.

In questo senso, un ``LdP`` **orienta la soluzione architetturale** che 
il progettista sceglie per mappare un problema del mondo reale nella logica computazionale. 


.. _L'astrazione:

------------------------------------------
L'astrazione
------------------------------------------

Un LdP crea i **modelli di enti** con cui la logica 
del sistema opera.
Questa fase definisce il **concetto di astrazione in informatica** e la sua relazione con la realtà,
o, meglio, con l'insieme delle rappresentazioni umane del mondo perceptio come 'reale'.

+++++++++++++++++++++++++++++++++++++++++++++++
Realtà vs. Modello
+++++++++++++++++++++++++++++++++++++++++++++++

- "Oggetti Reali" (Il **Dominio del Problema**): Sono le entità, i concetti e le interazioni che esistono 
  al di fuori del codice. Ad esempio, una persona, un conto bancario, un evento fisico 
  (come un click del mouse) o una transazione finanziaria. 
  Questi esistono indipendentemente dalla applicazione.
- "Modelli di Oggetti" (Il **Dominio della Soluzione**): Sono le rappresentazioni, o astrazioni, di 
  quegli oggetti reali create all'interno del linguaggio di programmazione.

Quando si utilizza la parola "automobile" nel linguaggio naturale, si evoca un'immagine vaga e ricca 
di connotazioni. Quando si definisce una ``Classe Automobile`` in C++ o Java, si crea un modello preciso 
che ha solo le proprietà (velocità, colore, motore) e i comportamenti (*accelera*, *frena*) 
che sono stati esplicitamente codificati nel linguaggio.

- In C, un modello potrebbe essere la *struct* (struttura).
- In C++, un modello può essere la *Classe automobile*.
- In Prolog, fatti e le regole logiche definiscono le relazioni che coivolgono l'automobile.
- In Akka, un modello potrebbe essere l'*Actor automobile* che differisce da tutti i precedenti
  in quanto esprime l'automobile come un ente intrinsecamente attivo.

 
In conclusione: **la programmazione è un esercizio di modellazione**. 
I linguaggi di programmazione sono strumenti formali e rigorosi che permettono di creare 
rappresentazioni manipolabili di entità per poter applicare una logica e risolvere un problema, 
senza cadere nell'ambiguità o nella relatività del linguaggio umano.


.. Vorresti un esempio di come la scelta tra un modello OOP e un modello Funzionale 
   influenzi la logica del sistema per un problema comune (es. un sistema di calcolo fiscale)?

.. _L'Abstraction Gap:

+++++++++++++++++++++++++++++++++++
L'Abstraction gap 
+++++++++++++++++++++++++++++++++++

  .. Hai centrato perfettamente il problema cruciale della moderna ingegneria del software: 
    l'Abstraction Gap tra il dominio del problema (espresso in Linguaggio Naturale, LN) 
    e il dominio della soluzione (espresso in Linguaggio di Programmazione, LdP).

  .. È assolutamente corretto affermare che i Domain-Specific Languages (DSL) sono la soluzione 
    più efficace per colmare questo divario.🧐 

L'**Abstraction Gap** (*Divario di Astrazione*) è la distanza concettuale tra:

- Il **Dominio del Problema**: I concetti, le regole e le entità come sono compresi e descritti dagli 
  esperti del dominio (es. un economista, un biologo, un esperto fiscale) usando il Linguaggio Naturale.

  *Esempio* in ``LN``: "Ogni cliente della banca deve avere al più un conto corrente in rosso".

- Il **Dominio della Soluzione**: Il modo in cui tali concetti devono essere mappati in strutture, 
  tipi e logiche eseguibili nel *Linguaggio di Programmazione General Purpose* 
  (:ref:`GPL<General Processing Languages>`).
   
  *Esempio* in ``LdP`` (*Java/C++*): Il concetto di "Cliente della banca" può essere modellato come un *Actor*
  che possiede uno o più (riferimenti a) *Oggetti* di classe ``ContoCorrente``  oppure come una riga di 
  una tabella "Clienti" in un database relazionale in relazione con la tabella ``ContoCorrente``
  o in vari altri modi.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
Perché esiste l'Abstraction Gap 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. I LdP più comuni (Java, C++, Python) sono General-Purpose Languages (GPL). 
   Le loro astrazioni di base sono universali e tecniche: classi, tipi, funzioni, cicli, variabili.

Nei GPL più comuni 
**non esistono** tipi nativi come *Microservizio*, *ConttoCorrent*, *ContrattoAssicurativo*, o *EquazioneTermodinamica*.
Il programmatore deve tradurre manualmente il linguaggio del dominio nel linguaggio GPL, 
un processo che richiede tempo, è soggetto a errori di interpretazione e 
spesso diluisce l'intenzione originale del dominio.


.. _Modelli e Linguaggi di modellazione:

++++++++++++++++++++++++++++++++++++++
Modelli e Linguaggi di modellazione
++++++++++++++++++++++++++++++++++++++

Un `Linguaggio di modellazione`_ è un `Linguaggio formale`_ 
che può essere utilizzato per descrivere (modellare) un sistema di qualche natura.

Nel linguaggio comune, il termine `modello` è spesso usato per denotare un'astrazione 
di qualcosa che esiste nella realtà, come ad esempio il modello che posa per un artista, 
una riproduzione in miniatura, un esempio di modo di svolgere un'attività, una forma 
da cui ricavare vestiti, un ideale da seguire, etc.. 

Alcuni (tra cui gli ingegneri) intendono per modello un sistema matematico o fisico che ubbidisce 
a specifici vincoli e che può essere utilizzato per descrivere e comprendere un sistema 
(fisico, biologico, sociale, etc.) attraverso relazioni di analogia.

**Modello=rappresentazione dell'essenza di un sistema**

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/Modello.PNG
         :width: 70%
         :align: center
    - .. image:: ./_static/img/ModelloNumeri.PNG
         :width: 100%
         :align: center
 
.. Nel contesto dei processi di costruzione del software, il termine modello va primariamente 
.. inteso come un insieme di concetti e proprietà volti a catturare aspetti essenziali di un sistema, 
.. collocandosi in un preciso spazio concettuale.   


.. Per l'ingegnere del software quindi un modello costituisce una visione semplificata di un sistema 
.. che rende il sistema stesso più accessibile alla comprensione e alla valutazione e facilita 
.. il trasferimento di informazione e la collaborazione tra persone, 
.. soprattutto quando è espresso in forma visuale.
 


Nel concepire un modello come visione semplificata di un sistema software si assume che il sistema 
abbia già una sua esistenza concreta. 
In alcune fasi di lavoro (in particolare nella fase di analisi) il sistema è il modello; 
un raffinamento o una variazione del modello corrisponde in questo caso ad una variazione del sistema.

La produzione esplicita di modelli si rivela utile in quanto i diversi attori di un processo 
di produzione di software (committenti, analisti, progettisti, utenti, etc) 
operano a diversi livelli di astrazione e con fini diversi. 

Definendo opportuni modelli del sistema da realizzare, in ogni fase del processo di produzione 
l'attenzione può essere focalizzata sugli aspetti rilevanti in quella fase, utilizzando una 
forma di comunicazione comprensibile ad attori diversi. 
Per garantire coesione e interoperabilità, si cerca di individuare regole di corrispondenza 
e di trasformazione automatica tra modelli.

.. _UML:

++++++++++++++++++++++++++++++++++++++
UML
++++++++++++++++++++++++++++++++++++++

UML (*Unified Modeling Language*) è un linguaggio di modellazione e di specifica 
di sistemi software basato sul :ref:`Paradigma Orientato agli Oggetti (OOP)`. Il linguaggio è definito in termini
di un **linguaggio di meta-modellazione** denominato ``MOF`` (si veda `Meta Object Facility`_) .

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/mofUml.PNG
         :width: 100%
         :align: center
    - La `Meta Object Facility`_ di UML2 nella versione incorporata in Eclipse
      (denominata `Ecore`_) può essere usata per definire un linguaggio che permette di esprimere sistemi software come
      oggetti attivi (**attori**) che interagiscono tra loro a scambio di messaggi si comportano come `MooreMachines`_.


Nel contesto dell'ingegneria del software, ``UML`` viene usato soprattutto per descrivere il dominio applicativo 
di un sistema software e/o il comportamento e la struttura del sistema stesso. 

Il modello è strutturato secondo un **insieme di viste** che rappresentano diversi aspetti della cosa modellata 
(funzionamento, struttura, comportamento e così via), a scopo sia di analisi sia di progetto, 
mantenendo la tracciabilità dei concetti impiegati nelle diverse viste.

Il linguaggio `UML`_ permette di definire modelli al termine di ogni fase
del processo di sviluppo software:

- *Use Case Diagrams*: permettono di esprimre il risultato della fase di analisi dei requisiti; 
- *class diagrams*, *sequence diagrams*, *activity diagrams*, *statechart diagram* permettono 
  di esprimre la struttura e il comportmento il sistema al termine della analisi del problema 
  e del progetto:
- *deployment diagrams* permettono di esprimere le modalità di distribuzione del prodotto.

Il linguaggio (metanodello) di `UML`_ (*(Unified Modeling Language*) è stato definito come strumento 
di modellazione di uso generale (GPL), con riferimento alla programmazione ad oggetti.

.. node::
   
  Il concetto di *Actor* che viene utilizzato all'interno dei *Diagrammi dei Casi d'Uso*
  (**Use Case Diagrams**) denota run'entità esterna che interagisce 
  con il sistema in esame,  
  ed è quindi totalmente diverso dalla nostro concetto di   
  :ref:`Attore<Gli attori come nuovo paradigma?>`
  che introdurremo in seguito.

 

Tecnicamente, UML non è limitato al :ref::ref:`Paradigma Orientato agli Oggetti (OOP)`,
in quanto permette **estensioni** che lo possono rendere capace di 
modellare anche sistemi basati sul :ref:`Modello ad Attori<Gli attori come nuovo paradigma?>`. 
Inoltre esistono  `Profili UML`_ 
definiti da comuità di sviluppattori, come è stato nel caso di Akka.  

Un modello UML standard è una specifica, mentre un modello **xUML** (*Executable UML*)
o **fUML** (*Foundational UML*)
è una rappresentazione formale che può essere utilizzata da un tool 
(come una piattaforma  `MDE`_: *Model-Driven Engineering*) per:

- **Interpretazione**: Eseguire direttamente il modello per simulare o testare il sistema.
- **Trasformazione** (Generazione di Codice): Generare codice sorgente eseguibile completo 
  (codice della piattaforma) dal modello astratto.


.. Sebbene UML possa modellare sistemi distribuiti (ad esempio, con diagrammi di Componenti o di Sequenza), 
  mancano concetti nativi eseguiibili specifici per i sistemi distribuiti e le comunicazioni asincrone.
  Un concetto come quello di "Microservizio" deve essere decomposto manualmente in classi, 
  configurazioni di rete, e gestori di messaggi, un processo che richiede tempo ed è soggetto a errori.

Questi aspetti sono però ua sorta di 'add on' al corpo principale di UML
e :ref:`Il linguaggio qak` che introdurremo più avanti 
vuole fornire uno strumento più adatto (in quanto esplicitamente 
orientato allo scopo) ad 
abbattere i costi di produzione di un sistema distribuito.


------------------------------------------------------
Domain-Specific Languages (DSL)
------------------------------------------------------

:ref:`L'Abstraction Gap` è un dato di fatto strutturale nell'informatica e 
i *Domain-Specific Languages* (**DSL**) rappresentano oggi la tecnica più potente per riconciliare 
il ricco e complesso linguaggio di un certo dominio applicativo con i rigidi e universali GPL.

I DSL sono linguaggi creati per esprimere in modo conciso e non ambiguo i concetti e le regole di un 
dominio applicativo specifico. Il loro scopo primario è alzare il livello di astrazione per 
colmare :ref:`L'Abstraction Gap` in modo più espressivo di quanto possa fare una libreria o 
un framework di un GPL.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SQL (Dominio Specifico)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

È un primo esempio di **DSL**, strettamente **dichiarativo**, 
poiché si concentra sulla descrizione del **risultato desiderato** (i dati da recuperare) 
piuttosto che sulla sequenza di passi per ottenerlo.

**Caratteristiche:**
   - **Non Procedurale:** Non si specificano i cicli o le condizioni di flusso.
   - **Set-Oriented:** Le operazioni agiscono su insiemi di dati (tabelle).
   - **Focus sui Dati:** La logica è incentrata su come manipolare e interrogare i dati relazionali.


I DSL possono essere classificati in base alla loro implementazione:

.. _DSL Interno:

++++++++++++++++++++++++++++++++++++++
DSL Interno  
++++++++++++++++++++++++++++++++++++++

Un DSL costruito all'interno di un GPL esistente (l'Host Language) viene anche detto 
**Embedded DSL**.
Utilizza la sintassi e la semantica dell'LdP host per creare astrazioni di livello superiore.

- *Vantaggio*: Facile integrazione, sfrutta l'infrastruttura dell'Host Language (es. compilatore, debugger).
- *Esempi*: LINQ in C#, le API Funzionali di Scala (es. le collezioni), l'uso di Builder Pattern in Java.

.. _DSL Esterno:

++++++++++++++++++++++++++++++++++++++
DSL Esterno
++++++++++++++++++++++++++++++++++++++

Si tratta di un linguaggio completamente nuovo, con la sua sintassi, parser e motore di esecuzione.

- *Vantaggio*: Massima espressività, può essere letto e scritto direttamente dagli esperti del dominio, totale indipendenza dal GPL.	
- *Esempi*: SQL (per interrogare database), Regex (per pattern matching), YAML/JSON (per la configurazione).


Il framework **Xtext** si basa sull'ecosistema **Eclipse** e offre strumenti per ampliare 
Eclipse con appositi plugin per fornsre un editor guidato dalla sintassi, e 
un generazione di codice (Java, Kotlin o altro) che realizza la semantica del linguaggio.

.. Questa impostazione si pone nel solco della Model driven engineering*.

.. image:: ./_static/img/factory.jpg
          :align: center
          :width: 100%



I DSL traducono direttamente concetti del ``LN`` in costrutti formali 
che sono facili da comprendere sia dagli esperti del dominio che dai programmatori.
   
**Esempio**: Nonostante Java non abbia una parola chiave "Microservizio", 
un Framework (come *Akka* o *Spring Cloud*) può essere visto come un insieme di astrazioni che creano un 
DSL interno:
   
- Si usano annotazioni come ``@Service`` o si definiscono ``Actor`` (come in *Akka*) che mappano direttamente 
  il concetto di unità isolata del microservizio.
- Questo "Linguaggio" all'interno del Framework permette agli sviluppatori di pensare e scrivere in 
  termini di servizi anziché solo in termini di classi e thread.

:ref:`Il linguaggio qak` che introdurremo più avanti costituisce una :ref:`DSL Esterno` che permette di esprimere
in modo diretto concetti (attore, messaggio, etc.) particolarmente rilevanti per la costruzione di sistemi software
distribuiti a microserivizi.

**Vantaggi Principali a livello Applicativo**

L'uso di DSL per colmare :ref:`L'Abstraction Gap` offre vantaggi sostanziali:

- **Riduzione dell'Ambiguità**: I concetti del dominio vengono espressi in modo formale e non ambiguo 
  (es. "calcolaInteressi" nel DSL fiscale è univoco, a differenza dell'LN).
- **Aumento della Produttività**: I programmatori lavorano con astrazioni più vicine al problema, 
  riducendo la quantità di "boilerplate code" (codice standardizzato e ripetitivo).
- **Manutenibilità**: Quando le regole del dominio cambiano (es. una nuova legge fiscale), si modificano 
  solo le definizioni nel DSL (che è ad alto livello), senza toccare gran parte della logica 
  di basso livello del GPL.


.. _I DSL e i Digital Twins:

------------------------------------
I DSL e i Digital Twins
------------------------------------

I DSL consentono agli esperti di un dominio (ingegneri meccanici, fisici, chimici) di esprimere 
la logica e le proprietà di un asset fisico senza dipendere da programmatori software 
o da GPL.

Questo aspetto è particolarmente rilevante per un sistemi software che svolge il ruolo 
di `Gemello Digitale`_  (**Digital Twin** o **DT**) di un sistema fisico.

Il termine *Digital Twin* è stato introdotto nel ``2003``  da *Michael Grieves*
per denotare la replica digitale di una qualsiasi Entità Fisica che
viene vista come la fonte dei dati  
su cui il **DT** opera per realizzare alcune funzionalità chiave:

- **Monitoraggio in Tempo Reale**: Il ``DT`` è alimentato da streaming data (telemetria) 
  che riflette costantemente lo stato operativo, la salute e le prestazioni dell'asset fisico.

- **Simulazione e Previsione**: Permette di eseguire scenari What-If ("Cosa succede se...") 
  sul gemello virtuale senza rischiare danni all'entità fisica.

- **Diagnostica e Ottimizzazione**: Viene utilizzato per identificare le cause profonde 
  dei problemi e per testare le modifiche operative prima di implementarle nel mondo reale.

- **Manutenzione Predittiva**: Una delle applicazioni più potenti: il ``DT`` analizza 
  le prestazioni attuali, le confronta con i modelli di degrado e prevede 
  esattamente quando e dove un componente fallirà, permettendo la manutenzione prima del guasto.


Il ``DT`` fornisce una rappresentazione concreta di un :ref:`Sistema complesso<Sistemi complessi>`. 
Questo riduce l':ref:`Abstraction gap` tra l'utente finale (che lavora con l'asset fisico) 
e il programmatore (che scrive il codice di controllo).

In questo campo, i DSL non sono solo strumenti di codifica, ma sono
strumenti indispendabili per la **modellazione concettuale** che rendono il 
``DT`` più accurato, manutenibile e interoperabile.

Un DSL può servire anche come linguaggio intermedio standardizzato per descrivere e 
integrare i dati provenienti da fonti eterogenee di dati 
generati da sistemi di controllo industriali (*PLC, SCADA*).

I ``DT`` sono intrinsecamente basati su **eventi**, guidati dal flusso continuo di dati 
**IoT** (`Internet of Things`_). 
I sistemi software che li gestiscono devono essere costruiti con architetture reattive 
e asincrone (come l'Actor Model o l'architettura a microservizi) per gestire 
l'alta velocità e la bassa latenza richieste.

Il ``DT`` eleva il ruolo del programmatore da semplice codificatore a **modellatore di sistemi**
e **ingegnere di dominio**. Il valore non risiede più solo nello scrivere codice, ma nel:

- **Creare Modelli Accurati**: Sviluppare modelli matematici e fisici che replichino fedelmente 
  il comportamento del mondo reale.

- **Ingegneria dei Dati**: Progettare data pipelines efficienti e sistemi di time-series 
  database per gestire e pulire il volume massiccio di dati in tempo reale generato dal gemello.

Il *Digital Twin*, quindi, è un caso emblematico di come l'obiettivo di molti moderni sistemi software 
si sposta verso la proattività, la previsione e la conoscenza olistica dello stato operativo.
La transizione :ref:`Dagli algoritmi ai sistemi software` trova qui il suo più evoluto
compimento.


.. A questo punto possiamo tornare al problema di come descrivere le modalità di 
   comunicazione con il sistema introdotto nella sezione :ref:`Interagire con un sistema software`. 
  Per affrontare meglio il problema, introduciamo un  nostro ``DSL``:
  :ref:`Il Linguaggio qak`.



.. _Computare:



.. Riprenderemo questo importante discorso più avanti, nella sezione :ref:`I DSL e i Digital Twins`.





.. _Sistemi software:

=========================================
Sistemi software
=========================================

In ambito informatico, un Sistema è spesso descritto come:

.. code::

  Una combinazione strutturata di componenti che raccolgono, elaborano, 
  memorizzano e distribuiscono informazioni per supportare 
  servizi e processi decisionali e di controllo.


Storicamente, il software nasce come l'insieme di **istruzioni-macchina** che deve essere
eseguito da un computer su un insieme di **dati** per realizzare un algoritmo.

L'evoluzione di linguaggi ad alto livello ha visto la rapida introduzione di
costrutti capaci di esprimere semplici forme di aggregazioni di istruzioni e dati (componenti sofware).

.. (si veda :ref:`Componenti software di base`) che sono poi prpgressivamente evolute in veri e propri :ref:`Componenti software`.

L'uso del termine **sistema software** enfatizza, 
in genere, prodotti  complessi, costruiti o studiati in termini   
della  organizzazione e della interazione tra i componenti che formano il prodotto. 

.. Vi è quindi una stretta relazione con il concetto di :ref:`Archittettura software`  .
 
Quando si ha a che fare con un sistema software, è utile distinguere **due livelli**:

1. **Descrizione esterna** — come il sistema parla con l'esterno: API, messaggi, contratto di servizio.
2. **Comportamento interno** — come ogni componente (oggetto, attore, microservizio) evolve nel tempo: 
   stato, transizioni, reazioni ai messaggi, logica interna.

Molti strumenti coprono solo il primo livello (descrizione dell'interfaccia — es. `OpenAPI`_), 
altri solo il secondo (codice, FSM, logica interna). 
Ma per sistemi complessi servono entrambi in modo coerente.




-----------------------------------------
Viste di un sistema software
-----------------------------------------
Un sistema software può essere descritto da diversi punti di vista:

.. list-table:: 
  :widths: 60,40 
  :width: 100%
      
  - -  
      .. code:: text

      L'osservatore di un sistema software può 
      parlare di un sistema considerando
      diversi punti di vista


      - :ref:`Vista esterna`
      - :ref:`Vista interna`
      - :ref:`Vista sommersa`
    - Quello che si vede e non
      
      .. image:: ./_static/img/Viste.PNG
         :align: center
         :width: 80% 
 

.. _Vista esterna: 

++++++++++++++++++++++++++++++++++++++++
Vista esterna
++++++++++++++++++++++++++++++++++++++++

Il sistema  viene visto come una entità accessibile attraverso una  :ref:`API` 
(**Application Programming Interface**)
intesa come il punto di contatto che consente l'interazione tra codici in esecuzione


.. _Vista interna:

++++++++++++++++++++++++++++++++++++++++
Vista interna
++++++++++++++++++++++++++++++++++++++++

Il sistema  viene visto come un insieme di enti computazionali (funzioni, oggetti, processi, etc.) che operano  
interagendo tra loro e con il mondo esterno (clienti, dispositivi, etc.) usando adeguati supporti

.. _Vista sommersa:

++++++++++++++++++++++++++++++++++++++++
Vista sommersa
++++++++++++++++++++++++++++++++++++++++

Il sistema  è l'ultimo livello (*ayer*) di uno stack i cui livelli sottostanti 
(librerie, infrastrutura, etc.) forniscono il supporto alla esecuzione. 

Nel corso degli anni sono stati proposti e usati diversi tipi di componenti software,
che hanno contribuito a formare lo **spazio concettuale** dei linguaggi di programmazione 
di alto livello.

---------------------------------------------
Componenti software 
---------------------------------------------
In generale, il concetto di **componente software** può essere definito come:

.. code::

  una unità autonoma e riusabile di codice che svolge una 
  funzione specifica all'interno di un sistema software, 
  promuovendo la riusabilità, la modularità e la manutenibilità del codice

Questa idea di base ha subito una profonda evoluzione nel corso degli anni, tanto che
occrrerebbe un corso ad hoc per descriverla. 

Trascurando molti rilevanti aspetti, noi cercheremo di 
delinarne alcuni punti importanti sia sul piano concettuale, sia sul piano pragamatico,
relativi alle moderne pratiche di costruzione di sistemi sofwtare.

.. https://mia-platform.eu/it/blog/creare-componenti-software-componibili/

+++++++++++++++++++++++++++++++++++++++++++++++
Componenti software di base
+++++++++++++++++++++++++++++++++++++++++++++++

I linguaggi di programmazione più diffusi permettono di costruire sistemi software 
composti da due principali specie di componenti-base:

.. list-table:: 
  :widths: 20,80
  :width: 100%

  * - .
      
      .. image:: ./_static/img/funz.PNG
          :align: center
          :width: 70%        
    - Una funzione rappresenta un componente che permette la definizione parametrica di 
      istruzioni e la loro esecuzione mediante trasferimento di controllo.

      *Linguaggio di riferimento*: ``JavaScript`` (``Node.js``)

  * - pojo

      .. image:: ./_static/img/obj.PNG
          :align: center
          :width: 80%     
    - Un oggetto incapsula uno stato e un insieme di funzioni (metodi), la cui esecuzione
      avviene mediante chiamata di procedura (trasferimento di controllo).

      *Linguaggio di riferimento*: ``Java``.

      Un oggetto può essere dotato di comportamento autonomo incapsulando un **Thread**.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
I POJO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Nel seguito useremo il termine **POJO** (*Plain Old Java Object*) per denotare componenti software
'vecchio stile' che interagiscono mediante trasferimento del controllo (chiamate di procedera).


+++++++++++++++++++++++++++++++++++++++
Oltre gli oggetti
+++++++++++++++++++++++++++++++++++++++

Lo sviluppo delle reti informatiche e di Internet ha promosso la costruzione di **sistemi software 
distribuiti** su più nodi di elaborazione, su ciascuno dei quali possono essere eseguiti
programmi espressi medianti linguaggi diversi.

- La costruzione di **sistemi software distributi eterogenei** è resa possibile dall'uso 
  (entro funzioni ed oggetti) di protocolli di comunicazione (come ``UDP, TCP, HTTP, MQTT, CoAP``, etc.)
  e richiede logicamente componenti  capaci di interagire 
  (spesso in modo ``asincrono``) mediante **scambio di messaggi** e non più mediante trasferimento 
  di controllo con chiamate di procedura.
- Ciò ha portato alla definizione di nuovi tipi di componenti software
  quali gli :ref:`Attori<Gli attori come nuovo paradigma?>`, gli :ref:`agenti software (intelligenti)<<Agenti>`, 
  i `Microservizi`_, le `Funzioni serverless`_, etc.


.. _Un viaggio nei sistemi software:

-------------------------------------
Un viaggio nei sistemi software
-------------------------------------

In questa sezione cercheremo di parlare, in linguaggio naturale, di un sistema denominato **S** 
supponendo che sia un *sistema hardware/software* con cui sia possibile interagire via rete.

.. qualificabile come ciò che oggi denominiamo *servizio* (Web).
.. Consideriamo la situazione rappresentata nella figura che segue:

.. image::  ./_static/img/SInU.jpg
    :align: center 
    :width: 55%        

Il sistema **S**  è posto in un 'universo' (**U**) in cui si trova anche un  
osservatore (umano o meno) **Obs**, che      
può interagire con ``S``  in molti modi diversi. 

+++++++++++++++++++++++++++++++++++++++++++++
Punti di vista
+++++++++++++++++++++++++++++++++++++++++++++
.. list-table:: 
  :widths: 50,50
  :width: 100%

  *
    - . 
    
      .. image:: ./_static/img/VisteObs.PNG
          :align: center
          :width: 100%  
    - La figura vuole rappresentare l'idea che due osservatori di uno stesso oggetto
      possono avere viste diverse di esso
      e quindi pensare che l'oggetto osservato abbia proprietà diverse.

Dire che **S** è un sistema **hardware/software** induce a pensare che sia
costruito usando un **computer** (hardware) capace di elaborare **istruzioni** (software) che determinano 
il comportamento osservabile del sistema.

Il  *sistema globale S + Obs* è un sistema distribuito di cui può essere
difficile *parlare in modo preciso* senza un opportuno linguaggio capace
di **esprimere gli aspetti salienti della interazione/comunicazione**, lasciando sullo sfondo dettagli importanti,
ma non essenziali.


In assenza di ulteriori informazioni, ``S`` potrebbe essere visto come un **servizio**,
pensando che il sistema sia in grado di **fornire funzionalità** a
**clienti** (umani o programmi) che ne fanno richiesta usando 
protocolli di rete standard, come ``HTTP`` e ``WS`` (*WebSocket*) o altri.

Queste sommarie indicazioni sono già suficienti a dare una idea 
di cosa stiamo parlando comprensibile a **molti** esseri umani,
ed in particolare a coloro che sono abituati a usare **Internet**.
Osserviamo però che questo modo di 'capire' cosa sia ``S``  era **praticamente impossibile**
solo pochi decenni fa, quando i *computer* e *Internet* non erano così diffusi e
facilmente accessibili.

Tuttavia, anche  in comunità umane in cui il termine **servizio** (software) è ormai di uso comune, 
non è certo scontato che sia a tutti 'chiaro' cosa sia un *servizio*, come sia fatto e come funzioni.
Inoltre, anche i più esperti del settore potrebbero trovarsi in difficoltà di fronte a  domande del tipo:

**Domanda1**: che differenza c'è' tra un servizio e un normale **programma** che gira su un computer?
Certo si può presumere che un serivizio sia un programma, ma allora cosa lo rende un **servizio**?

**Domanda2**: che differenza c'è' tra un *servizio*  e un **microservizio** ?

In attesa di rispondere a domande di questo tipo, al momento osserviamo solo che:

- **tutti is sistemi software servono a qualcosa ma non tutti sono servizi**

.. _Sistemi Embedded/IoT:

++++++++++++++++++++++++++++++++++++++
Sistemi Embedded/IoT
++++++++++++++++++++++++++++++++++++++

I computer oggi in uso sono spesso 
dotati di dispositivi di interazione con il mondo fisico (si pensi a un un :ref:`RaspberryPi` 
e ai suoi  PIN **GPIO** (*General Purpose IO*) 
e rappresentano una categoria qualitativamente diversa dai computer generici che elabora solo dati.

Un **sistema embedded** è un sistema di calcolo dedicato a svolgere una o poche funzioni specifiche, 
integrato all'interno di un prodotto o dispositivo fisico.
Quando questi sistemi sono connessi in rete — spesso a Internet — e possono interagire con altri dispositivi 
o servizi digitali, si parla di **sistemi IoT** (`Internet of Things`_).

.. _Sistemi cibernetici:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Sistemi cibernetici
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un computer interfacciato con il mondo fisico rappresenta
un **sistema cibernetico** la cui funzione primaria è modificare o preservare lo stato del mondo 
reale. Come tale,  è un sistema — naturale, artificiale o misto — capace di
raggiungere o mantenere uno stato desiderato (un obiettivo):

- percependo l'ambiente attraverso sensori,
- valutando l'errore rispetto all'obiettivo,
- agendo sull'ambiente tramite attuatori,
- chiudendo il ciclo tramite un meccanismo di feedback.


.. _RaspberryPi:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
RaspberryPi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Il `Raspberry Pi`_ è una piccola scheda computer, economica e a basso consumo, molto utilizzata per 
realizzare sistemi embedded e IoT grazie a:

- un sistema operativo completo (generalmente Linux)
- interfacce di comunicazione evolute (Wi-Fi, Bluetooth, Ethernet)
- GPIO per la connessione diretta a sensori e attuatori fisici
- una comunità e un ecosistema di librerie molto vasti





-------------------------------------
Capire sperimentando
-------------------------------------

.. Prima di addentrarci nella risposta a  domande di questo tipo, può essere utile affrontare 

Il problema di capire/definire
cosa sia  ``S`` può essere affrontato seguendo un approccio analogo a quello di un ricercatore che 
vuole studiare un nuovo oggetto fisico.
In questo caso, il ricercatore potrebbe iniziare a porsi alcune domande del tipo:   

#. cosa fa questo oggetto?
#. come funziona?
#. come è fatto?
#. quali sono le sue proprietà più interessanti?

Notiamo che le domande ``1`` e ``2`` implicano una certa **osservazione** dell'oggetto in azione,
mentre le domande ``3`` e ``4`` richiedono una certa **analisi** dell'oggetto, magari smontandolo per 
vedere come è fatto dentro.

+++++++++++++++++++++++++++++++++++
Capire interagendo
+++++++++++++++++++++++++++++++++++

Sembra ragionevole pensare che, prima di 'smontare' un oggetto, sia  meglio intergire con 
l'oggetto in una *fase di 'pura osservarzione'*, per cercare di ricavarne informazioi utili 
per il suo utilizzo
e per **inferire**, se possibile, alcune delle sue proprietà.

Siamo qui di fronte a una delle problematiche più interessanti e controverse della scienza: 
come si fa a studiare un oggetto nuovo di cui non si sa nulla?
Anche una questione che sembra banale, come *la 'semplice (!) osservazione*, è oggi un tema di ricerca 
avanzata in molti campi, dopo che la `meccanica quantistica`_ ha mostrato che
l'atto stesso dell'osservazione 
può influenzare  (prima ancora di 'smontarlo') l'oggetto osservato 
o addirittura **determinarne alcune proprietà**.

Fortunatamente, per i nostri scopi, potremo trascurare queste proprietà che
sembrano caratterizzare il mondo in cui viviamo, almeno fino a quando non 
dovremo occuparci di sistemi software che usano il :ref:`Quantum computer`.

.. _Interagire con un sistema software:

+++++++++++++++++++++++++++++++++++++++++++
Interagire con un sistema software
+++++++++++++++++++++++++++++++++++++++++++

Nel caso in cui ``S`` sia un sistema software, è implicito il fatto che la interazione richiede 
l'uso di un computer e/o di una rete di comunicazione.


.. Quello più appropriato 
   è, nel nostro caso, usare un *computer* (un **client**) per inviare comandi al servizio
   e per ricevere risposte.

.. image::  ./_static/img/SInUComputer.jpg
    :align: center 
    :width: 60%      

+++++++++++++++++++++++++++++++++++++++++++++++
Capire implica opportuni livelli di conoscenza
+++++++++++++++++++++++++++++++++++++++++++++++

L'informazione scambiata tra un sistema software ``S`` e ``Obs`` è di solito 
rappresentata in forma di stringa usando caratteri
quali `UTF-8`_. Ma questo dettaglio di basso livello è piuttosto **irrilevante per catturare gli aspetti
salienti** della comunicazione.

Questo aspetto è ancora più evidente considerando che noi 'sappiamo' 
che ``S`` (o almeno il suo *hardware) è semza dubbio formato da *atomi* (su questo punto ci sarebbe da approfondire ...) ; 
tuttavia nessun essere umano penserebbe che
questo livello di conoscenza sia necessario (o meglio **il livello 'giusto'**) per capire ``S``.

In altri termini, per capire ``S`` non è oggi necessario (al momento almeno) 
studiare discipline come la *fisica* o la *chimica*
o la *biologia* o  la *psicologia*. Pensandoci bene, non è nemmeno necessario studiare
**calcolatori elettronici**, perchè è implicito che quello che fa ``S`` è determinato dal *software*,
che ha nell'hardware del computer, la sua premessa indispensabile, il suo 'supporto vitale'
ma non gli elementi necessari per fornire una adeguata 'spiegazione' di ``S``.

Potrebbe anche non essere nemmeno necessario addentrarsi nella parte di software nota come **sistema operativo**: 
per capire pienamente ``S`` sarebbe però necessario 
conoscere  il **linguaggio di programmazione** (o i linguaggi) 
con cui è stato specificato il comportamento di ``S`` : al più è necessario conoscere anche
il rapporto tra il linguaggio e il primo livello si software limitrofo sottostatnte.

Ma prima di 'aprire il sistema' per vedere come è fatto 'dentro', proviamo a capirlo seguendo l'idea
meno invasiva di **comunicare** con esso.

Tenendo conto del moderno punto di vista scientifico, non possiamo dimenticare che osservatore 
e osservato sono parte dello stesoo 'universo' e che il funzionamento di ``S`` potrebbe essere legato 
non solo al modo in cui l'osservatore interagisce direttamente con esso, ma anche da altri fattori,
ad esempio la temperatura e la pressione dell'ambiente, flare solari, etc.

Tuttavia è ragionevole pensare che, per studiare ``S``, l'osservatore possa limitarsi a interagire con esso
usando un computer come unico 'strumento di interazione', senza preoccuparsi troppo di altri fattori esterni
(come ha proposto di fare per primo *Galileo*, al fine di distinguere ciò che è necessario
da ciò che può essere ignorato in prima istanza).

.. _Conoscere per comunicare:

+++++++++++++++++++++++++++++++++++
Conoscere per comunicare
+++++++++++++++++++++++++++++++++++

Per poter **comunicare proficuamente** con  ``S``, l'osservatore ``Obs`` deve conoscere:

#. il **protocollo di comunicazione (P)** che permette al computer che supporta ``S`` di ricevere/trasmettere 
   informazione e quindi di iteragire con il computer usato da ``Obs``;
#. il **vocabolario/linguaggio** che ``S`` usa per denotare l'informazione trasmessa/ricevuta 
   come **messaggi**  usando ``P``;
#. il **legame logico della interazione** che si stabilisce in ogni particolare tipo di 
   comunicazione tra due enti.

.. _La interazione come vincolo:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
La interazione come vincolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La necessità di conoscere il **legame logico della interazione** nasce dal fatto che vi sono varie forme di 
comunicazione e che queste comportano diverse forme
di interazione logica tra gli enti comunicanti. Ad esempio, il sistema ``S``  potrebbe essere:

#. capace di rispondere a **richieste** provenienti da uno o più ``Obs``, inviando
   la risposta a chi ha fatto la richiesta. Se due ``Obs`` diversi inviano richieste a ``S``,
   ognuno di loro si aspetta di ricevere una risposta pertinente alla
   propria richiesta, senza confusioni.
  
   .. note::

    Notiamo che l'invio di una richiesta non implica che ``Obs`` si blocchi
    in attesa delle risposta. in tal caso si avrebbe una **operazione sincrona** e il canale di comunicazione
    rimarrebbe aperto fino alla risposta.
          
    ``Obs`` potrebbe inviare la richiesta come **operazione asincrona**; in tal caso il canale di comunicazione
    potrebbe chiudersi subito dopo l'invio della richiesta e ``S`` dovrebbe trovare  modi opportuni per
    inviare la risposta che  ``Obs`` si aspetta e che elaborerà quando  
    sarà 'disposto a farlo'.
#. **emettere informazioni**  (dette **eventi**) in modo spontaneo verso il mondo esterno, che potrebbero
   essere 'captate' da uno o più ``Obs`` (si pensi ad esempio a un servizio che avvisa su allarmi,   
   congestione o blochhi stradali, etc.)
   Questa forma di comunicazione viene detta `Publish–subscribe`_ e viene supportata da broker come 
   ``RAbbitMQ, Mosquritto, HiveMQ , Kafka``.
#. capace di eleborare messaggi inviati in modo
   `fire-and-forget`_ , impegnandosi a gestirli come **comandi da eseguire** e/o a restituire risultati
   in forma di **notifiche/eventi**. 

Ognuna delle forme di comunicazione citate costituisce un **vincolo** tra gli enti comunicanti, che devono agire
ciascuno in modo coerente con l'altro. E' simile al tipo di vincolo che lega due danzatori.

Anche questo semplice e vago elenco di possibiltà mostra come possa essere
difficile *parlare in modo preciso* di un sistema software senza un opportuno linguaggio capace
di **esprimere gli aspetti salienti della interazione/comunicazione**, lasciando sullo sfondo dettagli importantissimi,
ma non essenziali per la definizione e la comprensione del  *sistema globale S + Obs*.

---------------------------------------------------
Sistemi software come servizi (ma non solo)
---------------------------------------------------

Il sistema software ``S`` risulta accessibile a ``Obs`` attraverso l'uso di un particolare sistema fisico 
(il **computer**) che ha la capacità di inviare/ricevere informazioni usando reti cablate e/o wireless e opportuni
**protocolli** di comunicazione quali ``HTTP``, ``TCP``, ``MQTT``, ``WS`` ed altri.


.. _infrastruttura:

++++++++++++++++++++++++++++++++++++++++++++
L'infrastruttura
++++++++++++++++++++++++++++++++++++++++++++

Perché il computer usato da ``Obs`` (**Client**) possa interagire con ``S``
occorre disporre, allo stato attuale della tecnologia, di un ponte di comunicazione.

- **Networking**: Entrambi i computer devono essere sulla stessa rete (LAN) o connessi tramite VPN/Internet. 
  Occorre conoscere l'Indirizzo IP del computer su cui gira S.
- **Wrapping**: Se S è un programma "chiuso" (es. uno script che gira solo da terminale), 
  occorre aggiungere uno strato software (un *Framework* come **Flask** per Python, **Express** per JS,
  SpringBoot o  ASP.NET) che riceva le chiamate su rete e le "passi" a ``S``.
- **Port**: occorre scleglier un "canale" numerico (es. ``8080``) su cui il server rimarrà in ascolto.
- **Firewall**: Sul computer di S, occorre aprire la porta scelta nel firewall per permettere il traffico in entrata.


.. _framework:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
I framework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un **framework** è una struttura logica di supporto su cui uno sviluppatore può costruire software.

A differenza di una semplice libreria, il framework fornisce un'architettura predefinita e un insieme di strumenti, 
componenti e regole che guidano lo sviluppo, permettendo di non dover riscrivere codice comune da zero

.. note::

  Molti framework gestiscono le comunicazioni client-server, solitamente via ``HTTP/HTTPS`` o :ref:`WebSockets`; tra questi:
  ``Node.js (Express)``, ``FastAPI (Python)``, :ref:`javalin`, ``Spring Boot (Java)``.

  Nel campo dei Web *React* e *Angular* sono framework per **Frontend**, mentre Django (Python), Laravel (PHP), Spring (Java)
  sono framework per **Backend**.



Le caratteristiche principali di un framework includono:
  
- **Inversione del controllo (IoC)**: A differenza delle librerie, dove il programmatore chiama il codice esterno, 
  in un framework è la struttura stessa a chiamare il codice scritto dall'utente nei punti appropriati.
- **Estendibilità**: Permette di personalizzare specifiche parti del software per aggiungere funzionalità.
- **Codice predefinito**: Include soluzioni già pronte per compiti ripetitivi 
   (come la gestione dei database o l'autenticazione degli utenti).


Un volta stabilita una connessione, il computer **Client** è analogo ai tipi di strumenti 
telescopi, miscroscopi, acceleratori di particelle, etc.) usati dagli scienziati.

Ovviamente, la conoscenza di quale protocollo (**P**) usa  ``S`` per interagire con il mondo esterno
non è sufficiente: occorre anche conoscere la :ref:`Sintassi e semantica` delle 'frasi'
veicolate tramire **P**. In altre parole, ``S`` definisce un **proprio vocabolario**, o più 
in generale un  **proprio linguaggio** che ``Obs`` deve conoscere per interagire in modo
proficuo con ``S``.

.. _API:

++++++++++++++++++++++++++++++++++++++++++++
Le API
++++++++++++++++++++++++++++++++++++++++++++

Nei sistemi software accessibili in rete, di solito si esegue un mappaing tra le capacità interne del sistema 
e un'interfaccia esterna, l'**API** (*Application Programming Interface*) che stabilisce il "contratto" 
che definisce quali informazioni il sistema può ricevere e cosa risponderà.

.. Le API usando spesso il formato **JSON**, che è leggibile sia dagli umani che dalle macchine.

Senza **API standardizzate**, non ci sarebbe un accordo condiviso su come le diverse applicazioni o i servizi software comunicano. 
I programmatori di due applicazioni separate dovrebbero parlare tra loro per determinare ogni volta 
come sviluppare lo scambio di dati.


Di solito una API specifica almeno:
 
- **Input/Output**: Quali argomenti accetta una specifica funzionalità di ``S``? Che tipo di dati restituisce? 
  (Es. una stringa, un numero, un'immagine?).

- **Protocollo**: Il più comunenei servzi software è **HTTP**, 
  seguendo lo stile architetturale :ref:`REST` (**Representational State Transfer**).

Aspetti importanti in relazione all'uso di un sistema sono anche:

#. Gestione dello Stato

   - **Stateless**: Ogni richiesta è indipendente (es. una funzione che calcola la radice quadrata). 
     
   - **Stateful** : ``S`` ricorda le azioni precedenti (es. un carrello della spesa). 
     In questo caso, il client deve inviare un "ID sessione" per farsi riconoscere.

#. Concorrenza

  ``S`` è in grado di gestire più richieste contemporaneamente? 
  Se due client chiamano la stessa funzione nello stesso istante, ``S`` mette in coda le richieste? 
  Se ``S`` non è multi-thread, il :ref:`framework` che funge da wrapper della 
  :ref:`infrastruttura`  dovrà realizzare e gestire la coda.



Al giorno d'oggi esistono diverse soluzioni consolidate
per descrivere in modo formale (le interfacce di) servizi software,
alcune delle quali sono largamente usate. 

Non tutte sono “formalismi puri” in senso teorico, ma piuttosto **linguaggi di descrizione contrattuale**
(interface description languages, IDL / API description languages). 

.. _REST:

+++++++++++++++++++++++++++++++++++++++++++++++++++
Representational State Transfer (REST)
+++++++++++++++++++++++++++++++++++++++++++++++++++

REST è uno stile architetturale per sistemi distribuiti. L'espressione “representational state transfer” 
e il suo acronimo, REST, fu introdotto nel 2000 nella tesi di dottorato di **Roy Fielding**.

REST rappresenta un sistema di trasmissione di dati su HTTP senza ulteriori livelli (quali ad esempio `SOAP`_). 
I sistemi REST non prevedono il concetto di sessione, ovvero sono **stateless**.

REST prevede che la scalabilità del Web e la sua crescita siano risultati di pochi principi chiave di progettazione:

- lo stato dell'applicazione e le funzionalità sono divisi in risorse web
- ogni risorsa è unica e indirizzabile usando sintassi universale per uso nei link ipertestuali

.. - tutte le risorse sono condivise come interfaccia uniforme per il trasferimento di stato tra client e risorse, 
  
  .. questo consiste in:

..  - un insieme vincolato di operazioni ben definite
  - un insieme vincolato di contenuti, opzionalmente supportato da codice a richiesta
  - un protocollo che è: client-server, privo di stato (stateless) memorizzabile in cache, a livelli.

Il funzionamento di REST prevede una struttura degli `URL`_ (*Uniform Resource Locator*)
ben definita che identifica univocamente una **risorsa** o un insieme di risorse 
e l'utilizzo dei metodi HTTP specifici per il recupero di informazioni,
per la modifica e per altri scopi (``OPTIONS``, ecc.):

    - **GET**: "Dammi le informazioni" (non modifica nulla).
    - **POST**: "Crea qualcosa di nuovo" (invia dati).
    - **PUT/PATCH**: "Aggiorna qualcosa che esiste già".
    - **DELETE**: "Cancella una risorsa".

REST è ideale per creare un'API pubblica per sviluppatori esterni o un servizio-web semplice. 
È lo **standard universale** e il più facile da testare.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
HATEOAS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

HATEOAS è l'acronimo di **Hypermedia as the Engine of Application State** ed è un componente dell'architettura 
e della progettazione delle API RESTful.

Utilizzando l'architettura HATEOAS, un client potrà accedere all'API di un'applicazione 
tramite una semplice chiamata URL RESTful. Qualsiasi ulteriore azione che il client desideri 
intraprendere sarà abilitata dai dati restituiti dal server nella chiamata originale. 

I "dati", all'interno della risposta, che consentono questo cambiamento di stato 
sono semplici collegamenti ipermediali. 
Ciò consentirà al client di passare da uno stato dell'applicazione al successivo semplicemente 
interagendo con i dettagli contenuti nelle risposte del server. 

++++++++++++++++++++++++++++++++++++++++++++
Dai servizi ai microservizi
++++++++++++++++++++++++++++++++++++++++++++

I sistemi software composti da microservizi rappresentano l'apice di un'evoluzione 
che ha visto i sistemi informatici 
trasformarsi da semplici programmi a complicate infrastrutture distribuite. 

Le principali tappe che hanno segnato questo cambiamento possono essere visualizzate e riassunte come 
riportato in `mshistory`_ .

.. image::  ./_static/img/microservices.jpg
    :align: left 
    :width: 100%  

Le motivazioni che spingono le aziende verso i microservizi sono molteplici e spesso legate alla 
necessità di gestire sistemi complessi e scalabili, migliorare la resilienza, accelerare l'innovazione, 
e supportare la trasformazione digitale. 

Il tema verrà approfondito nella sezione :ref:`microservizi`


**Oltre HTTP**

Considerati i limiti di HTTP, vi sono molte applicazioni in cui
è preferibile utilizzare strumenti di interazione più efficienti ed ottimizzati, come 
il protocollo :ref:`CoAP` le :ref:`WebSockets` o, più recentemente, :ref:`gRPC`.

.. _CoAP:

++++++++++++++++++++++++++++++++++++++++
CoAP
++++++++++++++++++++++++++++++++++++++++

Il protocollo *CoAP* (**Constrained Application Protocol**) è stato progettato specificamente per portare 
il paradigma RESTful (risorse, metodi, URI) in ambienti dove l'overhead di HTTP e TCP sarebbe insostenibile.

Mentre HTTP è il protocollo del **Web delle persone**, CoAP è il protocollo del **Web delle cose (IoT)**.

REST tradizionale usa HTTP su TCP. Questo comporta un "peso" notevole per dispositivi alimentati a batteria 
o con poca memoria. CoAP ottimizza questa struttura agendo su tre livelli:

#. **Dal Testo al Binario**

   HTTP è testuale (leggibile dagli umani), il che lo rende verboso. 
   CoAP è binario e utilizza un header fisso di soli 4 byte.

   - In CoAP: Un intero messaggio può stare in meno di 10-20 byte.

#. **Da TCP a UDP**

   TCP richiede un "handshake" (3 passaggi) per stabilire la connessione e gestisce la 
   ri-trasmissione in modo complesso. CoAP gira su UDP, che è "senza connessione".

   - CoAP implementa la propria affidabilità (:ref:`Messaggi Confirmable`) solo quando serve, 
     risparmiando energia e traffico di rete.

#. **Non solo Request/Response**

   In REST/HTTP, per un aggiornamento, occorre fare polling (chiedere continuamente). 
   CoAP introduce il **meccanismo Observe**:

   - Il client si "iscrive" a una risorsa e il server invia un aggiornamento solo quando il valore cambia. 
     È un ibrido tra REST e Publish/Subscribe.


.. _Messaggi Confirmable:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Messaggi Confirmable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

I messaggi Confirmable (**CON**) rappresentano il meccanismo principale per garantire in CoAP 
l'affidabilità della comunicazione sopra il protocollo di trasporto ``UDP``, che di per sé non è affidabile.

Un messaggio contrassegnato come Confirmable richiede una conferma esplicita dal destinatario.

- Acknowledge (ACK): Quando il server riceve un messaggio CON, deve rispondere con un pacchetto ACK.
- Message ID: Per collegare correttamente la conferma al messaggio originale, 
  l'ACK deve contenere lo stesso Message ID del messaggio CON inviato.
- Ritrasmissione: Se il mittente non riceve l'ACK entro un determinato intervallo (timeout), 
  il messaggio CON viene inviato nuovamente. Questo processo continua fino a quando non arriva 
  la conferma o viene raggiunto il numero massimo di tentativi.


Se il server CoAP può elaborare la richiesta immediatamente, include i dati della risposta direttamente nel pacchetto ACK
(**Piggybacked Response**).
Altrimenti,  invia prima un ACK vuoto (per fermare le ritrasmissioni del client) e, una volta pronti i dati, 
invia un nuovo messaggio CON verso il client, che a sua volta dovrà rispondere con un ACK (**Separate Response**).


.. Un progettista di API deve scegliere l'architettura client-server preferita in base ai requisiti di sistema.

.. _WebSockets:

+++++++++++++++++++++++++++++++++++++++++++++
WebSocket
+++++++++++++++++++++++++++++++++++++++++++++

Il protocollo *WebSocket* (**WS**) è nato nato per risolvere il limite della comunicazione unidirezionale di HTTP.

**WS** consente a due o più computer di comunicare tra loro in modo full-duplex 
su una singola **connessione TCP**. È uno strato molto sottile su TCP che trasforma un flusso di byte 
in un flusso di messaggi (testo o binario).

- Con REST, per sapere se ci sono novità, occorre chiedere continuamente (**Polling**). 
  In WebSockets, si apre la connessione una volta e il server emette i dati appena sono pronti.
  Ciò aumenta l'efficienza.

- Tuttavia, gestire migliaia di connessioni sempre aperte è costoso in termini di memoria del server. 
  REST è più efficiente per operazioni "mordi e fuggi" (es. leggere un articolo di un blog).
  Dunque, **WS** non è un sostituto totale di REST:

- **WS** ha come uso ideale: Chat, notifiche live, cruscotti finanziari, giochi online.




.. A differenza di HTTP, che è un protocollo a livello di applicazione, nel protocollo WebSocket non ci sono 
   abbastanza informazioni in un messaggio in arrivo affinché un framework o un container 
   sappia come instradarlo o elaborarlo.

.. Per questo motivo il WebSocket RFC definisce l'uso di sottoprotocolli. 
  Durante l'handshake, il client e il server possono utilizzare l'intestazione *Sec-WebSocket-Protocol* 
  per concordare un sottoprotocollo, ovvero un protocollo a livello di applicazione superiore 
  da utilizzare. 
  L'uso di un sottoprotocollo non è richiesto, ma anche se non utilizzato, le applicazioni dovranno comunque 
  scegliere un formato di messaggio che sia il client che il server possano comprendere.

Nella sua forma più semplice,

**un WebSocket è solo un canale di comunicazione tra due applicazioni**

e non deve essere necessariamente coinvolto un browser.
Tuttavia l'uso più comune di WebSocket è facilitare la comunicazione tra un un'applicazione server 
e un'applicazione basata su browser, avendo il vantaggio di realizzare comunicazioni asincrone bidirezionali 
e in tempo reale. 

Mentre in HTTP ogni singola richiesta porta con sé il "metodo" (``GET/POST``) 
e il "path" (``/xxx``), nel protocollo WebSocket, una volta stabilita la connessione, 
i messaggi sono solo **sequenze di byte o testo** senza alcun metadato di instradamento.


Sorge un problema:
una volta che aperta una **WS** verso un servizio, occorre sapere cosa inviare 
e cosa aspettarsi. Senza uno standard, l'unico modo è leggere il codice Java o qualche documentazione scritta a mano.

A questo scopo è stato introdotto :ref:`AsyncAPI`, di cui parliamo più avanti. 






.. _La fase di connessione nelle WS:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
La fase di connessione nelle WS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ogni WebSocket inizia la sua vita come una normale richiesta **HTTP GET**.

- Il client invia: `GET /xxx HTTP/1.1` con l'intestazione `Upgrade: websocket`.

Questo **instradamento della connessione** apre la via a diverse forme di :ref:`Instradamento del messaggio`,
in accodo a diverse tecniche che permettono a un 
**server WebSocket** di gestire molteplici funzionalità sulla stessa porta.

.. il concetto di Routing o di Dispatching.

.. _Instradamento del messaggio:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Instradamento del messaggio
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Volendo inviare ordini diversi (es. "fai questo", "fai quello") 
sulla **stessa** connessione WebSocket, il protocollo non aiuta perché non ci sono "header" nei messaggi.
Per risolvere questo "vuoto" di informazioni, i server e gli sviluppatori usano tre strategie:

- A. Il modello "**Un path, una funzione**"  

  È la soluzione più semplice. Creiamo connessioni diverse per scopi diversi.

  * Connessione A -> `/xxx1`
  * Connessione B -> `/xxx2`
  Il "routing" avviene solo all'inizio. È adeguato se le funzionalità sono logicamente separate.

- B. **Sotto-protocolli** (Sub-protocols)

  Il protocollo WebSocket permette di definire un "sotto-protocollo" (es. **STOMP** o **MQTT**). 
  Questi aggiungono un piccolo header a ogni messaggio che dice: "Questo messaggio è per la coda X". 
  Ciò complica il codice del client.
  .. Javalin può supportarli, ma complicano il codice del client.

- C. L'**Envelope Pattern** (Il "**Facade**" logico)

  Visto che il protocollo è "muto", avvolgiamo il messaggio in una 'busta' (*envelope*) che contiene 
  le istruzioni di routing. È lo standard nell'industria moderna.

  **Esempio di envelope JSON:**

  .. code::

    {
      "action": "xxx1",
      "data": "il mio input"
    }
  
  In questo caso, un server riceve il messaggio come stringa generica, 
  lo decodifica e usa uno `switch` nel codice Java per decidere cosa fare. 
  
  **Il routing non lo fa il protocollo, lo fai il codice applicativo.**

.. I WebSocket utilizzano le Socket nella loro implementazione basata su un protocollo standard che definisce 
   un handshake di connessione e un frame di messaggio.



.. _javalin server:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
javalin server
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Javalin è quello che in gergo viene definito un micro-framework per Java e Kotlin. 
Javalin è per Java quello che **Express.js** è per *Node.js* o **Flask** è per *Python*.

A differenza di `Spring Boot`_, che è un "ecosistema" vasto e spesso pesante, 
*Javalin* è progettato per essere estremamente leggero, semplice da imparare e 
privo di configurazioni (niente file XML o annotazioni ``@``).

Dalla **versione 6**, *Javalin* è diventato molto modulare, per cui è opportuno
usare la dipendenza **javalin-bundle**, che include tutto 
il necessario per far girare WebSockets e rendering di template.


.. Ho letto che il protocollo  WebSocket non ha abbastanza informazioni per instradare i messaggi. 
  Mi chiedo come faccia a farlo un wesocket server come javalin


.. Hai colto esattamente il punto critico che separa le **WebSocket** dal mondo **REST/HTTP**. 
  La tua osservazione è tecnicamente corretta: mentre in HTTP ogni singola richiesta porta con sé il "metodo" (GET/POST) 
  e il "path" (`/f`), nel protocollo WebSocket, una volta stabilita la connessione, 
  i messaggi sono solo **sequenze di byte o testo** senza alcun metadato di instradamento.

.. Allora, come fa Javalin (o qualsiasi altro server) a gestire la cosa? 
  Bisogna distinguere tra **instradamento della connessione** e **instradamento del messaggio**.


**Come opera javalin**

Javalin sfrutta il fatto che ogni WebSocket inizia la sua vita come una normale richiesta **HTTP GET**.

#. Il client invia: `GET /f1 HTTP/1.1` con l'intestazione `Upgrade: websocket`.
#. Javalin legge il path `/xxx1` come se fosse una normale pagina web.
#. In quel momento, Javalin "stacca" quella specifica connessione e la associa internamente 
   al blocco di codice che hai scritto per `/xxx1`.

Da questo punto tutti i messaggi che arrivano su quella connessione
verranno passati alla funzione `xxx11`. 
**Il protocollo non instrada i messaggi, il server ricorda a quale "binario" appartiene la connessione.**
  

**In sintesi**

Javalin "bara" usando le informazioni dell'HTTP iniziale per separare i flussi. 
Una volta che la connessione è aperta, il protocollo WebSocket è effettivamente un "tubo cieco":

- Volendo  **ordine e semplicità**, è opportuno usare path diversi (`/xxx1`, `/xxx2`).
- Volendo **un solo path**, occorre aggiungere  le informazioni di instradamento dentro 
  il messaggio (solitamente JSON) come detto in :ref:`Instradamento del messaggio`.

Javalin:

- è **Imperativo/Bloccante**: segue il modello "One Thread per Request". Quando arriva una richiesta, 
  viene assegnato un thread che rimane occupato finché la funzione 
  non ha finito. È facile da leggere e da debuggare perché il codice segue un flusso lineare.
- è un Framework Web: È progettato quasi esclusivamente per fare HTTP e WebSocket. 
  È un "guscio" attorno al :ref:`Server Jetty`.
- è ideale per trasformare una funzione semplice in un servizio accessibile

.. _Server Jetty:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Jetty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

`Jetty`_ è un server web e un container di servlet Java, leggero, gratuito e open source, 
gestito dalla Eclipse Foundation

A differenza di server più "monolitici" come Apache Tomcat, Jetty è nato per essere incorporato direttamente 
nel codice di un'applicazione.

 È ottimizzato per gestire un numero elevatissimo di connessioni simultanee con un basso consumo di memoria, 
 rendendolo ideale per applicazioni ad alta concorrenza.




.. _Server Vert.x:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Vert.x
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un server javalin non è ideale se un sistema 

- deve gestire decine di migliaia di connessioni WebSocket aperte contemporaneamente 
  (es. una chat massiva o un sistema di notifiche push)
- ha bisogno di resilienza: se un componente fallisce, gli altri devono continuare a girare isolati
- vuole usare più linguaggi di programmazione

Una alternativa è impostare il server usando `Vert.x`_:

- è **Reattivo/Non-bloccante**: i basa sul modello Event Loop (simile a Node.js). 
  Un solo thread (o pochissimi) gestisce migliaia di connessioni contemporaneamente. 
  Se la funzione richiesta deve attendere un dato, il thread non si blocca, ma passa subito a servire un'altra richiesta.
- è un **Toolkit per sistemi distribuiti**: Non serve solo per il Web. Può essere usarlo per gestire protocolli 
  TCP, UDP, DNS, database, o persino per far comunicare diversi parti di software tramite un **Event Bus** interno.
- non è solo un server, ma un insieme di **Verticles** (piccoli componenti isolati) che si scambiano messaggi.


.. _OpenAPI Specification:

+++++++++++++++++++++++++++++++++++++++++++++++++++++
OpenAPI Specification
+++++++++++++++++++++++++++++++++++++++++++++++++++++

`OpenAPI`_ (precedentemente noto come **Swagger**) è oggi lo standard de facto per descrivere 
API HTTP/REST.

Un *documento OpenAPI* rappresenta una descrizione formale di un'API, 
(endpoint, metodi (GET, POST, …), parametri, tipi di dato, schemi di richiesta/risposta, 
sicurezza, metadati, ecc) che può essere utilizzata da diversi 
strumenti per generare codice, documentazione, test case e altro ancora.
Il documento:

- può essere serializzato in JSON o YAML ed essere letto da tool che **generano**
  *client*, *server-stub*, *documentazione interattiva*, *test automatici*, ecc.  
- **REST API** 
  rappresenta il contratto formale che definisce **cosa offre il servizio**, senza esporre l'implementazione. 
  Questo facilita interoperabilità, evoluzione indipendente dei servizi.  
- non è un formalismo “semantico” come quelli della teoria del calcolo. 
  Serve a descrivere *API*, **non** a definire *comportamenti dinamici, proprietà concorrenti, tipologie di stato, 
  invarianti, transazioni, sincronizzazione*

Una specifica come la **OAS** (:ref:`OpenAPI Specification`) può servire come **contratto di superficie** 
(quello che un sistema-servizio “dichiara di offrire”, come **endpoint** e - nelle versioni più recenti - 
anche **eventi**, **webhooks**), 
ma **non** come modello completo per la dinamica del servizio.

.. note::

   webhooks sono una funzionalità introdotta nativamente con la versione 3.1,
   per descrivere comunicazioni "out-of-band" o asincrone iniziate dal server.

   A differenza delle API tradizionali (**PULL**), dove il client interroga il server, 
   i *webhooks* seguono un modello **PUSH**: il server invia proattivamente dati al client 
   quando si verifica un evento specifico.


Il livello descrittivo **OAS** rimane un'astrazione relativamente semplice, 
vicina al modello 'REST + callback HTTP'.

Poichè **non tutti i sistemi software sono servizi**,
per sistemi complessi, distribuiti, dinamici, event-driven — la documentazione API non basta: 
serve un formalismo di **comportamento e coordinazione**, non soltanto di interfaccia.

.. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
AsyncAPI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mentre per un'API HTTP è il Client a decidere quando chiamare il sistema, 
con gli *eventi* è il sistema che decide quando informare il mondo esterno.
Per le forme di interazione ad eventi uno standard usato è **AsyncAPI**
che (in un file *asyncapi.yaml*) elenca i **Channels** e le operazioni di *Publish* (quello che il sistema emette) 
e *Subscribe* (quello che il sistema riceve). 

*AsyncAPI* non è una tecnologia di comunicazione, ma uno standard di documentazione. 
È nato per affiancare OpenAPI per coprire ciò che OpenAPI non poteva fare: il mondo asincrono.
Permette di documentare cosa succede quando un servizio lancia un messaggio (es. su ``RabbitMQ`` o ``Kafka``) 
per avvisare tutti gli altri di un allarme o di un fatto applicativo.

- *OpenAPI*: Descrive una conversazione *Domanda -> Risposta immediata* (**Sincrona**) con possibile 
   semplici notifiche con webhooks
- *AsyncAPI*: Descrive un *flusso di messaggi* dove chiunque può inviare qualcosa in qualsiasi momento (**Asincrona**). 
  È perfetto per le WebSocket perché gestisce sia chi "Invia" (*Publish*) sia chi "Ascolta" (*Subscribe*).

*AsyncAPI* ricalca la struttura di OpenAPI ma la adatta ai sistemi di messaggistica asincrona
e permette di definire il "contratto" di un'interfaccia :ref:`WebSockets` in modo 
che sia leggibile dalle macchine.

*AsyncAPI* usa un file (``YAML`` o ``JSON``) per descrivere formalmente:

- **Servers**: L'indirizzo del server (es. ``ws://localhost:8080``).
- **Channels** (I percorsi): Specifica che esiste un canale ``/xxx``.
- **Messages** (Il contenuto): Descrive la forma dei dati.

.. code::

    asyncapi: 2.6.0
    info:
      title: Sistema S API
      version: 1.0.0
    channels:
      /f1:
        subscribe: # Messaggi che il CLIENT riceve dal server
          message:
            payload:
              type: string
              description: "Il risultato dell'elaborazione di f1"
        publish: # Messaggi che il CLIENT può inviare al server
          message:
            payload:
              type: object
              properties:
                inputString:
                  type: string  
 
A partire da questo documento, è possibile:

- **Documentazione Automatica**: Esistono tool che leggono il file AsyncAPI e generano una pagina web 
  (simile a Swagger UI) dove chiunque può vedere come interagire con il  sistema .
- **Generazione del Codice**: Dal file è possibile generare automaticamente le classi Java o i client JavaScript. 
  Invece di scrivere manualmente frasi del tipo ``socket.send(...)``, le funzioni generate impediscono di 
  commettere errori.
- **Validazione**: Si può inserire nel server un "validatore" che controlla se i messaggi in arrivo 
  rispettano il contratto. Se un client invia un numero invece di una stringa, il sistema lo rifiuta automaticamente.

Ad esempio, una volta scritto il contratto in `AsyncAPI Studio`_ (editor visuale online), si potrebbe usare:

- `Modelina`_ per generare le classi Java dei messaggi.
- `AsyncAPI Generator`_ per creare lo scheletro del client che i tuoi colleghi useranno.
- `Microcks`_ per simulare il server mentre si scrive la logica reale in Javalin o Vert.x.



.. Se ti connetti al canale /chat, puoi inviare o ricevere messaggi con questo schema.

 
.. se la tua app deve reagire istantaneamente a eventi esterni senza che l'utente debba ricaricare la pagina


.. _gRPC:

+++++++++++++++++++++++++++++++++++++++++++++
gRPC
+++++++++++++++++++++++++++++++++++++++++++++

**gRPC** sta per `gRPC Remote Procedure Call`_.

.. note::

  la **"g"** non ha un significato fisso. Sebbene il framework sia stato creato originariamente da Google, 
  il significato della lettera cambia per ogni versione rilasciata. 
  Ad esempio, nella versione 1.1 significava "gentle", nella 1.10 "glowing", e così via.


gRPC è un'architettura e un sistema API open source governati dalla *Cloud Native Computing Foundation*. 
È è un'implementazione specifica basata sul modello **RPC** (*Remote Procedure Call*).  

Mentre in *REST* un client richiede o aggiorna i dati sul sistema-servizio,
in *gRPC*, il client chiama o invoca funzioni specifiche del server, visto come un altro componente software. 

gRPC è stato progettato da Google specificamente per essere più efficiente di REST nella comunicazione 
tra :ref:`microservizi<Microservices>`.

- gRPC è progettato per far sì che un client possa invocare un metodo su un server remoto 
  come se fosse una chiamata a una funzione locale, scoendo un 'contratto' definito nel file ``.proto``.
- un server gRPC è solitamente stateless 
- REST usa JSON (testuale, pesante da leggere per le macchine).
  gRPC usa *Protocol Buffers* (binario, molto più piccolo e veloce da processare).
- gRPC usa **HTTP/2**, che permette di inviare più richieste contemporaneamente 
  sulla stessa connessione (multiplexing).
- gRPC non è un sostituto totale di REST: È **difficile da usare direttamente dal browser** (richiede dei proxy). 
  Inoltre, essendo binario, non puoi "leggere" i messaggi semplicemente guardando 
  il traffico di rete senza strumenti appositi.
- in architetture a m :ref:`microservizi<Microservices>`icroservizi, se due servizi risiedono nello stesso processo, 
  la specifica può indicare un trasporto locale **In-Process**. Questo elimina l'overhead della rete e 
  della serializzazione, pur mantenendo l'interfaccia definita nel file di configurazione (``.proto``).
- gRPC ha come uso ideale: Comunicazione interna tra :ref:`microservizi<Microservices>` (**Backend-to-Backend**).

gRPC è estremamente efficiente per lo sviluppatore perché genera automaticamente il codice per il client 
e per il server. Non occorre scrivere a mano  chiamate o gestire gli errori di parsing JSON: 
il codice generato si comporta come se si stesse chiamando una funzione locale sul client.



+++++++++++++++++++++++++++++++++++++++++++++++
gRPC vs. OAS
+++++++++++++++++++++++++++++++++++++++++++++++

Il rapporto tra gRPC e OAS è un tema centrale nell'architettura moderna, poiché rappresenta l'incontro tra due mondi: 
quello della comunicazione binaria ad alte prestazioni e quello della documentazione testuale standardizzata.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Code-First" vs "Contract-First
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. Il rapporto tra gRPC rappresenta l'incontro tra due mondi: 
  quello della comunicazione binaria ad alte prestazioni e quello della documentazione testuale standardizzata.

 

- **OAS (REST)**: Nasce per descrivere interfacce HTTP esistenti o per progettarne di nuove basate su verbi (GET, POST) 
  e risorse. È molto flessibile e orientato all'essere umano. 
  Molte implementazioni REST fatte con Spring Boot o ASP.NET Web API partono (**Code-First**)
  da una classe in C# o Java, in cui si aggiungono dei metadati (es. @Annotation);
  un software scansiona il codice per produrre un file descrittivo (come *swagger.json*).

- **gRPC (Protobuf)**: Il contratto ``.proto`` non è solo una documentazione, ma è il codice stesso. 
  Dal file *.proto* si generano le classi e le funzioni da usere nel software. 
  È un approccio "Schema-First" o  **Contract-First** ((Il contratto prima di tutto)) per definizione.


In generale si può dire che:

- il rapporto OAS/gRPC evideniza un punto fondamentale dell'ingegneria del software: 
  la distinzione tra interfaccia di superficie (contratto 'passivo' su cosa si può chiamare - endpoint, verbi, parametri) e 
  contratto funzionale (contratto "Vincolante": Tipizzazione Forte, Gestione degli errori, ...).
- gRPC sposta il contratto dalla documentazione alla compilazione e 
  il contratto include aspetti inerenti alla **logica della comunicazione**
  Client e Server usano lo stesso identico codice generato dal file ``.proto``. 
  Se il contratto cambia, entrambi devono essere ricompilati. 
  È impossibile avere un client che "pensa" che l'API sia fatta in un modo mentre il server la implementa in un altro.
  Dunque gRPC fa meglio se l'obiettivo è la correttezza del sistema: evita ambiguità, elimina gli errori di parsing 
  e garantisce che la dinamica tra i servizi sia coerente.
- OAS fa meglio se l'obiettivo è l'accessibilità: chiunque, con un semplice browser o un comando **curl**, 
  deve poter interagire con la superficie del servizio senza dover scaricare compilatori o file di schema.
  OAS rimane superiore anche per la scoperta (**Discoverability**) dei servizi

Nelle architetture a :ref:`microservizi<Microservices>`, ``gRPC`` e ``OAS`` convivono spesso secondo questo schema:

- **Front-End - Back-End** (``OAS/REST``): Per la comunicazione verso il mondo esterno (browser, app mobile, partner esterni), 
  si usa OAS. È universale, facile da testare con un browser e attraversa facilmente i firewall.

- **Back-End - Back-End** (``gRPC``): Per la comunicazione interna tra i microservizi, si usa gRPC. 
  È molto più veloce, riduce il carico della CPU e garantisce che se un servizio cambia il suo "contratto" 
  (il file ``.proto``), gli altri se ne accorgano in fase di compilazione.

 
La comunità ha creato strumenti per trasformare l'uno nell'altro. Il più famoso è il **gRPC-Gateway**.
Si tratta di un plugin che i file .proto e genera automaticamente:

- Un server Reverse Proxy che accetta chiamate REST/JSON e le traduce in gRPC.
- Un file OpenAPI che documenta quegli stessi endpoint.

In questo modo, si può scrivere il  servizio  in gRPC e fornire agli utenti 
una documentazione OAS standard per usare il servvio via HTTP.


.. Qualunque sia la forma di comunicazione, ancora una volta è una questione 
   di **livelli descrittivi**: prima dei dettagli tecnologici che realizzano
   la comunicazione (reti, protocolli, DNS, etc.) può essere conveniente/opportuno focalizzare l'attenzione
   sulla **logica della comunicazione<**, utilizzando un linguaggio apposito 
   per 'parlare' a questo livello di astrazione.

.. Prima di addentrarci in questa specifica problematica, può essere utile
   richiamare alcuni aspetti essenziali relativi agli attuali ``LdP``.

-------------------------------------
Sistemi visti dall'interno 
-------------------------------------

Guardare un sistema software 'dal di dentro' significa poter capire meglio come è fatto e quali altre proprietà
abbia, oltre a quelle esposte nelle API.

Ovviamente l'interno di un sistema software è costituito da  un insieme di *istruzioni* (codice) scritte in qualche 
linguaggio di programmazione e non è raro che, per molti sistemi, la lettura del codice risulti intricata
e :ref:`complicata<Sistemi complicati>` da capire.

Ma se un sistema software è 'fatto bene' il codice rivela subito una precisa **architettura** che ne rende 
la comprensione più semplice.

.. _Dimensioni:

+++++++++++++++++++++++++++++++++++++
Dimensioni
+++++++++++++++++++++++++++++++++++++

La descrizione di un sistema software 'dall'interno' può avvenire 
focalizzando l'attenzione su almeno tre diversi punti di vista:


.. list-table::
  :widths: 50,50
  :width: 100%
  
  * - .. image:: ./_static/img/Architectures/Dimensioni.PNG
         :width: 100%
         :align: center
    -  
       - l'organizzazione del sistema in parti (**struttura**);
       - il modo in cui le diverse parti scambiano informazione implicita o esplicita tra loro (**interazione**);
       - il funzionamento del tutto e di ogni singola parte (**comportamento**).

+++++++++++++++++++++++++++++++++++++++++++++
Design patterns
+++++++++++++++++++++++++++++++++++++++++++++

I Design Pattern sono l'equivalente dei "modelli predefiniti" o delle "best practice" 
consolidate nel mondo dell'ingegneria del software. Invece di reinventare ogni volta la ruota 
per risolvere un problema ricorrente, si utilizza una **soluzione architetturale** che è già stata testata, 
analizzata e raffinata da migliaia di sviluppatori.

Un pattern non è codice da copiare e incollare. 
È piuttosto un **progetto concettuale** che descrive come risolvere un problema in una 
determinata situazione.

Se l'architettura è la "strategia" (come dividiamo il sistema in grandi blocchi?), 
i design pattern sono la "tattica" (come facciamo comunicare questi blocchi in modo opportuno?).

I pattern vengono solitamente divisi in famiglie principali.
Ricordiamo qui le tre categorie classiche, la cui conoscenza diamo per scontata.


.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - Agli anni 90 del secolo scorso risale l'idea di `pattern`, culminata nella pubblicazione 
      nel ``1995`` dell'ormai famoso testo sui `Design Pattern`_  della così detta *Gang-of-Four*
      (**GoF**): *Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides*).

    - .. image:: ./_static/img/DesignPatternGof.PNG
         :width: 100%
         :align: center

Un errore comune è cercare di "forzare" i pattern ovunque. 
Questo porta alla cosiddetta **Over-engineering**: il codice diventa inutilmente complicato. 
Un bravo architetto software usa i pattern solo quando la semplicità non è più sufficiente.

Dopo la introduzione dei pattern **GoF**, si sono susseguiti molte altre
proposte sui design pattern. 
I riferimenti più noti sono i cinque testi ``POSA`` 
sulle *Pattern oriented Software Architectures*
e i convegni ``PLoP`` (*Pattern Languages of Programming*).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Pattern POSA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Si riportano qui i pattern POSA (*Pattern oriented Software Architectures*) principali, 
che intendono introdurre strutture nei
sistemi software, per superare il così detto :ref:`Big Ball of Mud`.

.. list-table::
  :widths: 2,98
  :width: 100%
  
  * -  
    - .. image:: ./_static/img/Posa.PNG
         :width: 100%
         :align: center

Anche se non approfondiremo in modo sistematico questi pattern, ritroveremo 
molte delle problematiche che motivano i vari pattern nei casi di studio 
di sistemi distributi che affronteremo, poenendo particolare attenzione 
sui :ref:`Sistemi a Microservizi`.

+++++++++++++++++++++++++++++++++++++++++++++
Architettura di un sistema
+++++++++++++++++++++++++++++++++++++++++++++

Definire l'architettura software è sempre stato complicato perché il termine oscilla tra la struttura 
tecnica e il processo decisionale. Oggi, la comunità scientifica e professionale converge 
principalmente su due definizioni che si completano a vicenda.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Definizione Strutturale 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Lo Standard ISO/IEC/IEEE 42010 recita:

- L'architettura software è l'organizzazione fondamentale di un sistema, definita dai suoi componenti, 
  dalle relazioni tra di essi e con l'ambiente, e dai principi che ne guidano il progetto e l'evoluzione.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Definizione Pragmatica 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   

Nel mondo dello sviluppo Agile e dei Microservizi, si sposta l'attenzione dal "disegno" alle scelte strategiche:

- L'architettura è l'insieme delle decisioni significative su come è costruito un sistema software; 
  sono le decisioni **difficili da cambiare** in un secondo momento

Ad esempio: usare un database relazionale o NoSQL è una scelta architettonica (difficile da invertire).
 
Un'altra frase celebre nel settore dice:

- L'architettura è ciò che resta del sistema quando si rimuovono tutti i dettagli implementativi. 

Ovvero, è lo **scheletro concettuale** che permette di ragionare sul comportamento del software.

**Evoluzione delle architetture**

L'evoluzione delle architetture software è una storia di *astrazione crescente* e di *decentramento*. 
Ogni fase è nata per risolvere un limite della precedente, passando da blocchi di codice indivisibili 
a ecosistemi di funzioni atomiche che "vivono" nel cloud.

Un sintetico quadro di questa evoiluzione può essere tracciato come segue:

#. Il **Monolite (Anni '60 - '80)**

   Tutto il software risiede in un unico blocco logico. 
   Interfaccia utente, logica di business e accesso ai dati sono strettamente intrecciati.
   Il software gira su un unico server (Mainframe)

#. **Client-Server (Anni '90)**

   Con l'arrivo dei PC e delle reti locali, l'architettura si spacca in due (**2-Tier**).
   Il Client (PC dell'utente) contiene l'interfaccia e la logica, mentre il Server gestisce solo il Database.

#. **Architettura N-Tier / Layered (Anni 2000)**

   L'esplosione del Web induce a dividere il monolite in "strati" (**layer**) logici.
   Si aggiunge uno strato intermedio (**3-Tier**): 
   
   ``Presentation (Browser) → Logic (Server Applicativo) → Data (Database)``

   Questo modello ha dominato l'era di Java EE e .NET, portando alla definizione di pattern come 
   il *Model-View-Controller* (**MVC**).
#. **SOA - Service Oriented Architecture (Metà anni 2000)**

   Il sistema è un insieme di "servizi" che comunicano tramite un bus centrale (**ESB** - *Enterprise Service Bus*)
   I servizi sono grandi e pesanti, spesso legati a protocolli complicati come SOAP e XML.
#. **Microservizi e Cloud-Native (2010 - Oggi)**

   Il sistema è diviso in decine o centinaia di servizi minuscoli e autonomi.
   Ogni servizio ha il suo DB, viene "impacchettato" in **Docker** e orchestrato da **Kubernetes**. 
   La comunicazione è leggera (REST, gRPC, WebSocket).
#. **Serverless ed Event-Driven (Il Presente)**

  L'architettura non è più fatta di server sempre accesi, ma di singole funzioni che si attivano solo in risposta a un evento
  (**FaaS** *Function as a Service*) gestito da un *Cloud Provider*.

.. il concetto di "contratto" (tipo AsyncAPI o OpenAPI) è diventato il vero collante che tiene insieme 
   queste architetture moderne.

.. _Big Ball of Mud:

+++++++++++++++++++++++++++++++++++++++++++++
Big Ball of Mud
+++++++++++++++++++++++++++++++++++++++++++++

Il concetto di **Big Ball of Mud** (*Grande Palla di Fango*) è stato evocatoo per la prima volta 
in un saggio di *Brian Foote* e *Joseph Yoder* nel 1997. 
Tuttavia, come problema sistematico, si è manifestato in momenti diversi dell'evoluzione architettonica, 
diventando particolarmente critico durante la transizione tra gli anni '80 e '90.

Nel 1997, quando Foote e Yoder pubblicarono il loro saggio,
nonostante i nuovi Design Pattern, la maggior parte del software reale non era affatto "pulito".

La fretta, i requisiti che cambiano continuamente e il turnover degli sviluppatori portavano 
naturalmente il codice verso la "Palla di Fango", cioè 
verso uno stato di entropia massima del software: un sistema che cresce senza un'architettura definita, 
dove ogni parte dipende da ogni altro parte.

Nella storia del software, il "Big Ball of Mud" si manifesta ogni volta che la velocità 
di sviluppo prevale sulla disciplina architettonica.
È la "**default architecture**": senza uno sforzo cosciente per applicare principi organizzivi
(come i :ref:`Principi SOLID` o 
le :ref:`Clean Architectures`, il sistema, inevitabilmente, si presenta internamente  una palla di fango.

**L'architettura è costosa, ma la mancanza di architettura costa molto di più.**


.. _Principi SOLID:

+++++++++++++++++++++++++++++++++++++++++++++
Principi SOLID
+++++++++++++++++++++++++++++++++++++++++++++

I principi SOLID sono nati nel contesto della *Programmazione Orientata agli Oggetti* (OOP), 
ma oggi sono considerati principi universali di progettazione software, applicabili a livello di architettura, 
microservizi e persino organizzazione dei dati.


.. _Single responsibility:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SRP-Single responsibility
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

**Single responsibility principle**:  in OOP, una classe dovrebbe avere una, e una sola, ragione per cambiare.

- Concetto Universale: **Coesione**. Ogni componente del sistema deve fare (bene) una cosa sola.
- In Architettura: Un microservizio (o un modulo del Monolite Modulare) deve gestire una sola funzionalità 
  di business. Se il servizio "Ordini" gestisce anche la "Generazione PDF delle fatture" e il "Tracking GPS", 
  si sta violando l'SRP a livello macroscopico.


.. _Open-closed:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
OCP-Open/closed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

**Open-closed principle**:  in OOP, una classe dovrebbe essere aperta per l'estensione ma chiusa per la modifica.

- Concetto Universale: **Estensibilità**. Usare interfacce o "hook" per permettere l'evoluzione del sistema 
  senza toccare il codice sorgente originale.
- In Architettura: Un sistema deve permettere l'aggiunta di nuove funzionalità senza riscrivere il nucleo esistente. 
  Si pensa ai Plugin o alle Estensioni dei browser.

.. _Liskov substitution:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
LSP-Liskov substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


**Liskov's substitution principle**: in OOP, gli oggetti in un programma dovrebbero essere sostituibili 
con istanze dei loro sottotipi senza alterare la correttezza di quel programma.

- Concetto Universale: **Intercambiabilità**. Il rispetto del "contratto" garantisce che il sistema 
  non collassi sostituendo un componente.
- In Architettura: Questo è il principio cardine delle Interfacce API e dei Contratti (come AsyncAPI). 
  Se si sostituisce il servizio xxx1 versione A con la versione B, il client non deve accorgersi della differenza.

.. _Interface segregation:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ISP-Interface segregation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

**Interface segregation principle**: in OOP, molte interfacce specifiche del client sono migliori di un'interfaccia generica.

- Concetto Universale: **Minimo Privilegio Informativo**. Fornire solo ciò che serve per quel compito specifico 
  (molto rilevante nella sicurezza e nelle performance).
- In Architettura: Evitare i "Modelli Dati Giganti". Se un client ha bisogno solo dell'indirizzo di un utente, 
  non inviargli l'intero oggetto JSON con password, storico acquisti e preferenze.

.. _Dependency inversion:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DIP-Dependency inversion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

**Dependency inversion principle**: si dovrebbe dipendere dalle astrazioni, non dalle implementazioni.

- Concetto Universale: **Disaccoppiamento**. L'astrazione protegge la logica di business dalle tecnologie volatili.
- In Architettura: È il fondamento della :ref:`Architettura Port/Adapter`. 
  Il "cuore" logico della applicazione non deve dipendere dal database specifico (MySQL o MongoDB) 
  o dal protocollo (WebSocket o CoAP). Sono il database e il protocollo che devono "adattarsi" alle porte del sistema.

Se il codice sorgetne di un componente di alto livello dipende da quello di un componente di basso livello, 
i cambiamenti nei componenti di basso livello si diffonderanno al componente di alto livello. 
Pertanto, poniamo un confine tra i due, usando il polimorfismo per invertire il flusso logico.


.. _Clean Architectures:

++++++++++++++++++++++++++++++++++++++++
Clean Architecture
++++++++++++++++++++++++++++++++++++++++

E' un'architettura che segue i principi SOLID. 
L'idea chiave è quella di utilizzare il :ref:`principio di inversione delle dipendenze<Dependency inversion>` per tracciare 
confini tra componenti di alto livello e componenti di basso livello. 
Questo crea un'architettura "plug-in" che mantiene il sistema flessibile e manutenibile.


Vediamo un esempio, preso da :ref:Clean Architecture:


.. list-table::
  :widths: 50,50
  :width: 100%

  * - Le regole aziendali dipendono dall'interfaccia anziché dalla classe di database concreta.

      Il database diventa un plug-in delle regole aziendali: un componente di basso livello 
      che può essere modificato senza influenzare le regole aziendali (componente di alto livello).


    - .
    
      .. image:: ./_static/img/EsempioInversioneDip.PNG
          :align: center
          :width: 100%
 

.. _Architettura Port/Adapter:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Architettura Port/Adapter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

L'architettura **esagonale** (anche nota come *Port-Adapter*) è, tra le tante Architetture di sistemi software 
oggi in uso, quella cui noi faremo particolare attenzione.


.. list-table::
  :widths: 50,50
  :width: 100%

  * - Si identificano quattro layer principali

      - Entities: oggetti che contengono la logica aziendale critica.
      - Use-cases: regole aziendali specifiche dell'applicazione
      - Interface adapters: gateway, presentatori e controller. 
        Ad esempio, questo livello contiene l'architettura MVC della GUI e anche oggetti che trasformano 
        i dati tra il formato del database e i casi d'uso.
      - Frameworks and drivers: framework web, database, la vista di MVC
    - .
    
      .. image:: ./_static/img/portAdapterArch.PNG
          :align: center
          :width: 100%


.. _Bounded Context:

+++++++++++++++++++++++++++++++++++++++++++++
Bounded Context e Clean Architecture
+++++++++++++++++++++++++++++++++++++++++++++

#. Bounded Context: Il confine "Politico/Linguistico"

  Immagina il tuo sistema S. Se cresce, potresti avere una parte che si occupa di Vendite e una di Spedizioni. 
  Nel Bounded Context "Vendite", la parola Prodotto significa "prezzo e descrizione". 
  Nel Bounded Context "Spedizioni", Prodotto significa "peso e dimensioni".

  Il Bounded Context impedisce che i due concetti si confondano.

  Divide il sistema in moduli indipendenti (la base per i Microservizi o i Monoliti Modulari).

#. Clean Architecture: Il confine "Tecnico"

  Una volta stabilito che siamo dentro il contesto "Vendite", come organizziamo il codice? Qui entra in gioco la Clean Architecture (o Architettura Esagonale).

  Mette la Business Logic (le tue funzioni f1 e f2) al centro.

  Mette il Database, le WebSocket (Javalin/Vert.x) e le interfacce esterne in periferia.

  La regola d'oro è: il centro non sa nulla della periferia.

In sintesi:

- Il Bounded Context (dal Domain-Driven Design) definisce i confini orizzontali (tra diverse aree di business).

- La Clean Architecture definisce i confini verticali (all'interno di ogni singola area, tra logica e tecnologia).


Un microservizio ben progettato è:

Un'unità di deploy che racchiude un singolo Bounded Context, organizzata internamente secondo la Clean Architecture.

============================================
Costruire sistemi software
============================================

Processo di produzione SCRUM


------------------------------------
Installare su PC
------------------------------------

#. Installare `Java JDK 17` *Windows->Preferences->Java->InstalledJRE*
#. Installare `GIT` e un Git repository `PERSONALE PRIVATO` e **dare accesso al docente**
#. Installare `Gradle`  (8.4, 8.6)  
   (per accedere a *System Properties Advanced* su Windows: ``sysdm.cpl``)
#. Installare  `Eclipse IDE`: `Eclipse IDE for Java and DSL Developers`_ (2024 12)  
#. Installare `Docker` e provarne l'uso

In un secondo momento:

#. Installare `Python (3.9.13)` (usando Anaconda)
#. Installare `IntelliJ`
#. Installare `Node.js` 
 
------------------------------------
Il ruolo di Gradle
------------------------------------

La costruzione di un sistema software non può oggi prescindere dall'uso di un **IDE** e di 
strumenti di come `Gradle`_, uno strumento open source per automatizzare la costruzione (build) 
del software.

Gradle è ormai uno standard di fatto in questo settore ed è interessante non solo in quanto
strumento, ma anche perchè applica i principi del `Domain Driven Design`_ (**DDD**) 
per modellare il suo proprio  domain-building software.

Ne consegue che non poco tempo deve essere dedicato allo studio di questi tools e 
alla preparazione del file ``build.gradle`` che governa lo sviluppo e il deployment
del sistema software.

Le rete offfre numerosi tutorial su Gradle, come ad esempio:
https://tomgregory.com/gradle/gradle-tutorial-for-complete-beginners/
(anche in `gradle-tutorial`_ e in :ref:`GradleIntro25`)

.. note::

  Per usare Eclipse insieme a Gradle, potrebbe essere necessario eseguire i seguenti passi 
  (Grazie a *Stefano Arasi*):

  #. Help->Eclipse MarketPlace
  #. Search "Gradle"
  #. Go to "BuildShop Gradle Integration 3.0" (the elephant) which is indicated as installed and 
    clic on the grayed installed button.
  #. Either click on update or uninstall and reinstall it, this will restart eclipse.


------------------------------------
Processi agili e incrementali
------------------------------------

Oggi si ritiene che un approccio `INCREMENTALE` sia  indispensabile per aggredire la complessità del problema e per
mettere in luce in primis gli aspetti
PIU' IMPORTANTI e PIU' CRITICHE senza perdersi in dettagli che possono distogliere
l'attenzione per formare un quadro generale di riferimento.

L'approccio `AGILE` descritto in `SCRUM Guide`_ è oggi un punto di riferimento.

.. image:: ./_static/img/AgileDevelop.PNG
   :align: center
   :width: 90%
  

I vari SPRINT dovrebbero effettuare uno ZOOMING entro MACRO-COMPONENTI
innescando un processo ITERATIVO di analisi, progetto , sviluppo e testing di
quel componente o del SOTTOSISTEMA  che lo SPRINT vuole costruire.

------------------------------------------------
Il testing
------------------------------------------------

L'obiettivo della fase di testing è quello di trovare il maggior numero di situazioni che conducono ad errori 
con il minimo numero di casi di prova. 

La fase di testing del software è  attività imprescindibile per garantirne la qualità ed è anche 
indispensabile per garantire all'utente una *user experience* soddisfacente. 

In `Software testing IBM`_  leggiamo che:

- Negli anni '90 c'è stata una transizione dai test a un processo più completo denominato 
  `controllo di qualità`, che copre l'intero ciclo di sviluppo del software e riguarda 
  i processi di pianificazione, progettazione, creazione ed esecuzione di casi di test. 
- I test del software sono stati tradizionalmente separati dal resto dello sviluppo, ma
  molti team di sviluppo  usano ora una metodologia nota come `test continuo`. 

  Un  *piano di testing* (**TestPlan**)  ha di solito lo scopo di stabilire la gerarchia con cui i test vanno eseguiti, 
i metodi di esecuzione, i criteri di accettazione e prevede diverse tipologie di test, tra cui:


- **Unit test** (Test di unità o di modulo)
  Ha l'obiettivo di individuare gli errori nel singolo modulo software. 
 
- **Integration Test** (Test di integrazione)
  Ha l'obiettivo di individuare gli errori nel software quando tutti i moduli che compongono un sottosistema 
  o l'intero sistema vengono fatti lavorare assieme. 

- **System Test** (Test di sistema)
  Ha l'obiettivo di garantire che il prodotto software nel suo complesso soddisfi completamente 
  i requisiti iniziali. E' un collaudo interno. 

- **Functional Test** (Test legato ai requisit)
  verifica che il sistema implementi correttamente le funzionalità specificate, producendo gli output attesi 
  a fronte di input noti, indipendentemente da come il sistema è implementato internamente.
  In altre parole, verifica **cosa fa** il sistema, **non come** lo fa.

- **User Acceptance Test** (Test di accettazione)
  Ha l'obiettivo di valutare la rispondenza dell'applicazione software rispetto ai requisiti 
  espressi inizialmente nel contratto e di ottenere l'accettazione formale del cliente di quanto realizzato. 
  Il test viene effettuato dal cliente nel suo ambiente di test, e da un gruppo di utenti. 

- **Alpha test e Beta test**
  Un `alpha test` è un test preliminare di un'applicazione software anche non ancora completa, 
  eseguito da alcuni potenziali utenti rappresentati da un team. 

  Un `beta test` ha l'obiettivo di far valutare al cliente, prima della distribuzione ufficiale del sistema, 
  la reale funzionalità, completezza ed operatività dell'applicazione. 
  
- **Regression Test** (test di non regressione)
  Ha l'obiettivo di verificare a valle di una manutenzione, dopo che un bug è stato individuato e corretto 
  e sono stati eseguiti esattamente gli stessi test che erano stati effettuati quando era stato individuato il problema.

- **Stress test** (test di carico)
  Ha l'obiettivo di determinare il punto di rottura di un sistema software, 
  oltre il quale si verificano instabilità del sistema, perdita dei dati o interruzione del servizio.


Sul problema del testing si trova moltissimo materiale in rete. Riportiamo qui alcuni riferimenti utili sul 'piano pragmatico':

- `Software testing`_ (wikipedia)
- `Automated-Testing-Plan FAQ`_

++++++++++++++++++++++++++++++++
Dal testing a DevOps
++++++++++++++++++++++++++++++++

Il *test continuo* è parte dell'approccio `DevOps`_, in cui sviluppo e operazioni collaborano 
per l'intero ciclo di vita del prodotto. L'obiettivo è quello di accelerare la fornitura del software, 
bilanciando al tempo stesso i costi, la qualità e i rischi.   

.. Noi porremo particolare attenzione al fatto che la definizione di test (autmatizzabili) può essere vista come
  la **formalizzazione** delle `User Stories`_  e che l'uso dei modelli (esguibili) può permettere 
  di anticipare questa formalizzazione fin dalle fasi di analisi.

.. Nella fase di analisi, l'obiettivo non è quello di eseguire dei test, ma quello di trovare il modo migliore 
  per definire i test in modo che possano individuare in modo automatico le falle del software rispetto ai requisiti.

L'obiettivo di definire fin dalle fasi di analisi un  **TestPlan** con test automatizzabili 
di un sistema applicativo, introduce di fatto, per il progettisto del sistema, un **nuovo requisito**: 
`rendere  l'applicazione osservabile`, o meglio:

**rendere verificabili, da parte di una macchina, gli effetti di un sistema software**



------------------------------------
Il metodo di lavoro
------------------------------------

#. Partiamo dall'insieme di requisiti **forniti dal committente** ed espressi in linguaggio naturale 
#. Impostiamo lo ``SPRINT0`` come una **analisi dei requisiti** che mira a esprimerli in modo comprensibile anche alla macchina introducendo:

   - un modello (eseguibile) dell'architattura del sistema desunta dai requisiti 
   - un (primo) *TestPlan* di **Functional Tests**
   
#. Impostiamo una **analisi del problema** che mira a definire:
 
   - una architettura logica del sistema come risultato dall'analisi
   - un piano di lavoro
   - una possibile estensione ai piani di testing funzionali
   - la definizione del primo SPRINT relizzativo
 
#. Impostiamo ogni SPRINT come un **sottoprogetto** con sua propria spiegazione e testing. 

   - Lo SPRINT :math:`n+1` parte dai risultati dello sprint :math:`n` e costruisce un sottosistema (funzionante) 
     che sarà l'input dello SPRINT :math:`n+2`.
#. Facciamo seguire ad ogni SPRINT una fase di `Sprint review`_> i cui meeting saranno
 
   - **un nuovo modo di concepire le ore di ricevimento-studenti**
#. Per ogni  SPRINT, compiliamo un documento (si veda :ref:`La documentazione del lavoro`)  
   per **rendere esplcite** le conoscenze, 
   le decisioni, i modelli, etc. introdotti nello SPRINT, 
   fornendo indicazioni all'utente finale su come eseguire lo SPRINT. 

++++++++++++++++++++++++++++++++++++++
Il diario di bordo
++++++++++++++++++++++++++++++++++++++

Ogni porgetto da noi impostato, deve avere un `diario di bordo`, 
organizzato secondo un preciso `template`_. Questo diario deve essere compilato
**in itinere** 
con indicazioni **sintetiche ed essenziali**, man mano si svolge 
il processo di produzione e `non dopo` avere sviluppato il codice.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il template del diario
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- Introduction
- Requirements

     Copy here the EXACT text given by the customer.
- Requirement analysis
- Problem analysis
- Test plans
- Project
- Testing
- Deployment
- Maintenance
- About the team (massimo 3 worker)
   
   #. CognomeNomeMatricola del worker1
   #. ...



==============================================
Game of Life di Conway
==============================================

.. La disponibilità di un micro-framework che permette la definziione di componenti software sia proattivi che reattivi (message-driven)
.. ci indice a sperimentare la 

Affrontiamo la
costruzione di un sistema software ispirato al famoso automa cellulare di
**John Horton Conway**: il **Game of Life** (*GofLife*).

Il mondo di *GofLife* è una griglia infinita di celle quadrate. Ogni cella può trovarsi in soli due stati:
VIVA (accesa) o MORTA (spenta)2. 

GofLife è un "zero-player game": la sua evoluzione è determinata interamente dallo stato iniziale della griglia. 
Ad ogni "tick" di un clock (**generazione** o **Epoch**), si applicano quattro **regole** 
basate sui  vicini di ogni cella:

   - Una cella viva con meno di due celle vive adiacenti muore (per isolamento).
   - Una cella viva con due o tre celle vive adiacenti sopravvive alla generazione successiva.
   - Una cella viva con più di tre celle vive adiacenti muore (per sovrappopolazione).
   - Una cella morta con esattamente tre celle vive adiacenti diventa una cella viva (per riproduzione).

Nel caso di grigla infinita, ogni cella ha esattamente 8 vicini (orizzontali, verticali e diagonali).
Ovviamente, in una implementazione software, la griglia sarà finita e le celle potranno avere **3,5,o 8** vicini.

Nonostante le regole parlino solo di "celle e vicini", **osservando una vista del sistema** 
emergono strutture che sembrano avere una propria identità, come:

- Still Lifes: Forme statiche che non cambiano (come rocce).
- Oscillatori: Forme che mutano ciclicamente (come un battito cardiaco).
- Spaceships (Astronavi): Aggregati che "espellono" delle strutture che viaggiano all'infinito lontano dal centro della griglia. Il più famoso è il **Glider** (Aliante). 


E' importante sottolinare che le strutture *Still Lifes* **sembrano** rimanere immutabili.
Infatti esse sono **continuamente rigenerate** dal 'motore' del gico, sempre uguali a sè stesse.
Si veda: :ref:`Evoluzione di GofLife`.

.. Basterebbe però la nascita di nuove celle


---------------------------------------------
Il gioco in  JavaScript
---------------------------------------------

Collegandosi al sito https://playgameoflife.com/ si può sperimmetare il gioco. Riportiamo qui 
alcune configurazioni iniziali interessanti:


.. list-table:: 
    :widths: 20,20,20,20,20
    :width: 100%

    * - 
        oscilla 

        .. image:: ./_static/img/demobase.png
          :align: center
          :width: 100%   
      - 
        stabilizza 
             
        .. image:: ./_static/img/stabile.png
          :align: center
          :width: 100%   
      - 
        penatamini
             
        .. image:: ./_static/img/pentamini.png
          :align: center
          :width: 100%   
      -  
        glider

        .. image:: ./_static/img/glider.png
          :align: center
          :width: 100%   
      - 
        pentaminoR

        .. image:: ./_static/img/pentaminoR.png
          :align: center
          :width: 100%   


I 12 **pentamini** esistenti si stabilizzano nei tre modi citati: Still Lifes, Oscillatori e Astronavi (Glider).

Il **Pentamino-R** è importante perché ha dimostrato che non era possibile prevedere a occhio nudo 
se una forma sarebbe cresciuta all'infinito o meno. È il riflesso visivo del Problema della *Fermata di Turing*: 
non si può sapere se un programma si fermerà (si stabilizzerà) senza farlo girare.
Viene definito un *Matusalemme*, perché esplode in un caos ribollente che dura per 
ben ``1103`` generazioni prima di stabilizzarsi.
 
.. oscillatore.png
 


-----------------------------------------
Il gioco produce complessità
-----------------------------------------

Nonostante la semplità delle regole di base,
la previsione del comportamento a lungo termine del Gioco della Vita è un problema 
che ha affascinato matematici e informatici per decenni e, nonostante numerosi studi, 
non esiste ancora una soluzione definitiva e generale, per alcuni motivi:

- **Complessità esponenziale**: Il numero di possibili configurazioni di una griglia di celle aumenta in modo
  esponenziale con la dimensione della griglia stessa. Questo rende impraticabile un'analisi esaustiva 
  di tutte le possibili evoluzioni.
- **Comportamento caotico**: Piccole variazioni nella configurazione iniziale possono portare a risultati 
  completamente diversi nel lungo periodo, rendendo difficile stabilire delle leggi generali che governino 
  l'evoluzione del sistema.
- **Emergenza**: Dal semplice insieme di regole del gioco emergono comportamenti complessi e imprevedibili, 
  come la formazione di strutture stabili, oscillanti o in continua evoluzione.

Anche con una griglia finita, prevedere il comportamento a lungo termine di una configurazione iniziale 
rimane un :ref:`problema complesso<Sistemi complessi>`. 
Il numero di possibili configurazioni, anche se finito, può essere enorme, 
rendendo impraticabile un'analisi esaustiva.

Inoltre, a differenza di molti altri sistemi fisici, il Gioco della Vita **non è sempre reversibile**. 
Ciò significa che, data una configurazione finale, non è sempre possibile risalire univocamente alla configurazione iniziale 
che l'ha generata. Molte configurazioni finali possono avere più configurazioni iniziali che portano allo stesso risultato.

Dunque, determinare la configurazione iniziale che porta a una data configurazione finale nel 
Gioco della Vita 
è un :ref:`problema complesso<Sistemi complessi>` e, in generale, non esiste una soluzione 
algoritmica efficiente. 

Il gioco è un esempio di sviluppo e **auto-organizzazione**. È interessante per scienziati, matematici e economisti 
osservare il modo in cui schemi complessi possono emergere dall'implementazione di regole assai semplici.

++++++++++++++++++++++++++++++++++++++++++++++
Il gioco è Turing-completo
++++++++++++++++++++++++++++++++++++++++++++++

È stato dimostrato che nel *Game of Life* si possono costruire circuiti logici (porte ``AND, OR, NOT``) 
ed è quindi :ref:`Computazionalmente completo`.
Ciò significa che, con una griglia abbastanza grande e la giusta configurazione iniziale, 
si pottrebbe costruire un computer capace di eseguire qualsiasi algoritmo che un PC attuale può eseguire.

.. _Il problema della vista del gioco:

------------------------------------------------
Il problema della vista del gioco
------------------------------------------------

Se visualizziamo l'evoluzione dello stato delle celle con una sequenza di messaggi su una console,
come ad esempio:

.. code::

    cell x=0y=0:false
    cell x=0y=1:false
    cell x=0y=2:false
    ...

possiamo capire che :ref:`LifeController` sta girando, ma non avremo certo alcuna 
immediata percezione delle configurazioni 'interessanti'.

il "senso" delle configurazioni non risiede solo nei dati, ma anche nella struttura dello spazio 
in cui questi dati vengono proiettati. 
Se la proiezione non rispetta la geometria delle regole del gioco, 
l'emergenza (la nascita delle forme) svanisce per l'osservatore.

Per fare in modo che lo spazio della rappresentazione
sia "sintonizzato" sulla metrica delle leggi del gioco
occorre una matrice 2D.

La matrice non è solo un modo "comodo" per vedere il gioco; 
è la chiave di **decrittazione** che permette alla logica di Conway di manifestarsi come "forma".

.. note::

  Il filosofo **Daniel Dennet** utilizza il Game of Life come metafora centrale nel suo saggio del ``1991``, 
  *Real Patterns*, per illustrare come entità complesse possano essere considerate "reali" 
  senza dover essere riducibili a oggetti fisici fondamentali.

  La descrizione dello stato delle celle come sequenza di stringhe è esaustiva ma priva di sintesi; 
  non permette di "vedere" il comportamento globale del sistema in modo efficiente.

  Per Dennett, il **glider** che si muove su una rappresentazione a matrice
  è un "pattern reale" perché riconoscerlo permette una **compressione predittiva**: 
  fornisce un vantaggio informativo enorme rispetto alla descrizione atomica delle celle.

  I glider dunque "esistono"? La risposta di Dennet è che sono reali tanto quanto i nostri desideri 
  o le nostre credenze. Non sono entità fisiche separate, ma sono configurazioni oggettive 
  della materia che diventano visibili (e reali) solo quando adottiamo 
  un certo livello di astrazione necessario per navigare la complessità del mondo. 

  Dennet sostiene che noi identifichiamo modelli adottando diverse posizioni nei confronti di un sistema:

  - **Posizione fisica**: previsione basata su leggi fisiche e microdettagli.
  - **Posizione di progettazione**: previsione basata sull'organizzazione funzionale 
    (ad esempio, "questa parte serve per il raffreddamento").
  - **Posizione intenzionale**: prevedere il comportamento attribuendo credenze, desideri e razionalità.


  Il collegamento tra i "Real Patterns" di Dennett e la **Teoria algoritmica dell'informazione**
  è diventato un pilastro della filosofia della scienza contemporanea, con importanti sviluppi 
  nel 2025 e 2026 che formalizzano questa intuizione.
  
  Per un approfondimento, si veda  la :ref:`Teoria Algoritmica dell'Informazione` come
  l'apparato matematico che formalizza le idee di Dennet.
  
  


--------------------------------------------
Il gioco come caso di studio
--------------------------------------------

Nei capitoli seguenti faremo riferimento al gioco *Game of Life* (**GofLife**) come
caso di studio di sistemi software, dapprima concentrati e poi distribuiti.
Riportimo qui l'elenco delle varie versionei:

#. :ref:`Costruiamo il Game of Life in Java<Progetto conway26Java>`: 
    impostiamo il sistema come una collezione 
    di oggetti Java. L'obiettivo è anche mettere a punto gli strumenti 
    (Eclipse, Gradle, Docker, etc.) che usermo per la cstruzione del software
#. :ref:`Una GUI HTML per Game of Life`: estendiamo il sistema Java iniziale
   dotando il gioco di una GUI HTML in cui visualizzare l'evoluzione della griglia.
#. :ref:`Game of Life con protoattori`: impostiamo il controllore del gioco come un
   :ref:`Protoattore<Protoattori>`, un nuovo tipo di componente software da noi introdotto.
#. :ref:`Game of Life con QActor`:


.. Costruiamo il Game of Life in Java
 



.. _Progetto conway26Java:

++++++++++++++++++++++++++++++++++++++++++
Progetto conway26Java
++++++++++++++++++++++++++++++++++++++++++

**Impostiamo il progetto in Eclipse**

.. list-table::
    :widths: 25,75
    :width: 100%
    
    * - 
         .. image::  ./_static/img/conway25JavaProjectEclipse.PNG
           :align: center 
           :width: 100%     

      - Inizializzazione
        
        - nella directory **conway26Java** eseguire: ``gradle init 1 2 - -`` 
        - aggiunta *Java nature* 
        - definito il :ref:`build.gradle<build.gradle e Main di conway26Java>`
        - aggiunta (se non esiste) come `sourcefolder`: **src/main/java**  e le altre directory 
          specificate in :ref:`build.gradle<build.gradle e Main di conway26Java>`
        - eseguito  ``gradlew eclipse`` per generare i file per Eclipse
        
        Parte applicativa
         
        - aggiunto ``package conway`` con i file ``java`` dell'applicazione,
          incluso :ref:`Main di conway26Java<build.gradle e Main di conway26Java>` 
        - aggiunto ``package conway.devices`` con i file ``java`` dei dispositivi di I/O
        - aggiunto ``folder userDocs`` e al suo interno:
          
          - il file di nome ``conway25Java_v0.html`` ricavato da `template`_  che ha il ruolo di un `diario di bordo`
            (con varie versioni) 
          - la subdirectory ``userDocs/css`` per gli stili usati dal diario
          - la subdirectory ``userDocs/img`` per le immagini usate dal diario

        Settaggio filtri per redere visibili **resources** e **Gradle build folder**

         .. image::  ./_static/img/eclipseProjectFilers.png
           :align: center 
           :width: 40%     

       

    * - Esecuzione del prodotto
      -  - ``gradlew run``  o da Eclipse

 
+++++++++++++++++++++++++++++++++++++++
build.gradle e Main di conway26Java
+++++++++++++++++++++++++++++++++++++++

.. list-table::
    :widths: 50,50
    :width: 100%

    * - `build.gradle` 

        .. code::

          plugins {
              id 'java'
              id 'eclipse'
          }               
          version '1.0'
          java {
            toolchain.languageVersion.set(
                  JavaLanguageVersion.of(17))
          }
          repositories {
              mavenCentral()
              flatDir {   dirs '../unibolibs'	 }
          }
          sourceSets {
                main {
                    java {
                        srcDirs = ['src/main/java']
                    }
                    resources {
                        srcDirs = ['src/main/resources']
                    }
                }
                test {
                    java {
                        srcDirs = ['src/test/java']
                    }
                    resources {
                        srcDirs = ['src/test/resources']
                    }
                }
          }
          dependencies {
              testImplementation 'junit:junit:4.13.2'
          }

          task run(type: JavaExec){
              classpath = sourceSets.main.runtimeClasspath
              mainClass = "conway.MainConway"
          }

          jar {
            println("building jar")
            from sourceSets.main.allSource
            manifest {
              attributes 'Main-Class':'src/main/java/conway.MainConway'
            }
        } 
      - Si veda :ref:`Creazione progetto con Gradle`

        In questa versione `vi sono dipendenze` solo relative alla libreria JUnit per il :ref:`Testing`
        
        .. file:///C:/Didattica2025/issLab2026/iss25Material/docs/_build/html/ConcettiFondamentali.html#testing. 

        `MainConway.java`_

        .. code::

          public class MainConway  {
              
              public static void main(String[] args) {             
              
                //configureTheSystem
                  Life life           = 
                          new Life( 3,3 );
                  LifeController cc   = 
                          new LifeController(life);   
                  ConwayInputMock cim = 
                          new ConwayInputMock(cc,life);
                
                //start the system
                  cim.simulateUserControl();
                  
              }
          }

++++++++++++++++++++++++++++++++
conway26Java testing
++++++++++++++++++++++++++++++++

Per il :ref:`Testing`, eseguire:

- ``gradlew test`` e aprire il file ``build\reports\tests\test\index.html`` per vedere il risultato del test
- ``gradlew run`` per vedere il risultato dell'esecuzione del programma

  

#. Seguendo quanto detto in :ref:`Il metodo di lavoro`, considerimao questo progetto come il primo Sprint
   per la costruzione incrementale ed evolutiva di un prodotto software
#. Definiamo nel modo più preciso possibile i **requisiti del sistema GofLife**:

   - il sistema deve consentire ad un singolo utente di inizializzare lo stato della griglia
     e di attivare/fermare il gioco 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Analsi del problema GofLife
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Tratandosi di un gioco zero-player con controllo esterno, il sistema 

- deve essere **proattivo**, in quanto deve realizzare il gioco come un comportamento autonomo
- deve essere **anche reattivo**, in quanto deve percepire e gstire i comandi di configurazione 
  e di start/stop che l'utente inviarà  mediante un dispositivo di input
- deve fornire una rappresentazione tenendo conto di quanto detto in 
  :ref:`Il problema della vista del gioco`




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Progetto del sistema GofLife
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In accordo al principi di :ref:`Separazione delle Responsabilità` e :ref:`Single responsibility`
proponiamo una architettura software basata sui seguenti componenti software:

#. Modelliamo il dominio cone le classi Java ``Cell, Grid, Life``
#. Definiamo un componente attivo ``LifeController`` che ha la responsabilità di far evolvere il gioco
#. Definiamo :ref:`La interfaccia IOutDev`  per la visualizzazione dello stato di una ``Cell``  
   e/o di tutta la ``Grid``
#. Definiamo :ref:`La interfaccia GameController`  per la interazione dei dispostivi di input cone  ``LifeController``  
#. Definiamo i componenti di output che implementano ``IOutDev`` e quelli di input che si relazionano con ``LifeController``
   mediante l'interfaccia ``GameController``.
   

.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .
        
        .. image:: ./_static/img/LifeGameJava+.jpg
          :align: center
          :width: 100%   

      -       
        - **Cell**: elemento fondamentale del gioco
        - **Grid**: aggregato di ``Cell``
        - **Life**: regole del gioco 
        - **IOutDev**: contratto per la visualizzazione dello stato di una ``Cell``
        - **LifeController**: controllo del gioco e visualizzazione della ``Grid``
        - **Gamecontroller**: contratto che ``LifeController`` impone ai dispositivi in input

.. _LifeController:

+++++++++++++++++++++++++++++++++++
LifeController
+++++++++++++++++++++++++++++++++++
Osserviamo che ``LifeController`` è un componente 

- **proattivo**, in quanto fa evolvere il “zero-player game”
- **reattivo**, in quanto dovrebbe essere capace di:

  - percepire comandi per definire la configurazione iniziale della  ``Grid``
  - percepire comandi di ``start/stop/clear`` del gioco  emssi da un utente (umano) mediante un dispositivo di input.
    A questo fine, ``LifeController`` implementa  :ref:`La interfaccia GameController`

Osserviamo anche che i dispostivi di output e di input possono essere di tipi diversi. In particolare,
esamineremo le seguenti possibilità:

#. Dispositivo di output basato su console (``System.out``); lasciato come esercizio al lettore
#. Dispositivo di output (e input) basato su GUI swing: si veda :ref:`Una GUI con Swing`
#. Dispositivo di output (e input) basato su GUI HTML/JS:

  - con rapprresentazione granulare della ``Grid``; si veda :ref:`Una griglia granulare` 
  - con rappresentazione sintetica della ``Grid``` mediante canvas; si veda :ref:`Una griglia globale`

Il punto importante consiste nel fare in modo che ``LifeController``
**non dipenda** da una specifica implementazione di ``IOutDev``.

.. code:: java

  public class LifeController implements GameController { 
    public LifeController( Life game, IOutDev outdev ){
    ... 
    }

    protected void play() {  
      new Thread() {
        public void run() {	
          //Evoluzione del gioco in epoche successive
          while( running ) {
            ...
          }
        }
      }.start();
     }//play

.. _Evoluzione di GofLife:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il processo di evoluzione del gioco
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Il task **play** fa evolvere il gioco dalla configurazione iniziale in epoche successive.
Nella nostra implementazione attuale, il task rimane **running**  fino a quando:

- la configurazione corrente diventa stabile
- non ci sono più celle vive
- l'utente invia un comando ``stop`` per fermare l'evoluzione del sistema

Tuttavia si potrebbe pensare di non fermare *play* nei primi due casi, in quanto:

- l'utente che controlla il gioco potrebbe introdurre nuove celle 'vive' tra una epoca e l'altra
- il task *play* stesso potrebbe generare nuove celle 'vive' in modo casuale,
  simulando un meccanisimo che nella teoria dei campi della fisica moderna 
  è collegato all'idea di 'vuoto fisico' della toria dei campi come entità dinamica, 
  che, come asserito dai mistici orientali,
  è la 'realtà prima' che dà origine a tutte le forme del mondo fenomenico.

 




.. _La interfaccia IOutDev:

++++++++++++++++++++++++++++++++++++++++
La interfaccia IOutDev
++++++++++++++++++++++++++++++++++++++++

.. code:: java

    package main.java.conway.domain;

    public interface IOutDev {
      void display(String msg);      //For HMI
      void displayCell(Cell cell, Grid grid);   
      void displayGrid(Grid grid);
      void close();
    }

- Il metodo ``display(String msg)`` consente di visualizzare messaggi di testo (per una migliore **HMI**
  *HumanMachineInterface*)
- Il metodo ``displayCell(Cell cell, Grid grid)`` consente di visualizzare lo stato di una singola cella 
  (all'interno della griglia)
- Il metodo ``displayGrid(Grid grid)`` consente di visualizzare lo stato di tutta la griglia

.. _La interfaccia GameController:

++++++++++++++++++++++++++++++++++++++++
La interfaccia GameController
++++++++++++++++++++++++++++++++++++++++

.. code:: java

  package main.java.conway.domain;

  public interface GameController {
      void onStart();
      void onStop();
      void onClear();
      void switchCellState(int x, int y);
      void setOutDev(IOutDev outdev); //injection
  }

- I metodi ``onStart``, ``onStop`` e ``onClear`` consentono di avviare, fermare e azzerare il gioco.
- Il metodo ``switchCellState`` consente di commutare lo stato di una cella (viva/morta). Usato in particolare nella
  fase di inizializzazione.
- Il metodo ``setOutDev`` consente di 'iniettare' una specifica implementazione di ``IOutDev`` nel ``LifeController``.

 
I diversi approcci per la realizzazione di dispostivi di output e input vengono sperimentati con il programma
**MainConwayLifeJava.java** nel package ``main.java.conway.domain`` attraverso diverse procedure di configurazione
del sistema:

- :ref:`Configurazione di GofLife con Swing`
- :ref:`Configurazione di GofLife con HTML`

.. `Una prima analisi del problema`    




.. _Una GUI con Swing:

+++++++++++++++++++++++++++++++++++++++
Una GUI con Swing
+++++++++++++++++++++++++++++++++++++++


Un primo modo per superare il limite dell'uso della console come dispositivo di output, 
è introdurre una visualizzazione di tipo grafico,
realizzando una GUI in Java con Swing.
Un dispostivo di questo tipo è definito nella classe ``main/java/conway/io/ConwayLifeGridClaude.java``
il cui codice è stato proposto da **Claude AI**. 

.. note::

  Il prompt dato a Claude (**requisiti**): Vorrei una classe Java che realizza la rappresentazione grafica di 
  una griglia quadrata di ``20x20`` celle usando Swiing. 
  La griglia è relativa al gioco ConwayLife e quindi le celle possono assumere solo due colori (white - cella morta e red - cella viva). 
  La classe deve fornire metodi invocabili dall'esterno per visualizzare tutta la griglia e per commutare il colore di una cella 
  (da white a red e viceversa). Nella rappresentazione grafica devono comparire anche due pulsanti START e STOP, 
  facendo click sui quali la classe invia un comando a un componente esterno (un controllore del gioco)

.. _Configurazione di GofLife con Swing:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Configurazione di GofLife con Swing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Rispetto al codice proposto da Claude, abbiamo aggiunto i metodi per implementare l'interfaccia ``IOutDev``
e la 'iniezione' alla costruzione  dell'istanza di ``LifeController``.

.. code:: java

  public void configureTheSystemWithSwing() {
    Life life            = new Life( 20,20 );                   
    IOutDev swinggui     = new ConwayLifeGridClaude( );   //dispositivo di output (e anche di input)
    GameController  cc   = new LifeController(life, swinggui) ;   //un GameController che deve usare un IOutDev
    ((ConwayLifeGridClaude) swinggui).setController(cc);          //iniezione del controller nella GUI
    //Il sistema termina quando si chiude la swinggui
  }

**Problemi di deplyment**

Questa implementazione funziona bene in locale, ma non è adatta a essere eseguito in un container Docker.

Infatti, Java Swing tenta di disegnare la GUI, interroga il sistema operativo per trovare un Display Server 
(come *X11* su Linux o *Window Manager* su Windows). 
Non trovandolo, Java solleverà l'eccezione **java.awt.HeadlessException**.

Mettere una GUI Swing in Docker va contro la filosofia "Cloud Native", se non altro
perchè l'immagine Docker diventa enorme, dovendo includere tutte le librerie grafiche.

Meglio quindi realizzare la GUI come una pagina Web (HTML/JS).


====================================================
Da una funzione a un servizio
====================================================

Vogliamo realizzare un semplicissimo servizio in Java che calcola i valori di una data espressione matematica:

.. list-table::
  :widths: 40,60
  :width: 100%

  * - :math:`\sin(x) + \cos(\sqrt{3}*x)`
    - .
    
      .. image:: ./_static/img/eval.jpg
          :align: center
          :width: 100%

Per raggiungere l'obiettivo useremo  il :ref:`javalin server`
che abilita la ricezione di mesaggi via WebSocket, ma anche via HTTP/1 e HTTP2
 
.. Qui assumiamo che queste funzione sia il 'core' applicativo di un nostro sistema software.


----------------------------------------------
framework javalin: ali e catene
----------------------------------------------

In modo analogo a :ref:`Il motto di Alan Kay`   
per i linguaggi di programmazione, possiamo dire che i framework sono, in generale, **sia ali sia catene**.

Infatti, un framework propone un proprio modello organizzativo di sistema.
Gli esempi documentali tendono a favorire la brevità a scapito della manutenibilità
e, senza opportune avvertenze progettuali, la struttura del codice 
del sistema, ricalcando la struttura degli esempi, potrebbe creare confusione e accoppiamenti pericolosi.

In particolare, **javalin** è un framework **non-opinionated** (si veda `Opinionated vs. Non-Opinionated Frameworks`_)
che pottrerbbe indurre a scrivere tutta la logica dentro i gestori dei messaggi, 
creando un ammasso disordinato di codice. Vediamo un esempio.

+++++++++++++++++++++++++++++++++++++++
Imitiamo gli esempi documentali
+++++++++++++++++++++++++++++++++++++++

.. list-table::
  :widths: 50,50
  :width: 100%

  * - .. code::

        package main.java.javalin;
        import io.javalin.Javalin;
        import unibo.basicomm23.utils.CommUtils;
        public class SistemaSJavalin {
        public void doJob() {  ....  }          
        public static void main(String[] args) {
              new SistemaSJavalin().doJob();
        }
        }//SistemaSJavalin
    -  Il metodo *doJob()* deve:

       #. acquisire da un client il valore dell'argonento ``x`` via rete
       #. calcolare :math:`\sin(x) + \cos(\sqrt{3}*x)`
       #. inviare al client il risultato
         
 
Il codice di **doJob**,  impostato secondo lo 'stile' della documentazione di javalin si presenta come segue:

.. list-table::
  :widths: 60,40
  :width: 100%

  * - .. code::

        /*1*/ ...
        public void doJob() {
        /*2*/  Javalin app = 
                  Javalin.create().start(8080);
        //PARTE WS ------------------------------------
        /*3*/ app.ws("/eval", 
        /*4*/  ws -> {
        /*5*/   ws.onConnect( 
                    ctx -> { ctx.send("welcome"); });
        /*6*/   ws.onMessage(ctx -> {
                String message = ctx.message();
                try {
        /*7*/     double x = Double.parseDouble(message);
        /*8*/     double r = 
                    Math.sin(x)+Math.cos(Math.sqrt(3)*x);
        /*9*/     ctx.send( result );
                }catch (NumberFormatException e) {
        /*9*/	    ctx.send("Errore: num non valido");
                }
              });
        /*10*/ws.onClose(
                 ctx->{System.out.println("sbye");}
              );
             });//ws
          ...
        }////doJob        
        ...  
 
    - 
      #. codice precedente 
      #. crea il framework, che fa partire il `Server Jetty`_ con una configurazione di default 
      #. chiama il metodo di Javalin per registrare un endpoint WebSocket specificando come path ``/eval``
         e come secondo argomento una **lambda expression** ``ws -> {...}``
      #. il parametro **ws** è un oggetto di tipo ``io.javalin.websocket.WsConfig``.
         L'oggetto **ctx** è di tipo `WsMessageContext`_
      #. specifica il comportamento alla connessione
      #. specifica il comportamento alla ricezione di un messaggio di tipo String su WS
         (ad es. ``"-4.0"``)
      #. estrae dal messggio il valore di input
      #. calcola l'espressione 'core' 
      #. invia la risposta al client su WS
      #. gestisce la chiusura della connessione da parte del client

.. note::

  Il messaggio "welcome" su WS al punto 5 potrebbe non arrivare al client.

  L'evento **onConnect** in Javalin scatta non appena il server decide che la connessione è valida, 
  ma non garantisce che il client abbia già "finito di inizializzare" 
  i suoi software. È l'essenza dei sistemi asincroni: essere connessi non significa essere pronti a ricevere.

.. _Come opera javalin:

++++++++++++++++++++++++++++++++++++
Come opera javalin
++++++++++++++++++++++++++++++++++++

Javalin gira sopra Jetty (un server web estremamente performante).
Ogni volta che arriva un messaggio, Jetty assegna il compito di eseguire il codice dentro **onMessage** a un thread preso dal suo *Thread Pool*.

In particolare:

- Quando si esegue ``Javalin.create().start(8080)``, viene inizializzato un pool di thread (solitamente chiamato *QueuedThreadPool*).
- Se arrivano due messaggi quasi simultaneamente da due client diversi (o anche dallo stesso client), 
  Jetty preleva due thread distinti (**TX**) dal pool.

  - Il primo thread TX esegue la logica di onMessage per il Messaggio A.
  - Il secondo thread TX esegue la logica di onMessage per il Messaggio B.

Questi due processi avvengono contemporaneamente (in parallelo) sui core della CPU.
Questa esecuzione parallela è ottima per le prestazioni, ma introduce molti problemi se il server non è **stateless**:

- Corse critiche (ad es. incremento di un contatore errato)
- In Java, ogni core della CPU ha la sua cache. Se il Thread TX-1 aggiorna una variabile nella sua cache, 
  il Thread TX-2 (che gira su un altro core) potrebbe continuare a vedere il valore vecchio per diversi cicli di clock. 
  Questo costringe a usare **volatile** o **synchronized**, appesantendo il codice.
- Inversione dell'Ordine. Le WebSocket garantiscono che i messaggi arrivino al server nell'ordine corretto, 
  ma Javalin non garantisce che i thread TX finiscano nell'ordine corretto. Ad esempio,
  se un Client invia un messaggio "Accendi" e poi il messaggio "Spegni", il thread TX che gestosce "Spegni"
  potrebbe termninare per primo e il sistema rimane acceso.

Per questo motivo un server scritto in Node.js esegue il codice JavaScript su un *unico thread* (chiamato **Event Loop**)  .

Notiamo che in un sistema distribuito due server potrebbero interagire con un altro servizio, ad esempio uno stesso database.
In questo caso, i problemi di concorrenza si ripresentano a livello di rete.


.. _Tempo di vita di una connessione WS in Jetty:

++++++++++++++++++++++++++++++++++++++++++++++
Tempo di vita di una connessione WS in Jetty
++++++++++++++++++++++++++++++++++++++++++++++
Jetty chiude automaticamente le connessioni WebSocket se non rileva traffico dopo un certo intervallo di tempo.

Per prolungare la vita di una connessione WebSocket in Javalin (che si appoggia a Jetty), 
si può agire su un parametro del server chiamato *Idle Timeout*.

.. E' quanto abiamo fatto al Punto /*2*/.

Tuttavia,  anche se si imposta un timeout molto lungo sul server, i router o i proxy lungo il percorso 
potrebbero comunque chiudere la connessione se non vedono passare dati.

In taluni casi è quindi opportuno inviare periodicamente dei messaggi (PING) di "heartbeat" (battito cardiaco)

Un esempio è fornito più avanti, nella sezione :ref:`Teniamo in vita la connessione WS`.

++++++++++++++++++++++++++++++++++++
L'oggetto ctx di javalin
++++++++++++++++++++++++++++++++++++



**ctx** che compare all'interno di onMessage è un'istanza della classe *io.javalin.websocket.WsMessageContex*. 

Il `WsMessageContext`_ agisce come un wrapper. Javalin lo crea nell'istante in cui il messaggio arriva 
e lo "distrugge" (lo rende disponibile per il Garbage Collector) non appena la lambda finisce di girare.

Tuttavia, all'interno di questo wrapper c'è un riferimento alla Sessione WebSocket reale, 
che invece è persistente e rimane la stessa finché il client non chiude il browser o cade la connessione.

.. note::

  Il `WsMessageContext`_  mette a disposizione strumenti ottimizzati per la lettura del messaggio:

  .. list-table::
    :widths: 35,65
    :width: 100%

    * - ctx.message()
      - Restituisce il messaggio ricevuto come semplice String.
    * - ctx.messageAsClass(Class<T>) 
      - Converte il messaggio direttamente in un `Java record`_ o POJO.
    * - ctx.send(Object)
      - Invia una risposta al client (un oggetto, che Javalin  trasforma in JSON).
    * - ctx.session()
      - Dà accesso all'oggetto Session di Jetty (per operazioni di basso livello)
    * - ctx.queryString()
      - pPrmette di leggere i parametri dell'URL usati al momento della connessione.

++++++++++++++++++++++++++++++++++++
javalin gestisce anche HTTP
++++++++++++++++++++++++++++++++++++

Negli esempi, a questo codice si affianca spesso una parte che gestisce ``HTTP``, che di solito richiede l'uso di **JSON**:

.. list-table::
  :widths: 50,50
  :width: 100%

  * - .. code::
 
        ...
        public void doJob() {
        /*1*/var app=Javalin.create().start(8080);
        
        //PARTE WS ---------------------------
          ....        
        //PARTE HTTP -------------------------
           ...
        }//doJob        
 
 
    - 
      #. parte precedente, che crea il framework.

        La frase **var app** sfrutta 
        la funzionalità chiamata **LVDT** (*Local Variable Type Inference*)
        introdotta da ``Java10``, disponibile solo per le **variabili locali con inizializzatore**.
  
.. list-table::
  :widths: 55,45
  :width: 100%

  * - .. code::
          
        /*1*/ ....      
        //PARTE HTTP -------------------------------
        /*2*/app.get("/",
                ctx->ctx.result("Hello HTTP/1.1")); 
        /*3*/app.get("/eval", ctx -> {
              double x = Double.parseDouble(
                      ctx.queryParam("x"));
        /*4*/ double r = 
                Math.sin(x)+Math.cos(Math.sqrt(3)*x);
	            ctx.json(Map.of(
                "fullUrl", ctx.fullUrl(), 
                "result", r));
	        });

        /*5*/app.post("/evaluate", ctx -> {//CORS
    	      org.json.simple.JSONObject m = 
        /*6*/ CommUtils.parseForJson(ctx.body());
        /*7*/ String xs= ""+m.get("x"); 
              try {
        /*8*/   double x = Double.parseDouble(xs);
        /*9*/   double r = 
                  Math.sin(x)+Math.cos(Math.sqrt(3)*x);
                 // Invia risposta in JSON
        /*10*/  ctx.json(Map.of(
                  "fullUrl", ctx.fullUrl(), 
                   body", ctx.body(), "result", r));
              } catch (NumberFormatException e) {
        /*10*/   ctx.json(Map.of(
                  "fullUrl", ctx.fullUrl(), 
                  "body", ctx.body(), 
                  "result", "Errore:num non valido"));
              }
            });
        }//doJob        
 
 
    - 
      #. parte precedente 
      #. comportamento GET alla connessione ``localhost:/8080``.
         L'oggetto **ctx** è di tipo `io.javalin.http.Context`_
      
         ---
      #. comportamento GET quando l'URL di una connessione specifica un parametro
         (ad esempio:
         
         ``http://localhost:8080/eval?x=-4``)
      #. calcola l'espressione 'core' 
 
         ---
      #. comportamento POST quando i dati (parametro ``x``)  viaggiano nel  
         corpo (body) della richiesta, in formato JSON
      #. estrazione del body in JSON
      #. estrazione del valore del parametro
      #. calcolo del valore del parametro ``x`` 
      #. calcola l'espressione 'core' 
      #. invia la risposta HTTP in JSON

**ctx.json(Map.of(...))**
 
La operazione ``ctx.json(Map.of(...))``  fa le seguenti azioni:

- **Serializzazione**: Prende la Map Java e la trasforma in una stringa in formato JSON. 
  Javalin usa solitamente una libreria  *Jackson* per farlo.
- **Impostazione degli Header**: Comunica al destinatario cosa starà ricevendo impostando l'header HTTP ``Content-Type a application/json; charset=utf-8``. 
  Senza questo, il client potrebbe pensare che sia semplice testo (*text/plain*).
- **Scrittura della Risposta**: Invia la stringa JSON nel corpo della risposta HTTP e chiude la transazione per quel thread.


.. note::

  CORS (*Cross-Origin Resource Sharing*) è un meccanismo di sicurezza nei browser che permette 
  a una pagina web di richiedere risorse (come dati, font, immagini) da un dominio diverso 
  dal proprio, cosa normalmente vietata dalla *Same-Origin Policy* (**SOP**). 

  Se il codice viene eseguito da un browser verso un IP 
  diverso da quello della pagina web corrente, il server del servizio 
  deve essere configurato per accettare richieste **Cross-Origin**, 
  altrimenti il browser bloccherà la risposta per sicurezza.
  
  Funziona tramite intestazioni HTTP, dove il server di destinazione comunica al browser 
  quali origini (siti) sono autorizzate ad accedere alle sue risorse, 
  gestendo così in modo sicuro le interazioni tra applicazioni web e servizi esterni, come le API. 
  In javalin, si può abilitare CORS alla creazione del server, con una opportuna configurazione: 

  .. code::

   var app = Javalin.create(config -> {   
             	config.bundledPlugins.enableCors(cors -> {
                cors.addRule(it -> it.anyHost());
            });
        }).start(8080);       

++++++++++++++++++++++++++++++++++
HTTP e WS sono diversi
++++++++++++++++++++++++++++++++++

L'esempio vuole mostrare che javalin permette di gestire sia connessioni su WebSocket 
sia interazioni via HTTP con un impianto di codice molto simile.

Ma le due funzionalità sono profondamente diverse:

- ``app.ws`` stabilisce una **relazione** tra client e server che rimane attiva fino a quando il client
  chiude la connessione.   
- ``app.post`` stabilisce una **transazione** che termina quando il server invia il risultato.


Si evidenzia un punto critico di molti framework moderni: 
la tensione tra "facilità d'uso" e "correttezza architettonica".

Javalin è progettato per essere fluente e minimale e propone un'interfaccia che fa sembrare tutto simile.
Ma questa uniformità estetica nasconde differenze strutturali profonde tra i protocolli, 
creando quello che in gergo si chiama un "modello mentale sfocato".
Si viola il `Principle of least astonishment`_ **(POLA)** (Minima Sorpresa): 
un sistema si deve comportare in modo da non stupire o sorprendere gli utenti.


---------------------------------------
Progettiamo il sistema
---------------------------------------

L'esempio ci induce a riflettere sulla differenza tra *imparare uno strumento* (il framework) 
e seguire metodi opportuni di ingegneria del software nell'uso dello strumento.

La progettazione (a livello umano) è sempre legata all'uso, consapevole o meno,
di 'abitudini mentali' implicitamente assunte come pragmaticamente utili e opportune.
E' però indispensabule rendere espliciti i **'principi'** su cui un progettista basa le sue
proposte, con particolare riferimento alla **impostazione della architettura** del sistema.

.. _Separazione delle Responsabilità:

++++++++++++++++++++++++++++++++++++++++++++
Separazione delle Responsabilità
++++++++++++++++++++++++++++++++++++++++++++

I progettisti di Javalin hanno operato, all'interno del framwork, una scelta architettonica precisa,
che rispetta il principio della **Separazione delle Responsabilità** (*Separation of Concerns* - **SoC**).

.. note::

  **SoC** è un principio  architettonico generale che opera a 'livello  macro'. 
  
  Si affianca al  
  :ref:`Single responsibility`
  che invece si applica a 'livello  micro', cioè di singoli componenti.

Infatti Javalin introdice due diverse classi come supporto alle funzionalità relative
alle *WebSocket* e a *HTTP*:

- **io.javalin.websocket.WebMessageContext** (sottoclasse di *WebContext*) per la gestione di messaggi inviati su **WS**;
- **io.javalin.http.Context** per le rotte **HTTP** 
  (come ``app.get`` o ``app.post``). 
  
Sebbene abbiano nomi simili, queste due classi servono a gestire protocolli diversi e appartengono a  
gerarchie ompletamente separate.

Tuttavia, negli esempi che 'spiegano' il funzionamento di javalin questi due contestii
non sono chiaramente separati.
Lo 'stile dichiarativo' che il framework propone a livello applicativo,
intende enfatizzare concetti comuni a due parti diverse 'sommerse'
e il comprtamento del framweork può apparire misterioso.

Il rischio è che il framework, in quanto parte sommersa del sistema, venga 
percepito come un'entità magica, mentre la sua reale comprensione risiede 
nel capire come esso orchestra le risorse (thread, socket, memoria) 'dietro le quinte' 
degli esempi.

Nel nostro refactoring del sistema, la *Separation of Concerns* verrà chiaramente evidenziata 
(in qualche modo 'ricostruita') a livello applicativo.


++++++++++++++++++++++++++++++++++++++++++++
Influenza della Clean Architecture
++++++++++++++++++++++++++++++++++++++++++++


Ricordando i principi delle :ref:`Clean Architectures`, 

#. il framework :ref:`javalin<javalin server>`, verrà conceptito come un sotto-sistema che svolge il ruolo
   di un **Inbound Adapter** .   
#. L'espressione matematica da calcolare sarà 
   contenuta in un componete sofware isolato dal framework.
   Al momento, introduciamo una  **funzione** (``eval``) attorno alla quale, 
   javalin funge **solo da guscio** infrastrutturale, 
   evitando che le logiche di trasporto inquinino la purezza del dominio applicativo.

Si  evitarà in questo modo il danno di una **Leaky Abstraction**, cioè che
i dettagli tecnici del framework vadano a contaminare la logica di business.



.. list-table::
  :widths: 50,50
  :width: 100%

  * -  
      .. image:: ./_static/img/evalInJavalin.png
          :align: center
          :width: 100%
    -  
      .. image:: ./_static/img/LayersSistemaS.png
          :align: center
          :width: 100%
 

Queste scelte progettuali modificano 
la struttura del codice del sistema in una  **architettura a Layer** :

#. **Livello di Dominio**. La funzione ``eval`` è il layer che definisce la 'business logic' del sistema:
   
   .. code::

      protected double eval(double x) {
        if (x > 4.0) {
            CommUtils.outmagenta( "eval  | Simulo ritardo per x=" + x);
            CommUtils.delay(10000);
          }
    	  return Math.sin(x) + Math.cos( Math.sqrt(3)*x);
      }
    
   Questa funzione non sa nulla di  Javalin o di protcolli.
   In seguito, potrrebbe essere sostituita da un **POJO**.

   SI noti che, per simulare computazioni con tempi lunghi, introduiciamo un ritardo per i valori ``(x > 4.0``.

#. **Livello Infrastruttura**. Qui opera Javalin, con l'obiettivo di gestire i protocolli e 
   di prelevare dai messaggi le informazioni rilevanti per il **domain-layer**.
   E' opportuno separare bene i vari aspetti con altrettante funzioni:

   .. code::

      //Parte di supporto alle WebSocket -----------------------
      protected String handlerWS(WsMessageContext ctx) {
        //Elabora i messaggi ricevuti su WS, 
        try {
        	String m       = ctx.message();   
        	double x       = readInputWS(m);
          double result  = eval(x);                
          return "risultato WS="+result + " per x="+x;     
        } catch (NumberFormatException e) {
           return "Errore WS: numero non valido";
        }
      }

      //Parte di supporto ad HTTP        -----------------------
      protected String handlerHTTP(Context ctx) {
        //Elabora i messaggi ricevuti su HTTP, 
         try {
        	JSONObject m  = CommUtils.parseForJson(ctx.body());
        	double x      = readInputHTTP(m);
          double result = eval(x);                
          return "risultato HTTP="+result;     
        } catch (NumberFormatException e) {
           return "Errore HTTP: numero non valido";
        }
      }

#. **Livello di Adattamento**: livello intermedio che trasforma i dati di basso livello 
   forniti dalla infrastruttura nei dati richiesti dalla applicazione. 
   Anche qui  è opportuno introdurre   funzioni di utilità:

   .. code::

      protected double readInputWS(String message) throws NumberFormatException{
        //Elabora i dati ricevuti su WS  
        double x = Double.parseDouble(message);   
    	return x;
      }

      protected double readInputHTTP(JSONObject b) throws NumberFormatException{
        //Elabora i messaggi ricevuti su HTTP,  
        String xs = ""+b.get("x");
        double x  = Double.parseDouble(xs);
        return x;
      }

In *javalin* (come in ogni framework) è il framework che chiama il codice scritto dall'utente
secondo il meccanismo della :ref:`Inversione di Controllo<Dependency inversion>`.

.. _SistemaSJavalinBetter:

++++++++++++++++++++++++++++++++++++++++++++
SistemaSJavalinBetter: SOC
++++++++++++++++++++++++++++++++++++++++++++

.. list-table::
  :widths: 60,40
  :width: 100%

  * - 
     .. code::

        package main.java.javalin; 
        import io.javalin.Javalin;
        import unibo.basicomm23.utils.CommUtils;

        public class SistemaSJavalinBetter {
        /*1*/ private Javalin app = null;

        /*2*/ protected double eval(double input) { ... }
        
        /*3*/public void configureTheSystem() {
              setWorkHTTP();
              setWorkWS( );   
            }
 
        /*4*/protected void setWorkWS(Javalin app) { ... }
        /*5*/protected void setWorkHTTP(Javalin app) { ... }
          
          public static void main(String[] args) {
              new SistemaSJavalinBetter().configureTheSystem();
          }
        }//SistemaSJavalinBetter 
    - 
      #. dichiarazione dell'oggetto che rappresenta l'infrastruttura
      #. la funzione ``eval`` che deve essere resa eseguibile via rete
      #. metodo per configurare il sistema in modo che gestisca sia WS sia HTTP
      #. configurazione del server per comunicazioni tramite WebSocket 
      #. configurazione del server per comunicazioni tramite HTTP 

La struttura del codice rende immediatamente percepible il 'core business' applicativo 
e le due diverse responsabilità 
della infrastruttura: gestione delle WebSocket  e gestione HTTP.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SistemaSJavalinBetter: setUpServer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Introduciamo un metodo che crea il framework javalin per WS e/o per HTTP in modo
che consenta la corretta configurazione del server in entrambi i casi,
indipendentemente da chi venga attivato per primo.

.. list-table::
  :widths: 90,10
  :width: 100%

  * - 
     .. code::

        protected void setUpServer( boolean forWS ) {
          if (forWS ) {
            if( app == null ) app = Javalin.create().start(8080);
          }else { //forHTTP			
            if (app == null) {
              app = Javalin.create(config -> {
                config.bundledPlugins.enableCors(cors -> {
                  cors.addRule(it -> it.anyHost());
                });
              }).start(8080);
            }else {
              //"Server già avviato. Configuro per CORS"
              app.before(ctx -> {
                ctx.header("Access-Control-Allow-Origin","*"); //Permette a TUTTI  
                ctx.header("Access-Control-Allow-Methods",
                            "GET, POST, PUT, DELETE, OPTIONS");
                ctx.header("Access-Control-Allow-Headers",
                            "Content-Type, Authorization");
                ctx.header("Access-Control-Allow-Credentials", "true");
              });        
              // Gestisce le richieste OPTIONS (Preflight)
              app.options("/*", ctx -> {
                    ctx.status(204); // No Content - il server accetta la chiamata
                });
            }//app != null
          }
        }
    - 
       
Scopo del metodo è inizializzare la variabile **app** che rappresenta la infrastruttura.
Se si vuole creare il supporto per HTTP 
con abilitazione di CORS
dopo che *app* è gia stata inizializzata.
occorre fare riferimeo a **app.before** e **app.option**, al fine di:

- Aggiungere gli header a ogni risposta.
- Rispondere alle *richieste Preflight* (il metodo ``OPTIONS`` che il browser 
  invia prima della richiesta reale).

.. note::

  Quando il browser deve fare una chiamata "pericolosa" (come un POST con JSON o una richiesta con header personalizzati)
  a un dominio diverso, esegue prima una chiamata di prova con il metodo **OPTIONS**.

  Se il server non risponde positivamente (200 o 204) a questa chiamata, 
  il browser blocca la richiesta vera e propria per sicurezza.

  Usando ``app.options("/*", ...)`` il sistema risponderà positivamente a qualunque "test" 
  di connessione su qualsiasi percorso.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SistemaSJavalinBetter: setWorkWS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Questa funzione ha la **responsabilità** di preparare le funzionalità del server 
rleative alla gestione delle connessioni su WebSocket.

.. list-table::
  :widths: 80,20
  :width: 100%

  * - 
     .. code::

        /*1*/ ...
        protected void setWorkWS( ) { 
        /*2*/setUpServer( true ); //per WS
        /*3*/ app.ws("/eval", 
        /*4*/  ws -> {  
                //w:io.javalin.websocket.WsConfig
        /*5*/   ws.onConnect( ctx -> {  
                  //ctx:io.javalin.websocket.WsConnectContext
                  //Thread.sleep(1000); //SOLO PER TEST!
                  ctx.send("welcome"); } 
                );
        /*6*/   ws.onMessage(ctx -> { 
                  //ctx:io.javalin.websocket.WsMessageContext
                  String message = ctx.message();
                  String answer  = handlerWS( ctx );
                  // Invia la risposta al client                  
        /*7*/    ctx.send( answer );
              });
        /*8*/ ws.onClose(ctx -> { 
                  //ctx:io.javalin.websocket.WsCloseContext
                  System.out.println("server: conn closed"); 
        	    });
            });
         }//setWorkWS
    
    -  




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SistemaSJavalinBetter: setWorkHTTP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Questa funzione ha la **responsabilità** di preparare le funzionalità del server 
rleative alla gestione delle connessioni HTTP.

.. list-table::
  :widths: 80,20
  :width: 100%

  * - 
     .. code::

        setUpServer( false ); //per HTTP
        app.get("/", ctx -> ctx.result(
                "Hello World via HTTP/1.1")); 
          
        app.get("/eval", ctx -> {
          double x = Double.parseDouble(ctx.queryParam("x"));
          double r = eval( x );     
          //Invia risposta in JSON             
          ctx.json(Map.of("fullUrl", ctx.fullUrl(), "result", r));
        });
                
        app.post("/evaluate", ctx -> {  //Warning: check CORS
              String result = handlerHTTP( ctx );
                  //Invia risposta in JSON
                  ctx.json(Map.of(
                    "fullUrl", ctx.fullUrl(), 
                    "body", ctx.body(), 
                    "result", result));
        });
    - 


.. _Uso del sistema in JS:

------------------------------------------------------
Uso del sistema in JS
------------------------------------------------------

Per utilizzare il sistema possiamo impostare client WS o HTTP in un qualche linguaqggio di programmazione
(Java, Pythin, etc.) o fare uso di strumenti come Postam o curl.

Un modo semplice è impostare un file html con codice Javascript. Aprendo il file con un browser
e attivando gli **Strumenti per sviluppatori** (tasto **F12**) si vedranno i messaggi inviati sulla console.

 

++++++++++++++++++++++++++++++++++++++++++++++++
Prova WS in Javascript
++++++++++++++++++++++++++++++++++++++++++++++++

Impostaimo un file **CallerBasic.html**

.. list-table::
  :widths: 60,40
  :width: 100%

  * - 
     .. code::
 
        <html>        
        <script>
        function  callWS(msgtosend){
        /*1*/const socketWS = 
          new WebSocket("ws://localhost:8080/eval");

        /*2*/socketWS.onopen = () => {
            console.log("callWS | Connesso a eval");
            socketWS.send(msgtosend);
          }

        /*3*/socketWS.onmessage = (event) => {
            console.log("callWS | Risposta:",event.data);
          }
        }//callWS

        callWS(5.0)  //lazy     
        callWS(4.0)  //fast
        </script>
        </html>
    - 
      #. Crea una WS con path ``eval``
      #. Invia un valore quando la connessione è stabilita
      #. Ascolta i messaggi dal server

La console del browser mosterà 'eventi' emessi dal server e due risposte:

.. image:: ./_static/img/CallWS.png
    :align: center
    :width: 80%

 

++++++++++++++++++++++++++++++++++++++++++++++++
Prova HTTP in Javascript
++++++++++++++++++++++++++++++++++++++++++++++++

In JavaScript moderno, il modo più semplice ed elegante per interagire con un'API è utilizzare 
l'API **fetch()**. È integrata in tutti i browser recenti e nelle versioni attuali di *Node.js*.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esempio di Richiesta GET
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Questa richiesta serve per "chiedere" informazioni al servizio.

.. code::


    async function testHTTPGet() {
      try {
        const url = 'http://localhost:8080/evaluate?x=-4';
        const response = await fetch(url);
        // Controlla se il server ha risposto con un errore (es. 404 o 500)
        if (!response.ok) {
          throw new Error(`Errore del server: ${response.status}`);
        }
        const data=await response.json(); //Converte la risposta da JSON a oggetto JS
        console.log('Dati ricevuti con successo:', data);
      } catch (error) {
        console.error('Errore:', error);
      }
    }

**fetch** restituisce una **Promise**. Usiamo **async** e **await** per rendere il codice leggibile, 
*come se fosse sincrono*, evitando che il programma si blocchi mentre aspetta la risposta della rete.

La console del browser mosterà:

.. image:: ./_static/img/CallHTTPget.png
    :align: center
    :width: 80%

  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esempio di Richiesta POST 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Per inviare delle informazioni al servizio, 
occorre specificare il metodo, gli headers e il body (il corpo del messaggio).

.. code::


    async function testHTTPPost() {
        try {
            const url = 'http://localhost:8080/evaluate';
            const response = await fetch(url, {
                method: 'POST', // Specifica il metodo
                headers: {
                    'Content-Type': 'application/json'  
                    //'Authorization': 'Bearer IL_TUO_TOKEN' //Se serve autenticazione
                },
                body: JSON.stringify({ x: 4.0 }) // Converte oggetto JS in stringa JSON
            });
            const result = await response.json();
            console.log('Risposta del server:', result);
        } catch (error) {
            console.error('Errore durante il caricamento:', error);
        }
    }




**JSON.stringify()**: È fondamentale quando invii dati (POST/PUT). Il server non capisce gli oggetti JavaScript, 
capisce solo stringhe di testo formattate come JSON.

La console del browser mosterà:

.. image:: ./_static/img/CallHTTPpost.png
    :align: center
    :width: 80%



-----------------------------------------------------
Dal bottum-up al top-down
-----------------------------------------------------

Abbiamo visto che in *javalin* è il framework che chiama il codice scritto dall'utente
secondo il meccanismo della :ref:`Inversione di Controllo<Dependency inversion>`.

Le applicazioni costruite attorno a questo framework, anche se ben organizzate, 
appaiono intrinsecamente **reattive** e 
potrebbe essere difficile impostare il progetto di applicazioni che siano anche proattive.

Si supponga, ad esempio, che la funzione ``eval``  debba essere calcolata ogni 5 secondi 
con i dati forniti da un sensore, e se il risultato è critico, 
il server deve "avvisare" tutti i client collegati su WebSocket (senza che loro abbiano chiesto nulla)
o anche altri componenti del sistema.

Avendo però introdotto il ruolo del framework come **inbound adapter**,
il livello applicativo potrebbe essere attivato anche da un timer o uno scheduler interno.

Si prospetta quindi un nuovo modo di vedere le cose:

**non è il sistema che "aspetta" Javalin, è Javalin che "serve" il sistema**

Siamo alle soglie della possibile trasformazione del sistema ``S`` in un 'organismo'
che ha i suoi propri obiettivi e  comportamenti (*proattivi*) e le sue 
capacità di 'interazioni sociali' (*reattive*).

Nei prossimi capitoli cercheremo di affrontare il progetto di sistemi di questo tipo. 

Prima però, faremo un ulteriore passo nella direzione 
per cui *javalin* sia **solo un supporto** alle esigenze applicative e non il vincolo
che stabilsce come è organizzata l'architettura del sistema.

Questo significa partire dai **requsiti applicativi** e selezionare (non adottare a priori)
le tecnologie ritenuti più adeguate per raggiungere gli obiettivi voluti.

====================================================
Interaction
====================================================


Nel capitolo precedente, abbiamo visto come utilizzare il framweork *javalin* pre costruire un sistema
che rende disponibile via rete un servizio di calcolo rappresentato da una funzione (*eval*).

Abbiamo fatto esempi di :ref:`Uso del sistema in JS` in cui i messaggi applicativi di richiesta
da inviare su WS o su HTTP erano, nel caso di WS, semplici stringhe 
o, nel caso HTTP, dati espressi in json.

Ancora una volta a dettare le 'regole del gioco' della comunicazione è il framework.
Al termine del capitolo, abbiamo prospettato l'idea che un framwework per le comunicazioni di rete
sia **solo un supporto** alle esigenze applicative e non il vincolo
che stabilsce come è organizzata l'architettura del sistema.

Un **primo passo** in questa direszione consiste nel pensare a un protocollo di comunicazione 
(``TCP, HTTP, UDP, CoAP, WS, BTH``, etc.) come puro trasportatore di informazioni, la cui struttura 
è fissata dal livello applicativo.

L'idea è di vedere un messaggio come una sorta di "carico standardizzato" , come un *container*
nel trasporto merci, che può viaggiare su nave, treno, camion, etc.. 
Questo messaggio-container ha sempre la stessa forma e le stesso proprietà, indipendemente dal mezzo di trasporto.
Nel massaggio inseriamo informazioni, come il nome del mittente e del destinatario,
che corrispondono a una sorta di 'metadati' capaci di rendere il messaggio **autoconsistente**.

Notiamo che nei messaggi usati negli esempi *javalin* non ci sono indicazioni esplicite del mittente e del destinatario,
essendo queste conoscenze legate agli 'endpoint' delle connessioni punto-a-punto stabilite dai protocolli.
Protocolli punto-a-punto come TCP, HTTP, CoAP, etc. sono in grado di stabilire una connessione stabile sulla quale inviare 
e ricevere messaggi. 

.. note::

  Il protocollo UDP non stabilisce una connessione, 
  ma può comunque essere usato per inviare messaggi e ricevere risposte.

Un **secondo passo** verso il ribaltamento da bottom-up a top-down consiste nell'introdurre a livello applicatovo 
l'idea di 'connessione' di comunicazione come una astrazione, che, in informatica, viene spesso
denominata "Link" o "Channel". Noi chiameremo questa astrazione :ref:`Interconnessione`.

L'idea è che la **logica applicativa** non dovrebbe sapere se ci sono bit che stanno viaggiando
su un cavo seriale, un pacchetto CoAP o un frame WebSocket. 
Essa dovrebbe solo sapere che esiste una *Interconnessione* capace di fornire azioni logiche   fondamentali
per l'invio e la ricezione delle informazioni espresse come messaggi-container.

.. _unibo.basicomm23-1.0:

--------------------------------------
unibo.basicomm23-1.0
--------------------------------------

Introduciamo subito una formalizzazione di queste idee mediante interfacce e classi Java, incluse, tra molte altre,
nella libreria  **unibo.basicomm23-1.0**. Ecco una sintesi:

.. list-table:: 
  :widths: 55,45
  :width: 100%

  * - Interfaccia standard dei messaggi   
    - :ref:`unibo.basicomm23.interfaces.IApplMessage<IApplMessage>` 
  * -  Classe di implementazione dei messaggi  
    - :ref:`unibo.interaction.msg.ApplMessage<ApplMessage>` 
  * - Interfaccia per la interazione  
    - :ref:`unibo.basicomm23.interfaces.Interaction<Interface Interaction>`
  * - Classe astratta per la implementazione di :ref:`Interaction<Interface Interaction>`   
    - :ref:`unibo.basicomm23.utils.Connection<Connection>` 
  * - Factory per la creazione di connessioni :ref:`Interaction<unibo.basicomm23.interfaces.Interaction>`   
    - :ref:`unibo.basicomm23.utils.ConnectionFactory<ConnectionFactory>` 

..  * -  Interfaccia per gli oggetti di gestione dei messaggi ricevuti
    - :ref:`unibo.basicomm23.interfaces.IApplMsgHandler` 

.. , realizzato  da un oggetto che implementa l'interfaccia :ref:`unibo.basicomm23.interfaces.Interaction`.

.. _Tipi di messaggi:

------------------------------------------------
Tipi di messaggi
------------------------------------------------

I messaggi applicativi hanno una forma comune, ma possono riferirsi a diversi tipologie, 
a ciascuno dei quali 
corrisponde una precisa forma di 'legame' tra chi lo emette e chi lo riceve, ricordando
quanto detto in  :ref:`La interazione come vincolo`.

.. list-table::
  :widths: 75,25
  :width: 100%

  * - 
       .. code::

          enum ApplMessageType{ 
            event, dispatch, request, reply, invitation}``

      - **dispatch**: un messaggio inviato a un preciso destinatario senza attesa di una risposta 
        (il modo detto **fire-and-forget** in :ref:`La interazione come vincolo`);
      - **invitation**: un messaggio inviato a un preciso destinatario aspettandosi un 'ack' 
        da parte di questi;
      - **request**: un messaggio inviato a un preciso destinatario aspettandosi da parte di questi una **reply**
        logicamente correlata alla richiesta;
      - **event**: un messaggio inviato a chiunque sia in grado di elaborarlo.
    - .

      .. image:: ./_static/img/legendMessages.png
          :align: center
          :width: 80%


.. _IApplMessage:


++++++++++++++++++++++++++++++++++++++++++++
IApplMessage
++++++++++++++++++++++++++++++++++++++++++++

*IApplMessage* la interface Java che ogni  messaggio applicativo deve implementare .


.. code::

    public interface IApplMessage {
    //selettori
        public String msgId();
        public String msgType();
        public String msgSender();
        public String msgReceiver();
        public String msgContent();
        public String msgNum();
    //predicati
        public boolean isDispatch();
        public boolean isRequest();
        public boolean isReply();
        public boolean isEvent();

        public String toJsonString();

        public void setConn( Interaction conn );
        public Interaction getConn(   );
    }  

.. _ApplMessage:

++++++++++++++++++++++++++++++++++++++++++++
ApplMessage
++++++++++++++++++++++++++++++++++++++++++++

ApplMessage è la classe che implementa i messaggi applicativi. Ne riportiamo qui i costruttori:

.. code::
  
     public class ApplMessage implements IApplMessage {
     //Costruttori
     public ApplMessage(
            String MSGID, String MSGTYPE, String SENDER, String RECEIVER,
            String CONTENT, String SEQNUM, Interaction conn ){...}
     public ApplMessage( String m ) { ... }
        //m: msg( MSGID, MSGTYPE, SENDER, RECEIVER, CONTENT, SEQNUM )
        //oppure: Rappresentazione dei messaggi in JSON
        ... 
     }

.. note::

    Se le astrazioni di messaggio-container  :ref:`IApplMessage` e di :ref:`Interconnessione` sono 
    utili e anche 'potenti', perché *Javalin* o altri framework non la introducono?

    Ci sono due ragioni fondamentali:

    #. **Overhead**: Creare oggetti *IApplMessage* consuma più memoria rispetto a una stringa grezza.
    #. **Capacità specifiche**: Alcuni protocolli hanno funzioni uniche (es. il Multicast di CoAP o gli Header di HTTP) 
       che vengono "nascoste" e perse nella parte sommersa di un'astrazione generica.

    Tuttavia, per sistemi dove la chiarezza e la proattività sono prioritari rispetto alla performance estrema, 
    questa impostazione può rivelarsi una scelta corretta per rendere il livello applicativo **tecchnology-independent**
    e per privilegiare le fasi di analisi dei problemi e di progettazione del software.

.. _msgsAsString:

+++++++++++++++++++++++++++++++++++++++++++++++++
Rappresentazione dei messaggi come String
+++++++++++++++++++++++++++++++++++++++++++++++++

Come ogni classe Java, *ApplMessage* definisce anche un metodo **toString** che restituisce una rappresentazione dei 
messaggi in forma di semplice stringa:

 

``msg( MSGID, MSGTYPE, SENDER, RECEIVER, CONTENT, SEQNUM )``

ove:

.. list-table:: 
  :widths: 45,55
  :width: 100%

  * - 
      - MSGID:    identificativo del messaggio
      - MSGTYPE:  tipo del msg 
      - SENDER:   nome del componente che invia  
      - CONTENT:  contenuto applicativo (payload)  
      - RECEIVER: nome del componente chi riceve  
      - SEQNUM:   numero di sequenza  
    
    - La rappresentazione in forma di String dei messaggi segue (per motivi che approfondiremo) 
      le regole della **sintassi Prolog**. In particolare:

      - gli identificatori MSGID,SENDER,RECEIVER sono espressi da atomi Prolog formati da lettere minuscole;
      - MSGTYPE è un atomo prefissato: **dispatch, request, reply, event** (non è implementato **invitation**);
      - CONTENT è un termine Prolog;
      - SEQNUM è una stringa che rappresenta un intero.
 
.. note::

  **A cosa serve SEQNUM**

  In un sistema proattivo, il livello applicativo potrebbe inviare molti messaggi in rapida successione. 
  
  Senza un SEQNUM:

  - Il client non saprebbe se ha perso la "Notifica #4" mentre leggeva la "Notifica #5".
  - Non si potrebbero implementare logiche di Acknowledge (ACK),
    dove il destinatario conferma: "Ho ricevuto correttamente fino al messaggio 102".


.. _Rappresentazione dei messaggi in JSON:

+++++++++++++++++++++++++++++++++++++++++++++++++
Rappresentazione dei messaggi in JSON
+++++++++++++++++++++++++++++++++++++++++++++++++

Il metodo  **toJsonString** di ApplMessage restituisce la rappresentazione di un :ref:`IApplMessage` in formato JSON.
Ad esempio:


.. code::

  var msgtosend =
  '{"msgId":"eval", "msgType":"request","msgSender":"client",
    "msgReceiver":"server", "msgContent":"4.0", "msgNum":"0"}'  


+++++++++++++++++++++++++++++++++++++++++++++++++
Esempi di uso in JS  
+++++++++++++++++++++++++++++++++++++++++++++++++

Package **main.java.javalin**:

Introduciamo una versione del sistema che gestisce solo messaggi 
ricevuti in forma di :ref:`Rappresentazione dei messaggi in JSON`:
**SistemaSJavalinBetterApplMsgs.java**.

Esempi di caller Javascript:

- **CallerBasicApplMsgLazy.html**: invia su WS e HTTP messaggi 
  di richiesta a esecuzione 'lazy' espressi in JSON.
- **CallerBasicApplMsgFast.html**: invia su WS e HTTP messaggi 
  di richiesta a esecuzione 'fast' espressi in JSON.

+++++++++++++++++++++++++++++++++++++++++++++++++
Esempio di uso in Java  
+++++++++++++++++++++++++++++++++++++++++++++++++

Riportiamo anche un client scritto in Java (package **main.java.javalin**).

.. note::

  - La libreria **org.java_websocket** è bloccante/sincrona nella gestione della connessione (usa i thread classici).
  - La libreria **java.net.http.WebSocket**, inglobata nel JDK da *Java11* è asincrona (usa i `CompletableFuture Java`_)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
CallerWsApplMsgs: l'organizzazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


.. list-table:: 
    :widths: 70,30
    :width: 100%

    * - 
        .. code::

          import java.util.concurrent.CountDownLatch;
          import org.java_websocket.client.WebSocketClient;
          import org.java_websocket.handshake.ServerHandshake;
          ...

          /*1*/public class CallerWsApplMsgs {
          /*2*/private IApplMessage msg=
            CommUtils.buildRequest("client","eval","4.0","server");
          /*3*/private WebSocketClient client;
          /*4*/private CountDownLatch latch=new CountDownLatch(1); 

            public CallerWsApplMsgs(URI serverUri) {
          /*5*/client = new WebSocketClient(serverUri){
            //Event handlers
            }
            ...
            doJob();
          }
 
          /*6*/public void doJob() {
                try {
          /*7*/  client.connect();
          /*8*/  while ! client.isOpen()){CommUtils.delay(100);}

          /*9*/  client.send(reqmsg.toJsonString());
          /*10*/ latch.await();
          /*11*/ client.close();
                } catch (Exception e) { ... }
              }//doJob
 
      - 
        #. Classe che include un client di tipo WebSocketClient
        #. Definizione del messaggi di richiesta
        #. Dischiarazione di un client WS
        #. **Latch** (con valore **1**) per evitare che il programma termini prima di ricevere la unica risposta.
        #. Creazione del client con specifica dei metodi **Event Handlers** (o **Lifecycle Hooks**)
        #. Metodo che realizza il comportamento del client applicativo
        #. Creazione della connessione con il server
        #. Attesa che la connessione sia completata
        #. Invio del messaggio di richiesta
        #. Attesa della risposta
        #. Chiusura della connessione

.. note::

  Internamente, un `CountDownLatch`_ usa un componente chiamato **AQS** (*AbstractQueuedSynchronizer*)
  che funziona come segue:

  - Al suo interno c'è un numero intero (quello che passi nel costruttore).
  - Quando si chiama **await()**, il latch controlla: "Il contatore è zero?"

    - Se NO, mette il thread in una coda di attesa e lo "addormenta".
    - Se SÌ, lascia passare il thread come se fosse un semaforo verde.
  - Quando un altro thread (quello del WebSocket) chiama **countDown()**, il numero scende. 
     Se arriva a zero, il latch invia un segnale di "sveglia" a tutti i thread che erano fermi sull'*await()*.
  
  Nel caso si dimentichi **countDown()**, il programma rimane bloccato per senpre.  Per evitare questo,
  meglio usare una verdsione con timeout:
  
  .. code::

    boolean successo = latch.await(10, TimeUnit.SECONDS);
    if (!successo) {
        System.out.println("Timeout: il server non ha risposto in tempo.");
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
CallerWsApplMsgs: la parte client
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table:: 
    :widths: 65,35
    :width: 100%

    * - 
        .. code::
 
           client = new WebSocketClient(serverUri){

            //Event handlers
            @Override
            /*1*/public void onOpen(ServerHandshake data) {
              System.out.println("Connessione aperta!");
            }
            @Override
            /*2*/public void onMessage(String message) {
              try {
                IApplMessage msg = new ApplMessage(message);
                CommUtils.outmagenta(reply ricevuto:" + msg);
                if (msg.isReply()) latch.countDown();
              } catch (Exception e) {
                CommUtils.outgreen("onMessage: " + message);
              }
            }
            @Override
            public void onMessage(ByteBuffer message) {
              System.out.println(" ByteBuffer ricevuto! ");
            }
            @Override
            /*3*/public void onClose(
                    int code, String reason, boolean remote) {
              System.out.println("Connessione chiusa: " + reason);
            }
            @Override
            public void onError(Exception ex) {
              System.err.println("Errore:"+ex.getMessage());
            }
            };
            
  
      - Gli **Event handlers** sono metodi di callback, invocati dalla libreira *org.java_websocket*:

        #. alla apertua della connessione 
        #. alla ricezione di un messaggio inviato dal server sulla WS 
        #. alla chiusra della connessione


La logica applicativa del client è inclusa nella callback **onMessage**. Poichè questa callback viene invocata
ad ogni messaggio inviato dal server, essa mostra il messaggio così come arriva nel caso 
non sia possibile convertirlo in un :ref:`ApplMessage`.
Se si tratta di un :ref:`ApplMessage`, allora, nel caso sia la **reply** attesa, si decrementa di 1 il **latch**, 
permettendo la terminazione del client appplicativo.



**Ancora troppe dipendenze tecnologiche**

La complicazione dell'impianto di codice che sempre accompagna le interazioni asincrone e il fatto 
che queste forme complicate variano da libreria a libreria e da protocollo a protcollo,
ci induce a intraprendere il **secondo passo** di cui abbiamo parlato: 

- un componente software che intende 
  comunicare con un altro componente, dovrebbe farlo senza doversi preoccupare dei dettagli 
  del trasporto e delle sue forme peculiari (sincrono, asincrono, con callback ttadizionali, 
  etc.)
  focalizzando l'attenzione solo sulla :ref:`logica della comunicazione<La Interazione come vincolo>`.

Introduciamo quindi un nuovo concetto: quello di :ref:`Interconnessione`.


.. _Interconnessione:

------------------------------------------
Interconnessione
------------------------------------------

Usiamo il termine *Interconnessione* per denotare l'idea astratta di un canale logico di comunicazione (bidirezionale) tra due 
o più componenti software (end-points).


.. _Connection:

++++++++++++++++++++++++++++++++++++++++++++
Connection
++++++++++++++++++++++++++++++++++++++++++++

Formalizziamo in Java il concetto di *Interconnessione* introducendo una classe astratta che cattura aspetti generali 
implementabili con ciascuono dei :ref:`Protocolli` citati.

.. code::

  public abstract class Connection implements Interaction{
    ...
  }

.. _Interface Interaction:

------------------------------------------
Interface Interaction
------------------------------------------

Le operazioni di invio-ricezione di messaggi relative all'astrazione :ref:`Interconnessione` 
sono divise in due insiemi, ciascuno dei quali include
funzioni con lo stesso nome ma con signature diversa, legata ai tipi di messaggi scambiati:
String non meglio specifiate (**Interaction2021**) o :ref:`IApplMessage` (**Interaction2023**).

 

.. code::
  

  public interface Interaction extends Interaction2021, Interaction2023{
  }

  public interface Interaction2021  {	 
    public void forward(  String msg ) throws Exception;
    public String request(  String msg ) throws Exception;
    public void reply(  String reqid ) throws Exception;
    public String receiveMsg(  ) throws Exception ;
    public void close( )  throws Exception;
  }

  public interface InteractionBasic {
    public void forward(  IApplMessage msg ) throws Exception;
    public IApplMessage request( IApplMessage msg ) throws Exception;
  }

  public interface Interaction2023 extends InteractionBasic{
    public IApplMessage request(  IApplMessage msg, int tout ) throws Exception;
    public void reply(  IApplMessage msg ) throws Exception;
    public IApplMessage receive(  ) throws Exception ;
    public void close( )  throws Exception;
  }

.. _InteractionBasic:

++++++++++++++++++++++++++++++++++++++++++++++
InteractionBasic
++++++++++++++++++++++++++++++++++++++++++++++

L'interfaccia **InteractionBasic** esprime le operazioni fondamentali che usermo in alcuni esempi 
che seguono. 

- Il metodo **request** esprime una intereazione che blocca il chiamante in attesa della risposta.
- Il metodo **forward** è di tipo :ref:`fire-and-forget<:ref:`La Interazione come vincolo>`; 
  tuttavia, se il messaggio inviato è di tipo *request*,
  allora il chiamante si aspetta di ricevere (in futuro, sulla connessione usate per la request) una **reply** 
  alla sua richiesta.

La liobreria :ref:`unibo.basicomm23-1.0`  definisce diverse classi che specializzano  
la classe astratta *Connection*, ciascuna in relazione ad uno specifico protocollo.

.. _Protocolli:

+++++++++++++++++++++++++++++++++++++++++++++++
Protocolli
+++++++++++++++++++++++++++++++++++++++++++++++

.. code::
  
   enum ProtocolType {  http, ws, tcp, udp, coap, mqtt, bluetooth, serial } 

.. Ad ogni protocollo corrisponde una classe che specializza *Connection* realizzando l'insieme 
   di operazioni di comunicazione definire dalla :ref:`Interaction`. In particolare:

Le classi spcecializzate che usermo più di frequente sono:

- HttpConnection: per http
- WsConnection: per ws
- TcpConnection: per tcp
- CoapConnection: per coap
- MqttInteraction: per mqtt

.. _ConnectionFactory:

++++++++++++++++++++++++++++++++++++++++++++
ConnectionFactory
++++++++++++++++++++++++++++++++++++++++++++

La classe  **ConnectionFactory** è una factory relativa alle costruzione delle diverse classi concerete.

.. list-table:: 
    :widths: 45,55
    :width: 100%

    * - 
        .. code::

          public class ConnectionFactory{
            ...
          public static Interaction
            createClientSupport( 
              ProtocolType protocol,
              String host,String entry ){
            try {
              switch( protocol ){
                case http  : {...}
                case ws    : {...}
                case tcp   : {...}
                case udp   : {...}
                case coap  : {...}
                case mqtt  : {...}
                case serial : {...}
                case bluetooth : {...}
            }
            ...
          }//ConnectionFactory
      
      - La coppia di argomenti ``String host, String entry`` è specifica per goni protocollo

        - **http**:host="localhost:8080" entry=-
        - **ws**:  host="localhost:8080" entry="eval"
        - **tcp**: host="localhost" entry="8080"
        - **udp**: host="localhost" entry="8080"
        - **coap**:host="localhost" entry="8080"
        - **mqtt**:: host"brokerip" entry="In-Out"



----------------------------------------------------
Nuove impostazioni progettuali
----------------------------------------------------


La libreria :ref:`unibo.basicomm23-1.0` fornisce classi che supportano le *nuove astrazioni* 
introdotte in questa sezione:

- il concetto di messaggio applicativo autocomtenuto (classi :ref:`IApplMessage` e :ref:`ApplMessage`)
- il concetto di Interconnessione implemnetabile su diversi :ref:`Protocolli`

La disponibilià di queste astrazioni pemette di 'penasare ai problemi' e alla loro soluzione in modo più vicino 
alle esigenze logiche dell'applicazione. 

Riprendendo, ad esempio, quanto detto in :ref:`La Interazione come vincolo`, ridefiniamo il *sistemaS* in modo che operi

- sia come **gestore di richieste**
- sia come **emettitore di eventi**, che siano perceibili e gestibili da **tutti i client** collegati al sistema.

Naturalmente occcorre anche fare in modo che la **reply** a una **request** venga inviata solo 
al client che ha fatto la richiesta.

Il ``sistemaS`` si presenta dunque agli occhi dei suoi osservaori ``Obs`` sia reattivo (in quanto risponde a un richiesta)
sia proattivo (in quanto può inviare informazioni ai client senza alcuna richiesta da parte loro).

.. _Refactoring del sistemaS:

-----------------------------------------------
Refactoring del sistemaS
-----------------------------------------------

Facciamo ora una più chiara separazione tra *javalin* inteso come *Inbound Adapter* e 
il livello applicativo, associando alla  *logica applicativa*
**un processo autonomo** che reagisce alle richieste in input ed emette risposte e/o eventi.

La **nuova architettura logica** del sistena è rappresentata nella figura che segue:


.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .

        .. image:: ./_static/img/JavalinAndWorker.png
            :align: center
            :width: 100%    
    
    
      - Il processo **ApplLogicWorker** è dotato di una coda di input **applMsgQueue**
    
        - su cui *javalin* deposita i messaggi applocativi
          ricevuti via rete, **senza elaborarli** in alcun modo
        - da cui preleva i messaggi in sequenza man mano arrivano,
          elaborando ciascuno di essi e, nel caso di request, inviando 
          la risposta al client richiedente

Con questa nuova architettura (``Molti thread TX Javalin -> Una Coda ->  Un thread applicativo TA``), 
stiamo fondamentalmente replicando il modello 
di **Node.js** in Java, con la possibilità di attivare, se ritenuto il caso, più worker applicativi.

.. note::

  Notiamo che con i **Virtual Threads** di *Java21*, si possono avere moltissimi thread TX che aspettano messaggi WebSocket 
  consumando pochissima memoria. Questi thread 'leggerissimi' convogliano i messaggi verso il thread *ApplLogicWorker*
  garantendo (si veda quanto detto in :ref:`Come opera javalin`):

  - assenza di synchronized
  - assenza di corse critiche
  - ordine di elaborazione garantito


++++++++++++++++++++++++++++++++++++++++++++++++
Dalla logica al progetto
++++++++++++++++++++++++++++++++++++++++++++++++

L'idea di convogliare i messaggi che giungono al sistemaS ad un unico processo di elaborazione applicativo
si può concretizzare in diverso modi. 
A ciascuno di questi modi corrisponde uno   **specifico progetto** di costruzione del sistema che conduce 
a un diversa struttura del codice e a diversi modi di trasferire comportamenti nel 'livello sommerso' 
del sistema.

Noi esamineremo due diverse modalità di passaggio dal livello logico al livello realizzativo:

- un modo **esplicito**, in cui  *applMsgQueue* e *ApplLogicWorker* sono introdotti 'in chiaro' nel codice  
- un modo **implicito**, in cui la coda e il worker sono realizzati (senza che si vedano) mediante i 
  :ref:`Java Executors`,
  che costituiscono il supporto più adguato per ridurre l'abstraction gap 
  tra ciò che vogliamo realizzare e la tecnologia.


In questa sezione  procedermo con il **modo esplicito**, mentre una soluzione basata sui Java Executors
verrà introdotta per realizzare, nella sezione successiva, il microframework 
:ref:`AbstractProtoactor` , un primo prototipo di supporto per gli 
:ref:`attori<Gli attori come nuovo paradigma?>`.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Analisi di come gestire i messaggi request
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Prima di procedere occorre però un approfondimento della **analisi del problema** in relazione ai diversi 
tipi di messggio da eleborare.

- messaggi di tipo **dispatch** ed **event** devono essere solo 'consegnati' al processo applicativo *ApplLogicWorker* 
  perchè siano gestiti;
- messaggi di tipo **request** implicano che, dopo la loro gestione da parte di *ApplLogicWorker* (TA), venga inviata
  una **reply** al componente richiedente, sulla stessa connessione usata per la richiesta.

Il problema è dare al processo applicativo *ApplLogicWorker* informazione 
relativa alla connessione su cui è giunta la richiesta, in modo che,
terminata la elaborazione del messaggio, il processo applicativo possa inviare la
**reply** sulla connessione giusta.

Come analisti, sappiamo che Java propone un meccanismo utile allo scopo legato alla interfaccia `CompletableFuture Java`_. 
Diamo qui alcune indicazioni utili per il progettista.

.. _CompletableFuture:

++++++++++++++++++++++++++++++++++++++++++++++
CompletableFuture
++++++++++++++++++++++++++++++++++++++++++++++

Java8 introduce la classe *CompletableFuture* che implementa l' interfaccia *Future* in modo che si possa utilizzarla 
come implementazione *Future* ma con logica di completamento aggiuntiva.

- Una istanza di questa classe, con costruttore senza argomenti rappresenta
  un risultato futuro.
- Distribuiamo l'istanza al processo di elaborazione, che la completarà in un momento futuro 
  utilizzando il metodo **complete**.
- Il metodo **thenAccept** può essere usato per eseguire una azione quando
  verrà fornito questo risultato.

Il thread (TX) attivato da Javalin alla ricezione di un messaggio, può operare come segue:

.. code::

    ws.onMessage(ctx -> { 
      IApplMessage am = readInputWS( ctx.message() );
      if( am.isRequest() ) {
    /*1*/CompletableFuture<IApplMessage> responseFuture = new CompletableFuture<>();
    /*2*/responseFuture.thenAccept(res -> {
          System.out.println("server invia risposta:" + res );
          String ss = res.toJsonString();
          ctx.send(ss); // Viene eseguito quando TA completa la promise
        }).exceptionally(ex -> { ctx.send("Errore!"); return null; });
        //Ci potrebbe essere anche un timeout ...
    /*3*/WorkTask wt = new WorkTask( am, responseFuture );        	
    /*4*/applMsgQueue.add( wt );  
      }else if ( am.isDispatch() || am.isEvent()) {
    /*5*/WorkTask wt = new WorkTask( am, null ); 
        applMsgQueue.add( wt ); 
      }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Nel caso di **request**
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#. Creazione di un **CompletableFuture**
#. Definizione delle azioni da eseguire quando il risultato sarà disponibile.
   
   La **lambda** ``res -> { ... ctx.send(...)}`` "cattura" l'oggetto *ctx*. Anche se il thread TX finisce 
   il suo lavoro e torna nel pool di Jetty, 
   la lambda rimane "viva" dentro l'oggetto ``responseFuture``, portando con sé il riferimento 
   alla connessione corretta.
#. Creazione di una struttura dati (record :ref:`WorkTask`) che associa il messaggio alla connessione
#. Inserzione di WorkTask nella coda di  *ApplLogicWorker* (TA)

Quando il thread applicativo (TA) chiama **complete** sulla future 
(dopo avere gestito un WorkTask: si veda più avanti :ref:`doelabaRequest`):

- La future passa dallo stato "In attesa" allo stato "Completato".
- Il sistema vede che c'era una funzione registrata con **thenAccept**.
- Viene eseguita immediatamente il corpo della **lambda**.

.. note::

  - E' lo stesso thread TA ad eseguire anche il codice dentro *thenAccept*.
    ``ctx.send(..)`` in Javalin è un'operazione molto veloce e thread-safe, 
    e non rallenta il thread applicativo, garantendo
    che la risposta parta istantaneamente.

  - Possiamo usare ``completeExceptionally(ex)`` per inviare un messaggio di errore al client 
    invece del risultato. 
  - E' anche possibile specificare azioni allo scadere di un timeout.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Nel caso di **dispath** o **event**
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

5. Il :ref:`WorkTask` non porta con sè alcuna *CompletableFuture*.

.. _WorkTask:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il record WorkTask
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code::

      private record WorkTask(
          IApplMessage message, 
          CompletableFuture<IApplMessage> future 
      ) {}

.. note::

  I `Java record`_  sono una funzionalità introdotta con ``Java16``.
  Rappresentano una forma ristretta di classe, progettata specificamente per fungere da "contenitore di dati" 
  (**Data Carrier**) immutabile, eliminando quasi tutto il codice ripetitivo (**boilerplate**) tipico dei POJO.

 


.. _Un progetto esplicito:

----------------------------------------------
Un progetto esplicito
----------------------------------------------

Tenendo conto di quanto detto in fase di analisi,
la coda **applMsgQueue** può essere definita come segue: 

.. code::

    lockingQueue<WorkTask> applMsgQueue = new LinkedBlockingDeque<WorkTask>(50)
    //il dimensionamento della coda a 50 andrebbe discusso ...

.. _SistemaSJavalApplMsgsQueued:

+++++++++++++++++++++++++++++++++++++++++
SistemaSJavalApplMsgsQueued
+++++++++++++++++++++++++++++++++++++++++

La classe che definisce la nuova versione del sistema implementa :ref:`InteractionBasic` per consentire  
inserzione diretta nella coda *applMsgQueue*, nel caso si voglia 
interagire con il componente senza l'uso della rete. Si veda :ref:`Interazioni locali`.

.. list-table:: 
    :widths: 60,40
    :width: 100%
 
    * -
         .. code::

            public class SistemaSJavalApplMsgsQueued 
                              implements InteractionBasic{
            /*1*/protected  static Vector<WsConnectContext>  
                  allConns=new Vector<WsConnectContext>();
            /*2*/protected BlockingQueue<WorkTask>  
                  applMsgQueue=
                      new LinkedBlockingDeque<WorkTask>(50);
              ...
            /*3*/ ...
            }
      - 

        #. Lista di tutte le connessioni attive (si veda :ref:`ws.onConnect`)
        #. Coda di input per la logica applicativa (si veda :ref:`Worker thread`)
        #. Codice strutturato come in :ref:`SistemaSJavalinBetter`
 

.. _ws.onConnect:

++++++++++++++++++++++++++++++++++++++++++++
SistemaSJavalApplMsgsQueued ws.onConnect
++++++++++++++++++++++++++++++++++++++++++++

La gestione di una nuova connessione consiste nell'aggiungere la conessione alla lista 
**allConns**, che viene usata da **emitInfo** per inviare informazioni a tutti i client collegati.

.. list-table:: 
    :widths: 65,35
    :width: 100%
 
    * -
         .. code::

            /*1*/protected  static Vector<WsConnectContext> allConns = 
                    new Vector<WsConnectContext>();
             ...
            /*2*/ws.onConnect(ctx -> {         	
            /*3*/ allConns.add(ctx);
            /*4*/ emitEvent("welcome",ctx);
            /*4*/ emitInfo("new connection established");
                 });
            });//onConnect
      - 

        #. Lista di tutte le connessioni attive
        #. Handler di gestione di una nuova connessione
        #. Aggiunta della connessione alla lsita 
           (la rimozione viene fatta in **ws.onClose**)
        #. Invio di un evento al client: :ref:`emitEvent`
        #. Invio di un evento a tutti i client attivi: :ref:`emitInfo`



.. _SistemaSJavalApplMsgsQueued ws.onMessage:

++++++++++++++++++++++++++++++++++++++++++++
SistemaSJavalApplMsgsQueued ws.onMessage
++++++++++++++++++++++++++++++++++++++++++++

La gestione dei messaggi in input si limita ora ad aggiungere un **WorkTask** alla coda
di ingresso del Thread applicativo, come indicato in fase di analisi.

.. list-table:: 
    :widths: 70,30
    :width: 100%
 
    * -
         .. code::

            public class SistemaSJavalApplMsgsQueued{
            protected BlockingQueue<WorkTask> applMsgQueue = 
                    new LinkedBlockingDeque<WorkTask>(50);
              ...
 
            /*1*/ protected double eval(double x) {
                if (x > 4.0) { //Simulazione elab lazy
                    CommUtils.delay(10000);
                }
              return Math.sin(x) + Math.cos( Math.sqrt(3)*x);
              }

            /*2*/ws.onMessage(ctx -> {         	
            /*3*/emitEvent(ctx); //just to test

                 IApplMessage am = readInputWS(ctx.message());         	
            /*3*/CompletableFuture<IApplMessage> responseFuture= 
                          new CompletableFuture<>();
            /*4*/responseFuture.thenAccept(res -> {
            /*5*/   ctx.send(res.toJsonString()); 
                 });
            /*6*/WorkTask wt = new WorkTask(am,responseFuture);
            /*7*/applMsgQueue.add( wt );
            });//onMessage
      - 

        #. Funzione di calcolo che *simula calcoli lunghi* in ceri casi 
        #. Handler di gestione di un nuovo messaggio
        #. Emissione di un evento (per una demo)
        #. Creazione di una `CompletableFuture Java`_
        #. Pianifiicazione dell'azione da compiere quando il :ref:`Worker thread` ha elaborato la risposta
        #. Invio della risposta al client
        #. Creazione del record da inserire nella *applMsgQueue*
        #. Aggiunta del record *WorkTask* nella *applMsgQueue* 


**Il nuovo readInputWS**

I messaggi si suppongono ricevuti come stringhe Json.

.. code::

    protected IApplMessage readInputWS(String message) throws Exception{ 
      return ApplMessage.cvtJson(message);
    }

.. _emitEvent:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
emitEvent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Emmete informazione sulla connessione corrente su cui ha ricevuto il messaggio.

.. code::

    protected void emitEvent(String s, WsConnectContext ctx){
      String event = "{\"msg\" : \"EV\" }".replace("EV",s);
      ctx.send( event  ); 
    }

.. _emitInfo:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
emitInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 

Emmete informazione sul tutte le connessioni attive.

.. code::

    protected void emitInfo(String s) {
    	allConns.forEach( (conn) -> conn.send(s) );
    }


.. _Worker thread:

++++++++++++++++++++++++++++++++++++++++++++
Worker thread message-driven
++++++++++++++++++++++++++++++++++++++++++++

Tutta la logica applicativa può essere ora espressa da un thread che opera in modo 
**message-driven**, ignorando tutti i dettagli relativi alle comunicazioni di rete.

Il thread opera secondo il classico schema **read-evel-print**, e quindi è puramente 
'guidato' dal fluire dei messaggi in input. Tuttavia può inivare informazioni non richieste (eventi)
sulle connessioni attive.


.. list-table:: 
    :widths: 55,45
    :width: 100%

    * -
        .. code::

          protected void setApplLogicWorker() {
          /*1*/new Thread(() -> {
              while (true) {
              try {
          /*2*/ WorkTask wt = applMsgQueue.take(); 
          /*3*/IApplMessage inputMsg = wt.message;
                if( inputMsg.isRequest() ) {
          /*4*/    doelabRequest(inputMsg,wt );
                }else if( inputMsg.isDispatch() ) {
          /*5*/   elabDispatch(inputMsg);
                }
              } catch (Exception e) {...}
            }
          }).start();
          }
      - 
        #. Thread che esegue la logica applicativa
        #. Preleva un elemento dalla **applMsgQueue**, bloccandosi se non esiste
        #. Seleziona il messaggio ricevuto
        #. Invoca il meotodo dedicato alla gestione di una :ref:`request<Tipi di messaggi>` 
        #. Invoca il meotodo dedicato alla gestione di un :ref:`dispathc<Tipi di messaggi>` 

.. _doelabRequest:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
doelabRequest
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La elaborazione di una richiesta viene delagata al metodo *elabRequest*, che restituisce una :ref:`reply<Tipi di messaggi>` 
che viene inviata al client sulla connessione WS ad esso relativa

.. code::

    protected void doelabRequest(IApplMessage req, WorkTask wt ) {
    	IApplMessage replyMsg = elabRequest(req);
    	wt.future.complete(replyMsg);
    }

**elabRequest**   

Questo metodo definisce la logica applicativa di gestione di una richiesta,
costruendo una **reply**
senza sapere nulla di come e a chi inviare la risposta.

.. code::

    protected IApplMessage elabRequest(IApplMessage req  ) {
      double x      = Double.parseDouble(req.msgContent());
      double result = eval(x);
      IApplMessage replyMsg =
          CommUtils.buildReply("server", req.msgId(), "" + result,req.msgSender());
    	return replyMsg;
    }

**elabDispatch**  

Questo metodo definisce la logica applicativa di gestione di un *dispatch*.

.. code::

    protected void elabDispatch(IApplMessage m ) {
    	CommUtils.outblue("ApplLogicThread elabDispatch:" + m);
    }


.. I metodi **elabRequest** e **elabDispatch** sono la punta 


 
.. Non solo request-response
 
.. note::

  Utilizzando dispatch e eventi, il sistema può esseere capace
  di realizzare una chat tra più client.

+++++++++++++++++++++++++++++++++++++++++
Refactoring dei client
+++++++++++++++++++++++++++++++++++++++++

Nel package **main.java.javalin**:

.. list-table:: 
    :widths: 38,62
    :width: 100%

    * - ``CallerJavaApplMsgReqsynch.java``       
      - Componente che usa :ref:`ConnectionFactory` per creare una WsConnection 
        su cui invia una request in modo sincrono.
        Non ha capacità di ricevere informazioni dal server diverse dalla **reply** alla sua richiesta.
    * - ``CallerJavaApplMsgObserver.java``       
      - Componente che usa una  WsConnection  su cui invia una request in modo sincrono.
        Estende **unibo.basicomm23.utils.ApplAbstractObserver** per operare
        come observer dei messaggi non-reply (eventi) emessi dal server

..     * - ``CallerWsclientReqSlow.java``       
      - Componente che usa un WebSocketClient per inviare messaggi su una WebSocket
        e per elaborare i messaggi non-reply (eventi) emessi dal server.
        Usa un `CountDownLatch`_ per terminare


Ricordiamo anche i seguenti clienti HTML che usano messaggi definiti come strnghe JSono:

.. code::

    var msgfast = '{"msgId":"eval","msgType":"request","msgSender":"client",
                    "msgReceiver": "server","msgContent":"3.0","msgNum":"0"}'

    var msglazy = '{"msgId":"eval","msgType":"request","msgSender":"client",
                    "msgReceiver": "server","msgContent":"5.0","msgNum":"0"}'
 
.. list-table:: 
    :widths: 38,62
    :width: 100%

    * - ``CallerBasicApplMsgsFast.html``       
      - Codice JS che invia una stringa strutturata come un :ref:`ApplMessage` per il calcolo di
        un valore che il servizio effettua velocemente (*msgfast*)
        


    * - ``CallerBasicApplMsgsLazy.html``       
      - Codice JS che invia una stringa strutturata come un :ref:`ApplMessage` e per il calcolo di
        un valore che il servizio effettua lentamente
 
.. _Interazioni locali:

-------------------------------------------
Interazioni locali
-------------------------------------------

La classe dichiara di implementare la interfaccia :ref:`InteractionBasic`.
Essa deve quindi defiire metodi che permettono anche a un componente locale
(che gira nella stessa JVM) di inviare messaggi


.. code::

  public class SistemaSJavalApplMsgsQueued implements InteractionBasic{ 
    protected IApplMessage reply=null;
    ...
    @Override
    public void forward(IApplMessage msg) {
	    	WorkTask wt = new WorkTask( msg, null );        	     	
	    	applMsgQueue.add( wt );   	        	 
    }
    
    @Override
    public IApplMessage request( IApplMessage msg ) throws Exception{ 
      if( msg.isRequest() ) { //defensive
        CompletableFuture<IApplMessage> responseFuture = new CompletableFuture<>();
        WorkTask wt = new WorkTask( msg, responseFuture );        		     	
        applMsgQueue.add( wt );     		
        return responseFuture.get();
      }else throw new Exception("Msg not a request");
    };

     ...
  }
 
In questo modo è possibile inviare messaggi usando la memoria, senza dover fare ricorso alla rete.
Ad esempio (package **main.java.javalin**):

.. _CallerOnMemory:

+++++++++++++++++++++++++++++++++++++++++++
CallerOnMemory
+++++++++++++++++++++++++++++++++++++++++++

.. code::

    public class CallerOnMemory  {  
        private SistemaSJavalApplMsgsQueued server;
        
        public CallerOnMemory( ) {
          server = new SistemaSJavalApplMsgsQueued();
        }
        
        public void doJob() {
          CommUtils.outblue("doJob  ...");
          String startMsg = "msg(cmd,dispatch,callerinmem,server,start,0)";
    /*1*/ server.forward(new ApplMessage(startMsg));
              
    /*2*/ new Thread() {	
    	   public void run() {
    		   try {
    			   String reqMsg = "msg(eval,request,callerinmem,server,5.0,0)";
    			   IApplMessage answer = server.request(new ApplMessage(reqMsg));
    			   CommUtils.outblue("answer=" + answer);
    		   } catch (Exception e) { e.printStackTrace(); }
    	   }
       }.start();
          
    /*3*/ new Thread() {
            public void run() {
              try {
                String reqMsg = "msg(eval,request,callerinmem,server,4.0,0)";
                IApplMessage answer = server.request(new ApplMessage(reqMsg));
                CommUtils.outgreen("answer=" + answer);
              } catch (Exception e) { e.printStackTrace(); }
            }
          }.start();
         
        public static void main(String[] args) {
          System.out.println("Java.version="+ System.getProperty("java.version"));
          new CallerOnMemory( ).doJob();
        }
    }

Il caller :

.. s#. invia un dispatch al server, e, usando :ref:`Java Executors`:
#. lancia un thread per la richiesta di un valore che richiede un tempo lungo di elaborazione
#. lancia un thread per la richiesta di un valore che richiede un tempo breve di elaborazione

Come risposte, si vede per prima quella relativa alla elaborazione con tempo breve:

.. code::

    server | invia risposta a eval4.0=msg(eval,reply,server,callerinmem,0.042286496169391286,0)
    answer=msg(eval,reply,server,callerinmem,0.042286496169391286,0)
    ...
    server | invia risposta a eval5.0=msg(eval,reply,server,callerinmem,-1.6806362513254687,1)
    answer=msg(eval,reply,server,callerinmem,-1.6806362513254687,1)

 


-----------------------------------------------
Un servizio per comunicazioni pub/sub
-----------------------------------------------

Fino ad ora abbiamo assunto che l'unico modo di comunicare con il sistemaS sia l'uso di un protcollo punto-a-punto
(WS o HTTP). 

Ma la tecnologia rende disponibili anche forme di interconnessione di tipo publish-subsribe basate su protcolli
come MQTT e su servizi detti **MQTT-broker**. Qui si disnguono due livelli di comunicazione:

- **Livello di Trasporto** (*Punto-a-Punto*): Si stabilisce una connessione tramite TCP o WebSocket) on il Broker. 
- **Livello Applicativo** (*Publish-Subscribe*): Una volta connessi , si 'parla' **attraverso il Broker** usando i **Topic**.

Una **Topic** è una sorta di 'etichetta' (ad es.``sensori/temperatura``) su cui chi è interessato a trasmettere
informazioni fa una **pubblish** e chi è interessato a ricevere fa una **subscribe**.

Per effettuare operazioni publish/subscribe usando un Broker MQTT, usiamo la liberia **org.eclipse.paho.client.mqttv3** 
che contiene la classe **MqttClient**. Ad esempio:

.. (oppure usiamo  *HiveMQ Client*).

  
.. code::

    // Connessione Punto-a-Punto al Broker
    MqttClient client = new MqttClient("tcp://broker.hivemq.com:1883", "ClientID");
    client.connect();

    // Comunicazione Pub/Sub
    client.subscribe("sistemaS/risposte", (topic, msg) -> {
        System.out.println("Ricevuto in modo asincrono: " + new String(msg.getPayload()));
    });

    client.publish("sistemaS/richieste", new MqttMessage("4.0".getBytes()));

MQTT è un sistema asincrono - publisher e subscriber sono indipendenti

- Il Publisher può pubblicare anche se nessuno è in ascolto (nessun errore)
- Il Subscriber riceverà solo i messaggi pubblicati dopo la sua sottoscrizione

  ECCEZIONE: se i messaggi sono pubblicati con opzione **retained=true**, 
  il Subscriber riceverà l'ultimo messaggio retained anche se pubblicato prima



++++++++++++++++++++++++++++++++++++++++++++++++
MqttConnectOptions
++++++++++++++++++++++++++++++++++++++++++++++++

Questa classe permette di configurare parametri del servizio inerenti la sicurezza e 
la logica di sopravvivenza della connessione.

- Clean Session 
   
  - **options.setCleanSession(true)**: Ogni collegamento è un nuovo inizio. Il Broker elimina eventuali messaggi non consegnati e le vecchie sottoscrizioni.
  - **options.setCleanSession(false)**: Il Broker mantiene la sessione. Se questa cade e poi torna online, si ritrovano tutti i messaggi 
    che sono arrivati sui topic (se inviati con :ref:`QoS<QoS di MQTT>` **1** o **2**) mentre si era offline .

- Last Will and Testament (**LWT** - Il Testamento)
  
  - **options.setWill(lastWillTopic, payload, 1, true)**: // QoS 1, Retained
    Un client A dice al broker:Se muoio improvvisamente (crash, perdita di segnale), pubblica questo messaggio per me.
    In questo modo, gli  altri componenti del sistema sapranno subito che A non è più disponibile.

- Keep Alive (Il battito cardiaco)

  - **options.setKeepAliveInterval(30)**: Definisce l'intervallo di tempo (in secondi) entro il quale il client deve inviare 
    un segnale al Broker per confermare di essere ancora vivo.

- Connection Timeout

  - **options.setConnectionTimeout(10)**: Indica quanto tempo il client deve aspettare che il Broker risponda alla richiesta di 
    connessione prima di arrendersi e lanciare un'eccezione.

**Esempio**

.. code::

    import org.eclipse.paho.client.mqttv3.*;
    MqttConnectOptions options = new MqttConnectOptions();

    // Sicurezza
    options.setUserName("il_tuo_utente");
    options.setPassword("la_tua_password".toCharArray());

    // Logica di sessione
    options.setCleanSession(false); // Mantieni i messaggi se cado
    options.setKeepAliveInterval(30); // Controllo ogni 30 secondi
    options.setConnectionTimeout(10);

    // Proattività: Il Testamento
    String lastWillTopic = "status/componenteA";
    byte[] payload = "{\"alive\": false}".getBytes();
    options.setWill(lastWillTopic, payload, 1, true); //QoS 1:Retained

    // Ora connetti
    client.connect(options);  


    OPZIONI DI CONNESSIONE:
    options.setCleanSession(true);              // true = non mantiene sessione
    options.setAutomaticReconnect(true);        // riconnessione automatica
    options.setConnectionTimeout(10);           // timeout in secondi
    options.setKeepAliveInterval(20);           // keep-alive in secondi
    options.setUserName("username");            // autenticazione
    options.setPassword("password".toCharArray());
    options.setWill(topic, payload, qos, retained); // Last Will Testament

.. _Qos di MQTT:

++++++++++++++++++++++++++++++++++++
QoS di MQTT
++++++++++++++++++++++++++++++++++++

MQTT definisce tre livelli di *Qualità del Servizio` (**QoS**), che influenzano la garanzia 
di consegna dei messaggi:

#. **QoS 0** (*At most once*):

    - Questo è il livello "fire-and-forget".
    - Il messaggio viene inviato una volta, senza alcuna conferma di ricezione.
    - Non c'è garanzia che il messaggio raggiunga il destinatario.
    - È il livello più veloce e leggero, ma anche il meno affidabile.
#. **QoS 1** (*At least once*):

    - Il messaggio viene inviato almeno una volta.
    - Il mittente conserva una copia del messaggio fino a quando non riceve una conferma (PUBACK) dal destinatario.
    - Se la conferma non arriva, il messaggio viene reinviato.
    - Garantisce che il messaggio venga consegnato, ma possono verificarsi duplicati.
#. **QoS 2** (*Exactly once*):

    - Il messaggio viene consegnato esattamente una volta.
    - Utilizza un protocollo di handshake a quattro vie per garantire che il messaggio venga consegnato senza duplicati.
    - È il livello più affidabile, ma anche il più lento e complesso.


**Esempi proposti da Claude**

- main.java.mqtt.claude.MqttSubscriber.java
- main.java.mqtt.claude.MqttPublisher.java



++++++++++++++++++++++++++++++++++++++++++++++++
MqttSender
++++++++++++++++++++++++++++++++++++++++++++++++

.. code::

    package main.java.mqtt;
    import org.eclipse.paho.client.mqttv3.MqttClient;
    import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
    import org.eclipse.paho.client.mqttv3.MqttException;
    import org.eclipse.paho.client.mqttv3.MqttMessage;
    import unibo.basicomm23.interfaces.IApplMessage;
    import unibo.basicomm23.utils.CommUtils;

    public class MqttSender {

      
      public void doJob() {
      String broker = "tcp://broker.hivemq.com";  
      String clientId = "sender";
      IApplMessage msgEvent = CommUtils.buildEvent(clientId, "alarm", "alarm(fire)" );
      try {
          MqttClient client = new MqttClient(broker, clientId);
          MqttConnectOptions connOpts = new MqttConnectOptions();
          connOpts.setCleanSession(true);

          client.connect(connOpts);
 
          // Pubblica messaggio 
          String topic   = "unibo/receiver/topic";
          String content = msgEvent.toString();
          int qos = 2;
          MqttMessage message = new MqttMessage(content.getBytes());
          message.setQos(qos);
          client.publish(topic, message);

            // Disconnetti
            client.disconnect();
        } catch (MqttException e) {
          CommUtils.outred("Error: " + e.getMessage());
        }
        
      }
      
      public static void main(String[] args) {
        new MqttSender().doJob();
        }
    }


++++++++++++++++++++++++++++++++++++++++++++++++
MqttReceiver
++++++++++++++++++++++++++++++++++++++++++++++++

.. code::

    package main.java.mqtt;
    import java.util.concurrent.CountDownLatch;
    import org.eclipse.paho.client.mqttv3.MqttClient;
    import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
    import unibo.basicomm23.utils.CommUtils;

    public class MqttReceiver {
        private CountDownLatch latch = new CountDownLatch(1); 

      
      public void doJob() {
      String broker = "tcp://broker.hivemq.com";  
      String clientId = "receiver";
      try {
          MqttClient client = new MqttClient(broker, clientId);
          MqttConnectOptions connOpts = new MqttConnectOptions();
          connOpts.setCleanSession(true);
          client.connect(connOpts);
          
          // Subscribe 
          String topic = "unibo/receiver/topic";
          client.subscribe(topic, (t, msg) -> {
            CommUtils.outmagenta("Ricevuto su topic:" + t + ": " + new String(msg.getPayload()));
            latch.countDown();
          });
          latch.await(); // Aspetta di ricevere il messaggio
          // Disconnetti
          client.disconnect();
        } catch ( Exception e) {
          CommUtils.outred("Error: " + e.getMessage());
        }        
      }
      
      public static void main(String[] args) {
        new MqttReceiver().doJob();
        }
    }

.. _MqttSupport:

++++++++++++++++++++++++++++++++++++++++++++++++
MqttSupport
++++++++++++++++++++++++++++++++++++++++++++++++

Lo scopo della classe  **MqttSupport** delle libreria :ref:`unibo.basicomm23-1.0` è **nasconder**  i dettagli relativi 
all'uso di **MqttClient** di Paho,
realizzanso operazioni più vicine al livello di astrazione applicativo:

.. list-table:: 
    :widths: 2,98
    :width: 100%


    * -  

      -  
         .. code:: java

          boolean connectToBroker(String clientid,  String brokerAddr)
          void disconnect()
          void cleartopic(String topic)
          void subscribe ( String topic, MqttCallback handler)
          void unsubscribe( String topic )
          void publish(String topic, String msg )
          void publish(String topic, String msg, int qos, boolean retain)
          void publish( String topic, byte[] payload, int qos, boolean retain)


+++++++++++++++++++++++++++++++++++++++++++++++
Non solo eventi
+++++++++++++++++++++++++++++++++++++++++++++++

Il protocollo MQTT nasce con l'idea che le informazioni emesse (*published*) su una topic 
da un componente software sono (nella nostra  :ref:`terminologia <Tipi di messaggi>`) **eventi** 
che qualche altro componente (i *subscribers*) può percepire ed elaborare.

Ma nelle nostre applicazioni può essere utile usare MQTT anche per inviare **dispatch** e **request**.
In questi casi, il sender si aspetta che:


Nel caso di **request** il sender si aspetta che:

- il messaggio venga percepito da un solo componente: quello il cui nome è specificato come 
  destinatario del messaggio. A questo fine si può supporre che ogni componente software (diciamo **A**) 
  operi come unico subscriber di una specifica topic (diciamo **topic_A**)
- nel caso di **request**, il *publisher* si aspetta che il destinaraio gli invii una **reply** e che 
  questa non venga percpeita da altri componenti. 
  
  A questo fine, si potrebbe introdurre il nome di una topic di risposta nel messaggio
  di richiesta. Ma noi non vogliamo modificare i messaggi di request per questa esigenza;
  faremo invece ricorso a un approccio 'implicito' specifico per la comunicazioni via MQTT:
  il concetto di :ref:`replyTopic`.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
replyTopic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un componente che riceve un *message* di tipo **request** da un componente di nome
**X**, invia la *reply*
su una topic il cui nome è strutturato come segue:

.. code::

    String replyTopic = "answ_" + message.msgId()+"_"+ message.msgSender() ;


1. La struttura ``answ_" + reqid + "_" + X`` ha tre grandi vantaggi:

   - *Isolamento*: Il componente **X** riceve su quel topic solo ed esclusivamente la risposta 
     a quella specifica richiesta. Non deve scorrere una lista di messaggi per trovare quello giusto.
   - *Identità*: Includendo **X** nel nome del topic, si semplifica il debug. Guardando il broker, 
     si capisce immediatamente chi sta aspettando cosa.
   - *Sicurezza*: Usando  le ACL (Access Control Lists) del broker, 
     si può fare in modo che solo A possa leggere da quel topic, proteggendo il dato.

2. Il problema del "Topic Churn" e del "Leak" delle sottoscrizioni
   C'è una sfida tecnica importante: se si inviano 1000 richieste, si creano 1000 topic di reply
   e il publisher dovrà ricordarsi si fare **UNSUBSCRIBE** su ciascuna di esse.
 
  Se si dimentica la *unsubscribe*, si può verificare un **Subscription Leak**:
  il Broker continua a tenere in memoria numerose
  sottoscrizioni vuote, rallentando le prestazioni.

+++++++++++++++++++++++++++++++++++++++
Response Topic
+++++++++++++++++++++++++++++++++++++++

.. note::

  Dal 2019 (con MQTT 5), il protocollo ha introdotto la logica di "Response Topic" nativamente nei 
  Properties del pacchetto,
  senza dover "sporcare" il contenuto del messaggio (il payload).

  - Invece di scrivere l'indirizzo di risposta nel JSON, lo si mette nell'header del protocollo:
  - Il componente che riceve, quando riceve il messaggio, non deve nemmeno guardare il JSON 
    per sapere dove rispondere: prende il valore dall'header Response Topic e pubblica lì.

-------------------------------------------------------
MqttInteraction
-------------------------------------------------------

L'uso diretto della libreria Paho o di :ref:`MqttSupport`
fornisce operazioni di tipo publish/subscribe su una topic, senza imporre vincoli.
Ad esempio, un client può pubblicare messaggi su una topic, e anche registrarsi come subscriber sulla stessa topic, 
con la conseguenza che il messaggio pubblicato viene ricevuto anche dal mittente. 
Ciò può costituire una opportunità, ma anche fonte di complicazione nel codice che voglia evitare 
la gestione dei messaggi inviati dalla sorgente.

Può essere quindi utile introdurre classi che forniscano un'interfaccia più semplice 
e coerente per la comunicazione tra due agenti, 
in cui uno fa da sender e l'altro da receiver.

.. Diamo il prefisso MqttConnectionBase ai nomi di queste classi, per evidenziare che intendono fornire supporti di 
   comunicazione logica, più strutturati rispetto a quelli forniti da MqttSupport.

.. image:: ./_static/img/mqttinteractionSenderReceiiver.png
    :align: center
    :width: 80%
 
 

.. code::

  //Il sender  dichieara:
  MqttInteraction mqttConn = 
    new MqttInteraction(name,  MqttBroker, "senderIn", "receiverIn");

  //Il receiver dichieara:
  MqttInteraction mqttConn = 
    new MqttInteraction(name,  MqttBroker, "receiverIn", "senderIn");

.. img/mqttAgents.png

 
**Esempio con MqttInteraction**
 
- ``main.java.mqttInteraction.MqttAgents``
 



.. _Una GUI HTML per Game of Life:

=========================================
Una GUI HTML per Game of Life
=========================================



----------------------------------------
conwaygui: analisi del problema
----------------------------------------

Per affrontare l'analisi del problema, introduciamo opportune domande. Ad esempio:

La GUI deve essere una pagina ``HTML`` che dovrebbe essere fornita da un
Web-server e che quindi potrebbe essere aperta  da **più utenti contemporaneamente**. 

#. `chi comanda?`. Nel caso di più utenti,
   questi potranno vedere la stessa griglia o ognuno vedrà la sua griglia?

   - il committente precisa che **tutti gli utenti potranno vedere la evoluzione della stessa griglia**, 
     ma solo uno potrà 
     inviare comandi di gestione del gioco. Questo utente privilegiato (detto `owner`) sarà 
     `l'utente che ha aperto per primo la pagina HTML`.
    

#. `chi crea la GUI?` Si modifica 
   :ref:`ConwayLife25 in Java` o è  meglio lasciare il più possibile inalterato 
   questo software già testato?  

   - meglio `modificare meno possibile` ciò che già funziona. 
     :ref:`ConwayLife25 in Java` è stato impostato in modo da  essere 
     estendibile senza dover modificare la logica del gioco. In particolare, la parte di **output** della
     GUI potrebbe essere aggiornata introducendo una nuova classe che implementa la
     :ref:`IOutDev interface` in modo da visualizzare lo stato delle celle nella pagina ``HTML``.
   - vi sono `framework` che permettono di realizzare pagine HTML che interagiscono con un server
     senza dover modificare il software già realizzato in Java. Uno di questi è  `SpringBoot`_.

#.  `come si aggiorna?` La pagina HTML deve essere aggiornata in modo automatico 
    o l'utente deve premere un pulsante per vedere lo stato delle celle?

    - la pagina HTML deve essere `aggiornata in modo automatico` (per tutti gli utenti
      connessi) durante la evoluzione del gioco, senza che un utente debba fare nulla.
      Questo richiede l'uso di  `WebSocket`_ che permettono di inviare messaggi dal server alla pagina HTML.

#.  `e se si ferma?` La pagina HTML potrebbe diventare vuota o rimanere stabile. 
    Come evitare che il gico continui senza che l'utente se ne accorga?

#. `come si riduce il traffico di rete?`  
    
   - il traffico di rete può essere ridotto inviando solo le informazioni necessarie per aggiornare la pagina HTML.
     Ad esempio, inviare `solo le celle che cambiano stato` e non tutta la griglia.     
   - tuttavia, un utente che si collega mentre il gioco è in corso dovrebbe vedere lo stato attuale
     della griglia in modo corretto. Questo richiede che il server invii al nuovo utente tutta la griglia attuale.   


Qui ci sono alcuni problemi da affrontare:

#. :ref:`Come rappresentare la griglia in HTML/JS`
#. :ref:`Comunicazioni server to pagina`
#. :ref:`Comunicazioni pagina to server`
#. :ref:`Come rendere disponibile la pagina HTML`  al browser dell'utente

..    - :ref:`Come rappresentare lo stato della griglia inviato` dal server Java alla pagina HTML/JS
..    - :ref:`Come rappresentare i dati inviati dalla pagina` al server
.. I primi due punti sono correlati.

La configurazione del sistema è simile alle :ref:`Configurazione di GofLife con Swing`; quello che cambia 
è la implementazione dell'oggetto (qui :ref:`OutInWs`) che implementa :ref:`La interfaccia IOutDev` 
(funngendo anche da dispositivo di input).

.. _Configurazione di GofLife con HTML:

----------------------------------------------
Configurazione di GofLife con HTML
----------------------------------------------

.. code:: java

   public void configureTheSystemWithHtmlWs() {
      Life life            = new Life( 20,20 );          
      IOutDev outinws      = new OutInWs(false);      
      GameController  cc   = new LifeController(life, outinws) ;       
      ((OutInWs) outinws).setController(cc);    //iniezione del controller nella GUI
   }

.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .
        
        .. image:: ./_static/img/LifeGameJavaWithHTML.jpg
          :align: center
          :width: 100%   
      -   La pagina HTML funge da:

          - **dispositvo di output** per visualizzare lo stato della ``Grid``
          - **dispositivo di input** per inviare comandi a :ref:`OutInWs`.


.. _IoJavalin:

------------------------------------
IoJavalin
------------------------------------


.. _OutInWs:

------------------------------------
OutInWs
------------------------------------

**OutInWs**: dispositivo di input/output che attiva (usando :ref:`javalin<Come opera javalin>`) una pagina HTML/JS 
per visualizzare lo stato della griglia e per inviare al ``LifeController`` 
le informazioni provenienti dalla pagina.

.. di ``start/stop/clear`` e di inizializzazione dello stato delle celle al ``LifeController``.

.. code::

  public class OutInWs implements IOutDev{  
	public OutInWs( boolean pageexternal ) {  
    javalin = new IoJavalin();
    if( ! pageexternal ) {
      setUpPageGranular();
      //setUpPageGlobal();
      //pageAloneUsingCHrome();
    }
  }

  protected void setUpPageGranular() { 
  try {
    Desktop.getDesktop().browse(
      new URI("file:///C:/.../conway/io/ConwayInOutPage.html") );
  }catch (Exception e) { ... }
  }
  protected void setUpPageGlobal() {  
  try {
   Desktop.getDesktop().browse(
    new URI("file:///C:/.../conway/io/LifeIInOutCanvas.html") );
  }catch (Exception e) { ... }
  }
  protected void pageAloneUsingCHrome() { 
  try{
    String cmd =  "\"C:/Program Files/Google/Chrome/Application/chrome.exe\"" +
                + " --app=file:///C:/.../ConwayInOutPage.html" ;
    Runtime.getRuntime().exec( cmd );
  }catch (IOException e) { ... }
  }

  /* Metodi di IOutDev */
      ...
  }


I metodi **setUpPagexxx** aprono uno specifico tipo di pagina evitando la necessità
di una apertura manuale della pagina :ref:`ConwayInOutPage.html` o  :ref:`ConwayInOutPage.html`
(che un end-user potrebbe non sapere dove si trova).

- Si tratta di una **richiesta al sistema operativo**; la pagina appare come una normale scheda 
  (tab) all'interno di una finestra del browser già aperta, con barra degli indirizzi, segnalibri 
  e tasti avanti/indietro.

Il metodo **pageAloneUsingCHrome** è una **Chiamata diretta a Chrome**:

- Forza l'apertura di *Chrome* in una modalità speciale (chiamata **Application Mode**,
  disponibile su tutti i browser basati su Chromium (Chrome, Edge)  
  progettata per far sembrare un sito web un'applicazione desktop nativa.
- La pagina ha la sua icona nella barra delle applicazioni e sembrerà un programma a sé stante.
- Funziona solo se Chrome è installato e se il percorso dell'eseguibile è corretto (molto fragile su sistemi diversi).

Notiamo che nessuna dei due modi di attivazione  funzionerà dentro un container Docker.
Nel caso di distribuzione del prodotto in Docker, il dispositivo dovrà essere inizializzato con
**pageexternal=true** e la pagina aperta con ``localhost:8080/conway``, come descritto al punto 3 di
:ref:`Come rendere disponibile la pagina HTML`.

.. _Come rappresentare la griglia in HTML/JS:

---------------------------------------------------
Come rappresentare la griglia in HTML/JS
---------------------------------------------------

La pagina HTML realizza un  dispostivo di I/O che interagisce con l'applicazione da
un lato e con l'utente umano dall'altro. 

All'interno della pagina, la griglia può essere rappresentata in modi diversi: 
esaminiamone due.

.. _Una griglia granulare:

+++++++++++++++++++++++++++++++++++++++++++
Una griglia granulare
+++++++++++++++++++++++++++++++++++++++++++


Definiamo la  griglia in *Retained Mode*, cioè
come una serie di celle quadrate, ciascuna con ID  **cell-i-j** incapsulata in un  tag ``<div>``.

- Identità: Ogni cella ha un "indirizzo" fisico nel documento HTML (es. l'ID).
- Stato: Lo stato (viva/morta) è "appeso" direttamente all'elemento, spesso tramite una classe CSS 
  (``.live { background: #28a745; }``) come fatto nel file ``mapstyle.css``.

Questa tecnica è adottata nel file **iomap.js** usato dalla pagina realizzata nel file  
``main/java/conway/io/ConwayInOutPage.html`` 

.. _ConwayInOutPage.html:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ConwayInOutPage.html 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: html

    <!DOCTYPE html>
    <html xmlns:th="http://www.thymeleaf.org">
    <head>
      <title>ConwayInOutPage</title></head>
        <link rel="stylesheet" href="mapstyle.css">
    </head>    
    <body>
      <h1>ConwayInOutPage</h1>
    <hr/>
    <!--  INPUT AREA   -->
      <button onClick="sendCmdToServer('start'); return false">START</button>
      <button onClick="sendCmdToServer('stop');  return false">STOP</button>
      <button onClick="sendCmdToServer('clear'); return false">CLEAR</button>
      <button onClick="sendCmdToServer('exit');  return false">EXIT</button>
      
    <!-- MAP AREA -->    
        <div >
          <h3 class="text-center">Life Grid Map - starts in (1,1)</h3>
          <div id="map" class="grid"></div>
        </div>      
      
    <!--  OUTPUT AREA -->
        <ol id="msgslist"></ol>
        <button type="button" onclick=clearOutArea()>Remove Messages</button>   
    
    <script src="iomap.js"></script>
    <script src="outArea.js"></script>	   
    <script src="wscontrol.js"></script>  
    </body>
    </html>

Nel package *src/main/java/conway/io*:

- **iomap.js**: mappa di nome **map** con le celle e funzione di commutazione del colore di una cella
  (``function updateCellColor(X,Y,color)``)
- **outArea.js**: area di nome **msgslist** dei messaggi di informazioni inviati dal server alla pagine 
  e metodi per il suo aggiornamneto
- **wscontrol.js**: gestisce la comunicazioni via socket tra server e pagina (``sendCmdToServer``)
  e la gestione di messaggi emessi dal serer .

.. _wscontrol.js:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
wscontrol.js
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Crea la socket di connessione tra pagina e il server e definisce codice per la gestione dei messaggi 
ricevuti dal server e per la trasmissione di messaggi al server.

- apre la socket verso il server: ``socketToGui = new WebSocket("ws://localhost:8080/eval")``
- definisce una funzione per l'inivo di messaggi in forma :ref:`IApplMessage` al server di cui 
  conosce il nome:

  .. code:: Javascript

    var cmdMsgTemplate = "msg( eval, dispatch, SENDER, lifectrl, CMD, 0 )" 
    var pageId         = "unknown"

    function sendCmdToServer(cmd) {
      msg = cmdMsgTemplate.replace("CMD", cmd).replace("SENDER",pageId)
      if( opened ) socketToGui.send(msg);
    }    
- ``socketToGui.onopen``: esegue *sendCmdToServer("ready")* per segnalare di essere attiva e granulare 
- ``socketToGui.onmessage``: gestisce messaggi (eventi) inviati dal server come discusso 
  in :ref:`Comunicazioni server to pagina`.
  


.. _Una griglia globale:

+++++++++++++++++++++++++++++++++++++++++++
Una griglia globale
+++++++++++++++++++++++++++++++++++++++++++


Evitiamo la creazione di molti tag ``<div>``, 
definendo la  griglia in *Immediate Mode*
usando l'elemento `canvas`_ di HTML5:
un'area di disegno programmabile via JavaScript che si comporta quasi esattamente 
come il *Graphics2D* di Java.

.. note::

  Questa tecnica è infinitamente più veloce per griglie grandi. 
  Disegnare 10.000 pixel su un canvas è un'operazione banale; gestire 10.000 <div> può mandare 
  in crash il browser di uno smartphone.

Adottiamo questa tecnica nel file ``main/java/conway/io/LifeIInOutCanvas.html``, suggerito da **Gemini AI**.

.. _LifeIInOutCanvas:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
LifeIInOutCanvas.html
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
.. code:: html

    <!DOCTYPE html>
    <html lang="it">
    <head>
        <meta charset="UTF-8">
        <title>LifeGuiCanvas</title>
        <style>
            body { background: #1a1a1a; color: #00ff00; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; }
            canvas { border: 2px solid #333; background: #000; cursor: crosshair; box-shadow: 0 0 20px rgba(0,255,0,0.1); }
            .controls { margin: 20px; padding: 10px; border: 1px solid #00ff00; }
            #status { font-size: 0.8em; margin-bottom: 10px; }
        </style>
    </head>
    <body>

        <h1>CONWAY GAME OF LIFE</h1>
        <div id="status">STATO: DISCONNESSO</div>
        
        <canvas id="gridCanvas"></canvas>

        <div class="controls">
          <button onclick="sendCmdToServer('start')">START</button>
            <button onclick="sendCmdToServer('stop')">STOP</button>
            <button onclick="sendCmdToServer('clear')">CLEAR</button>
        </div>

        <script src="wscanvascontrol.js"></script>
    </body>
    </html>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
wscanvascontrol.js
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Simile a :ref:`wscontrol.js` con funzioni specializzate per la gestione della griglia come canvas.

Riportiamo in particolare la funzione di gestione dei messaggi ricevuti dal server
(si veda :ref:`Comunicazioni server to pagina`):

.. code:: Javascript

      socketToGui.onmessage = (event) => {
      if( event.data.startsWith("ID:")){
        pageId= event.data.split(":")[1]; //definisce il nome della pagina
      }
      else if( event.data.includes("[[")) {
        const grid = JSON.parse(event.data);
        requestAnimationFrame(() => draw(grid)); //disegna la grid nel canvas
      }
      else  {
        console.log("pageglobal |  ", event.data );
      }
    };

Al momento, la pagina non defisce alcuna *outArea*; i messaggi informativi inviati dal server
sono visualizzati sulla console del browser.

 

 
**Comunicazioni server-pagina**
 

La comunicazione 
server/pagina è un elemento fondamentale per la integrazione tra due componenti 
sviluppati cone tecnologue informatiche diverse e che operano su due macchine diverse.

Approfondimao dunque l'analisi del problema relativo a questa integrazione.

.. _Comunicazioni server to pagina:

+++++++++++++++++++++++++++++++++++++++++++++
Comunicazioni server to pagina
+++++++++++++++++++++++++++++++++++++++++++++

Il server invia alla pagina comandi espressi da semplici stringhe

.. code::
   
   ID:name                //par dare il valore name al nome della pagina
   cell(X,Y)              //per commutare lo stato di una cella (griglia granulare)
   [[false,false, ... ]]  //per specificare lo stato di una grglia globale

L'invio dei comandi realativi allo stato della griglia è discusso in :ref:`Come inviare lo stato della griglia`.

Il primo comando indica che è il **server che attribuisce un nome** alle pagine che si connettono.
Questo per fare in modo che ci sia una **unica pagina** abilitata al *controllo* del gioco:
la **prima pagina** che si è conessa.

Nel server (ad esempio nella classe :ref:`IoJavalin` o in 
:ref:`AbstractProtoactor`) avremo codice come quello che segue: 

  .. code::
    
     protected AtomicInteger pageCounter         = new AtomicInteger(0);
     protected Vector<WsConnectContext> allConns = new Vector<WsConnectContext>();
     protected String firstCaller                = null;
     protected WsConnectContext firstctx         = null;

     ws.onConnect( ctx -> {
        int idAssegnato = pageCounter.incrementAndGet();
        String callerNAme = "caller"+idAssegnato;
        sendsafe(ctx, "ID:" + callerNAme);
        if( firstCaller == null ) {
         		firstCaller = callerNAme;
         		firstctx    = ctx;
        }
        allConns.add(ctx); //per permettere broadcast delle info
        sendsafe(ctx, callerNAme +"_conn_N_" + allConns.size());
        heartbeatTask = ...
    });//ws.onConnect

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sendsafe
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. Anche se il tuo thread TA è l'unico a elaborare la logica, se usi un Executor per l'Heartbeat (PING) 
   e contemporaneamente il TA finisce un compito e chiama ctx.send(), 

Può capitare che due thread applicativi cerchino di scrivere sullo stessa connessione nello stesso istante.
Questo 'conflitto' potrebbe accadere tra il thread proattivo che elabora la logica applicativa 
e  l'Heartbeat (PING).

Jetty non è thread-safe per gli invii WebSocket. Se due frame si sovrappongono, 
Jetty chiude la connessione per evitare di corrompere il protocollo.

Per evitare questi conflitti si introduce la operazion *sendsafe*:

.. codee::
    protected void sendsafe(WsContext ctx, String msg) {
    	synchronized (ctx.session) { 
            if (ctx.session.isOpen()) {
                ctx.send(msg);
            }
        }
    }
 
.. Questi comandi sono quelli introdotti con :ref:`La interfaccia IOutDev` e devono essere trasformati 
   in messaggi come discusso in :ref:`Come inviare lo stato della griglia`.

.. Tuttavia, il comando di visualizzazione dello stato di una singola cella 
  (``displayCell(Cell cell, Grid grid)``) non verrà mai inviato nel caso 
   di :ref:`Una griglia globale`.

.. dati diversi a seconda che la pagina organizzi la griglia come
   un insieme di celle separate (elemnti <idv> del DOM) o come un unico ente (canvas)

.. _Comunicazioni pagina to server:

+++++++++++++++++++++++++++++++++++++++++++++
Comunicazioni pagina to server
+++++++++++++++++++++++++++++++++++++++++++++
   

La pagina HTML deve inviare al server:

- comandi di commutazione di stato di una cella, quando l'utente vuole definire lo stato iniziale della griglia
- comandi di gestione del gioco ``start/stop/clear``
- informazione sul tipo di rappresentazione della griglia adottato dalla pagina (granulare o globale), 
  per permettere al server di inviare i giusti messaggi di aggiornamento

.. Fissiaamo la forma di 
   questo comando (di fatto il **"linguaggio della pagina"** ) in modo semplice

.. code::

   ready        //per dire che una pagina granulare è attiva
   canvas-ready //per dire che una pagina globale è attiva 
   start        //per attivare il gioco
   stop         //per porre il gioco in pausa 
   clear        //per resettare la griglia
   exit         //per terminare la applicazione

.. Questo *linguaggio della pagina* costituisce un **vincolo** valido sia per le pagine 
   a griglia granulare che per la pagine a griglia globale.

Queste stringhe sono il payload di messaggi di tipo IApplMessage
che vengono inviati al server come discusso nella sezione
:ref:`Come la pagina invia dati`.
 

.. _Come inviare lo stato della griglia:

++++++++++++++++++++++++++++++++++++++++++++++++
Come inviare lo stato della griglia
++++++++++++++++++++++++++++++++++++++++++++++++

#. Se si rappresenta la griglia in modo granulare,
   si può inviare un messaggio di aggiornamento **cella per cella**. 
#. Se si rappresenta la grida con l'elemento `canvas`_, 
   basta un messaggio con lo stato di **tutta la griglia** 

   Per una griglia di ``20x20``, il costo di inviare tutta la griglia è trascurabile:

  - Una matrice di ``400`` boolean occupa circa ``400-500`` byte in formato JSON.
  - Un singolo pacchetto di rete (**MTU** *Maximum Transmission Unit*) è di circa ``1500`` byte. 
     
   Dunque, inviare tutta la griglia o inviare una singola cella consuma esattamente la stessa quantità di risorse di rete 
   (perché il pacchetto deve comunque partire).

.. note::

  - A volte, l'interfaccia di rete di Docker ha un **MTU** leggermente più piccolo (es. ``1450`` byte) 
  - rispetto a quella del PC fisico (1500 byte).
      
    #. Il pacchetto esce dal  programma Java.
    #. Arriva al "confine" del container Docker.
    #. Docker si accorge che il pacchetto è troppo grande per il suo tunnel virtuale.
    #. Il problema: Se la frammentazione non è gestita bene, il pacchetto viene scartato. 
       Questo è uno dei motivi tecnici "oscuri" dietro l'**errore 1006** o le disconnessioni improvvise.

 .. In questo caso, inviare tutto è meglio perché è "Self-Healing": se l'Alieno 
     si connette a metà partita o ha un piccolo lag, riceve subito la situazione completa e non deve ricostruire la storia dei cambiamenti.


.. _Come la pagina invia dati:

++++++++++++++++++++++++++++++++++++++++++++++++
Come la pagina invia dati
++++++++++++++++++++++++++++++++++++++++++++++++

I dati introdotti in :ref:`Comunicazioni pagina to server`
potrebbero essere inviati al server direttamente, in forma di stringa.

Concettualmente però, ogni dato rappresenta il paylooad di un messaggio di tipo :ref:`IApplMessage`
tra il componente-pagina e il compoente-server:

  .. code::

    msg( eval, dispatch, PAGENAME, SERVENAME, DATOPAGINA, MSGNUM )

La pagina potrebbe avere nome ``PAGENAME=caller1``  ed essere configurata in modo da conoscere 
'a-priori' il nome del server (ad. es ``SERVENAME=lifectrl``) o ricevere il nome
dal server stesso alla prima connessione.

Ci si può chiedere che senso abbia custruire e inviare una struttura così ridondante,
quando la comunicazione deve avvenire tramite la WebSocket di connessione tra la pagina e il server.
Ocoorre però ricordare che ``N>1`` utenti umani possono aprire ``N`` pagine, ciascuna delle quali potrebbe 
essere usata per inviare dati.

La struttura ridondante del messaggio fornisce ulteriori informazioni per la gestione dello
scambio di informazioni tra un server e ``N>1`` pagine:

- nel caso di **dispatch** l'intento è che il comando deve essere recapitato e gestito dal solo 
  destinatario di nome ``SERVENAME``. Nel caso di **event** l'intento è inviare il payload
  come notifica a tutte le pagine connesse al server
- la indicazione di ``PAGENAME`` vincola
  il server a gestire un comando di gestione del gioco **solo se proviene** dalla *unica* pagina 
  abilitata al *controllo* del gioco.

Per ottenere un **unica pagina di controllo del gioco**, possiamo procedere come indicato 
in :ref:`Comunicazioni server to pagina` e con le sehuenti regole:

- il server considera la **prima pagina** che si è conessa come l'unica abilitata al *controllo* del gioco
- il server elabora solo messaggi che abbiano come RECEIVER il *serverName* corretto
- il server ignora eventuali comandi spediti da altre pagine, controllando il ``PAGENAME``
  del messaggio ricevuto
- tutte la pagine connesse possono ricevere informazioni emesse dal server come **event**


 
.. _Come rendere disponibile la pagina HTML:

++++++++++++++++++++++++++++++++++++++++++++++++++
Come rendere disponibile la pagina HTML
++++++++++++++++++++++++++++++++++++++++++++++++++

#. Aprendo 'manualmente' la pagina in un browser. Si tratta del
   modo *Standalone Client-Side App* o *Decoupled Frontend*:
   il browser opera come un motore di rendering per un'interfaccia locale.
#. Come fatto in :ref:`OutInWs` con *pageexternal=false*, facendo in modo che la pagina sia aperta 
   direttamente dalla applicazione
#. Come pagina Web erogata da un server. 
   Ad esempio, il server *javalin* embedded in :ref:`OutInWs` potrebe attìvare anche la parte ``HTTP``
   e fornire un metodo ``server.get("/", ctx-> ...``:

   .. code::

        protected void activateHTTP() {
          server = Javalin.create(config -> {
          //config.bundledPlugins.enableCors(cors->{cors.addRule(it->it.anyHost());});
            
            config.jetty.modifyWebSocketServletFactory(factory -> {
              factory.setIdleTimeout(Duration.ofMinutes(30));
            });
            config.staticFiles.add(staticFiles -> {
                staticFiles.directory = "C:/.../src/main/java/conway/io";  
                staticFiles.location = Location.EXTERNAL;
             });
          }).start(8080);
            
          server.get("/", ctx ->  {    
              Path path = Path.of("./src/main/java/conway/io/ConwayInOutPage.html");  
              if (Files.exists(path)) {
                  ctx.contentType("text/html").result(Files.newInputStream(path));
              } else {
                  ctx.status(404).result("File non trovato nel file system");
              }
            });
        }

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
concetto di "Self-Contained Service" (Servizio Auto-contenuto).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- Assenza di configurazioni CORS: Se la pagina HTML e la WebSocket provengono dallo stesso server e 
  dalla stessa porta (es. 8080), il browser non bloccherà mai la connessione per motivi di sicurezza 
  (*Same-Origin Policy*).
- Versionamento atomico: Se si aggiorna la logica del gioco nel server Java, l'utente riceve 
  anche la versione corretta della GUI. Non si corre il rischio che una vecchia pagina HTML cerchi di 
  parlare con un nuovo server.
- Semplicità per l'utente: L'utente deve solo ricordare un indirizzo (ad esempio ``http://localhost:8080/conway``) 
  e il sistema si "auto-installa" nel browser.

Visto che la pagina è servita dal server stesso, si può fare in modo che lo JavaScript non debba "indovinare" 
l'indirizzo IP del server.:
 
.. code::

  // window.location.host prende automaticamente l'IP e la porta corretti
  // (es. localhost:8080 o 192.168.1.50:8080)
  const socket = new WebSocket("ws://" + window.location.host + "/eval");

   
   


.. _Protoattori:

========================================
Protoattori
========================================

Il  :ref:`Progetto esplicito<Un progetto esplicito>` relativo al :ref:`Refactoring del sistemaS`,
può costituire il punto di partenza per la introduzione di componenti ispirati al modello
ad :ref:`attori<Gli attori come nuovo paradigma?>`.

.. , ispirato a quanto detto in  :ref:`Refactoring del sistemaS`.

.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .
       
        .. image:: ./_static/img/SystemSAsActorMqtt.png
          :align: center
          :width: 100%   
      -  

        L'idea è introdurre un componente che:

        - sia *intrinsecamene capace* di ricevere messaggio via rete
        - sia dotato di una struttura interna che pone in *foregorund* la logica applicativa
          lasciando nascosti (in *background*) i diversi meccanismi di comunicazione via rete
        - sia anche capace di *comportamenti autonomi*, cioè non legati alla ricezione di messaggi

        La classe astratta  ``AbstractProtoactorMsgdriven.java`` costitusice una sorta
        di **Micro-framework** che usa :ref:`Inversione di Controllo<Dependency inversion>` 
        per attivare operazioni applicative di gestione
        dei messaggi ricevuti via HTTP, WS e MQTT e posti nella coda del worker applicativo.

Prima di procedere alla definizione della classe astratta  ``AbstractProtoactorMsgdriven.java`` 
definendo in modo esplicito la coda ``applMsgQueue`` e il Thread ``ApplLogicWorker``,
osserviamo che Java introduce supporti utili alla realizzazione implicita della coppia 
``applMsgQueue + ApplLogicWorker``: gli Executors.

.. _Java Executors:

---------------------------------------
Java Executors
---------------------------------------

Java8 introduce la interfaccia `ExecutorService`_ (*java.util.concurrent*) come strato di più alto livello nella 
gestione dei Thread.
Inoltre, l'interfaccia **ScheduledExecutorService**  
estende **ExecutorService** per pianificare l'esecuzione di task dopo un determinato ritardo (delay) o in modo periodico.

.. La libreria **ScheduledExecutorService** è uno strumento generico della JVM. 
.. Gli **Executor** consentono l'esecuzione di task asincroni e pool di Thread.

La classe **Executors** definisce diversi metodi factory per creare 
un *ExecutorService* predefinito che soddisfi casi d'uso specifici.
Ad esempio, l'executor creato come segue: 

.. code::

  ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor()

è un "worker" che rimane in attesa di compiti (task) che gli sono accodati 
mediante il metodo :ref:`submit`.
Essendo *executor* "SingleThread", si ha la garanzia che non ci siano due task che interferiscono 
tra loro (niente problemi di sincronizzazione/race conditions).


.. list-table:: 
    :widths: 25,30,45
    :width: 100%

    * - Caratteristica       
      - new Thread()
      - SingleThreadScheduledExecutor
    * - Riutilizzo       
      - No (un thread per ogni task)
      - Sì (lo stesso thread riutilizzato per più task)
    * - Pianificazione       
      - Solo esecuzione immediata
      - Ritardata o Periodica (es. "fai questo ogni 10 sec")
    * - Resilienza       
      - Se fallisce, il thread muore
      - Se fallisce, l'executor ne crea uno nuovo per i task successivi
    * - Costo       
      - Elevato (creare un thread OS è costoso)
      - Basso (si paga il prezzo di creazione una sola volta)

.. _submit:

++++++++++++++++++++++++++++++++++++
submit
++++++++++++++++++++++++++++++++++++

Questo metodo è il modo più evoluto per "dare lavoro" a un executor. 
A differenza di un semplice comando "esegui", submit trestituisce un contratto (chiamato **Future**) 
che permette di monitorare, annullare o ottenere il risultato di quel lavoro (task).

Un task può essere un **Runnable** quando occorre eseguire 
un compito di tipo fire-and-forget, 
oppure **Callable** quando il compito da eseguire deve dare una risposta.


**Esempio nel caso Runnable**

.. code::

  executor.submit(() -> {
    System.out.println("Salvataggio dati in corso...");
    Thread.sleep(2000);
    System.out.println("Dati salvati!");
  });
  System.out.println("Proseguo subito con altre operazioni!");

**Esempio nel caso Callable**

.. code::

    Future<Integer> futuroRisultato = executor.submit(() -> {
        Thread.sleep(1000);
        return 42; // Il valore che verrà restituito
    });

    // Posso fare altro nel frattempo...

    // Quando serve il valore, chiedo al "Future"
    // .get() è bloccante: aspetta che il task finisca
    Integer risultato = futuroRisultato.get(); 
    System.out.println("Il risultato è: " + risultato);

**Esempio di annullamento**
 
.. code::

  Future<?> taskLungo = executor.submit(() -> {
      // ...operazione lunga...
  });

  // Se dopo un po' non serve più
  taskLungo.cancel(true);  


Se si usa solo **submit()**, lo ScheduledExecutor si comporta esattamente come un normale 
*SingleThreadExecutor*. Tuttavia, la **versione "Scheduled"** dà un vantaggio: eseguire 
compiti che new Thread non può fare facilmente:

- Esecuzione periodica (es. Heartbeat/Ping)
- Esecuzione ritardata (Delay)
  
Se, in futuro, l'applicazione volesse far partire un task dopo un certo tempo,
si avrebbe già lo strumento pronto.


**Come opera un executor newSingleThreadScheduledExecutor**

L'executor utilizza una coda interna (una *DelayedWorkQueue*). 

- Quando si invoca **submit()**, i task vengono messi in coda nell'ordine in cui arrivano. 
- Poiché c'è un solo thread disponibile, l'executor torna a prelevare dalla alla coda 
  solo quando il task corrente è terminato.
- Se il task corrente  lancia un'eccezione non gestita, 
  l'executor non si blocca, ma cree uno nuovo thread
  e passa ad eseguire il nuovo task.
- Un Executor crea thread di tipo "User" (non-daemon). La JVM rimane accesa finché 
  c'è almeno un thread di questo tipo attivo. Per **terminare**, occorre chiamare:

  - **executor.shutdown()**: Finisce i compiti che hai già in coda, ma non ne accetta di nuovi". 
    Una volta svuotata la coda, il conponente morirà
  - **executor.shutdownNow()**: Tenta di interrompere i compiti in corso e svuota la coda immediatamente. 

**Come terminare in modo automatico un executor**

Se si vuole che un Executor si chiuda automaticamente non appena 
il programma principale si ferma (senza dover chiamare esplicitamente *shutdown*), 
lo si puoò configurare usando una *ThreadFactory*:

.. code::

  ScheduledExecutorService executor = 
   Executors.newSingleThreadScheduledExecutor(runnable -> {
    Thread t = new Thread(runnable);
    t.setDaemon(true); //Questo rende il thread un "servitore" che muore col main
    return t;
  });

Con ``setDaemon(true)``, non appena il thread principale si chiude, anche l'executor 
verrà terminato forzatamente dal sistema.




.. Ogni Thread all'interno del pool è riutilizzabile, un *Executor* infatti non termina autonomamente 
  la sua esecuzione ma rimane in attesa dell'esecuzione di nuovi task. 
  Per terminare un *Executor* occorre esplicitamente invocare su di esso uno dei metodi 
  di shutdown offerti dalla classe. 

---------------------------------------
Un progetto con gli executors
---------------------------------------

.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .
       
        .. image:: ./_static/img/AbstractProtoactorExecutor.png
          :align: center
          :width: 100%   
      -  

        L'idea è introdurre un componente che:
 
Nel package **main.java.protoactor** definiamo le seguenti classi:

.. list-table:: 
    :widths: 37,63
    :width: 100%

    * - ``AbstractProtoactor.java``       
      - Classe astratta che lascia non definiti i metodi di gestione messaggi
        ``elabDispatch``, ``elabRequest`` ed ``elabEvent``.
    * - ``SystemSAsPProtoactor.java``       
      - Specializza  ``AbstractProtoactor`` definendo la logica applicativa
    * - ``CallerMqtt.java``
      - Un cliente Java che invoca sistemaS usando mqtt
    * - ``CallerProtoactor.html``
      - Un cliente HTML che invoca sistemaS usando WS e HTTP

.. _AbstractProtoactor:

---------------------------------------------
AbstractProtoactor
---------------------------------------------

.. Questa classe è organizzata come il :ref:`SistemaSJavalApplMsgsQueued`. In particolare,
   la classe implementa la interfaccia :ref:`InteractionBasic`, come fatto in :ref:`Interazioni locali`.


Costruiamo una classe che operi come un **MicroFramework** per la costruzione 
di componenti ispirati al modello ad :ref:`attori<Gli attori come nuovo paradigma?>`,
reattivi a messaggi e proattivi.


.. list-table:: 
    :widths: 70,30
    :width: 100%

    * -      
        .. code::

            public abstract class AbstractProtoactor 
                                    implements InteractionBasic{ 
                  protected Javalin server  = null;                                      
            /*1*/ protected ScheduledExecutorService taskexecutor= 
                    Executors.newSingleThreadScheduledExecutor();
            /*2*/ public AbstractProtoactor(String name){
                      this.name = name;
            /*3*/     configureJavalin();
                  }
            /*4*/protected abstract void elabDispatch(IApplMessage m);    
                protected abstract IApplMessage elabRequest(IApplMessage req);
                protected abstract void elabEvent(IApplMessage ev );

            /*5*/ protected void configureJavalin() {  
                    setWorkHTTP();
                    setWorkWS( );    
                  }

                    ...
            }
      -  

        #. la classe implementa la interfaccia :ref:`InteractionBasic`, 
           come fatto in :ref:`Interazioni locali` come anticipazione di
           :ref:`Comunicazioni basate sui nomi dei componenti`
        #. creazione dell'executor dei task applicativi
        #. costruttore che riceve un **nome** da dare al componente
        #. invocazione del metodo che inizializza la variabile **server** ad un server javalin
        #. metodi **abstract** che devono essere definiti da classi specializate
        #. inzializzazione del server javalin per gestire sia HTTP sia WS

Grazie a javalin, i componenti potranno erogare pagine HTML e 
ricevere messaggi via WebSocket.

La classe implementa la interfaccia :ref:`InteractionBasic` per permettere 
anche la ricezioni di messaggi da parte di componenti locali alla stessa JVM,
come già discusso in :ref:`Interazioni locali`.

.. _Comunicazioni basate sui nomi dei coponenti:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Comunicazioni basate sui nomi dei coponenti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In prosepttiva, si vuole generalizzare l'idea di un componente software con cui interagire inviando 
messaggi, anche quando questi gli sono recapitati usando la memoria locale.

- Ovviamente le interazioni su memoria locale sono possibili solo da parte di clienti/caller che 
  condividono la steaa JVM del componente. Un esempio è mostrato in :ref:`MainConwayLifeCmdOnmemory`.

Notiamo che questa possibilità di interazione supera l'idea che per comunicare 
con un 'attore' software sia necessario avare una conessione di rete.

Si fa strada l'idea che per comunicare con un componente dotato di un nome (ad esempio *'service'*)
sia solo necessario conosecrne il nome, lasciando alla 'parte sommersa' il compito 
di scegliere la via tecnologica più opportuna per recapitare il messaggio al componente 
con quel nome.

Viene subito alla mente, come analogia, il DNS delle reti di calcolatori.
Noi introdurremo supporti simili in un futuro capitolo. 

+++++++++++++++++++++++++++++++++++++++
Gestione dei messaggi via WS
+++++++++++++++++++++++++++++++++++++++

.. list-table:: 
    :widths: 70,30
    :width: 100%

    * -

        .. code::
          
          ... 
          /*1*/ws.onMessage(ctx -> {  
          /*2*/IApplMessage am = readInputWS( ctx.message() );          	
          /*3*/if( am.isEvent() || am.isDispatch() ) elabMsg(am);
              else if( am.isRequest() ) elabRequest( am, ctx );       
          });
  
          /*4*/protected void elabMsg(IApplMessage am) {
            if (am.isEvent()) {
                executeTask( () -> elabEvent(am) );
            } else if (am.isDispatch()) {
                executeTask( () -> elabDispatch(am) );
            }
          }

          /*5*/protected void executeTask(Runnable applTask) {
              taskexecutor.execute(() -> {
                  try {
                      applTask.run();
                  } catch (Exception ex) {... }
              });
            }  

          /*6*/ protected void elabRequest(
                    IApplMessage am,  WsMessageContext ctx) {  
                if( am.isRequest() ) { //defensive programming
                  taskexecutor.execute( () -> {
          /*7*/     IApplMessage replyMsg = elabRequest(am);
          /*8*/     ctx.send( replyMsg.toJsonString() );
                  });  
                }
              }
          ...
      -  
        #. javalin WS riceve un messaggio su una connessione
        #. il messaggio viene letto come *ApplMesage*
        #. se il messaggio non richiede reply, lo si elabora (metodi 4,5) come evento o come dispatch 
           invocando i rispettivi metodi applicativi specializzati
        #. metodo di gestione di messaggi non-request
        #. metodo che esegue la procedura applicativa specializzata
        #. metodo di gestione di una request 
        #. invocazione della procedura applicativa specializzata
        #. invio della **reply** sulla connessione del richiedente







.. _SistemaSAsProtoactor:

------------------------------------------
SistemaSAsProtoactor
------------------------------------------

Grazie alla classe ``AbstractProtoactor.java`` tutti i dettagli tecnologici reltativi a *javalin*,
alle interazioni sincrone e/o asincrone e alla gestione dei messaggi che arrivano dalla rete è 
ora introdotta nella 'parte sommersa' del componente.

Le operazioni ``elabDispatch``, ``elabEvent`` e ``elabRequest`` contengono la logica applicativa 
di gestione dei messaggi

.. code::

    package main.java.javalin.actor;
    import unibo.basicomm23.interfaces.IApplMessage;
    import unibo.basicomm23.utils.CommUtils;

    public class SistemaSAsProtoactor extends AbstractProtoactor{

    protected Future<?> myLocalTask;

      public SistemaSAsProtoactor(String name) {
        super(name);
        //myLocalTask = executor.submit( () -> proactiveTask() );
      }

      protected double eval(double x) {
        CommUtils.outblue(name + " | eval: " + x);
        if (x > 4.0) {
            CommUtils.outmagenta(name + " | Simulo ritardo per x="+x);
            CommUtils.delay(10000);
          }
        return Math.sin(x) + Math.cos( Math.sqrt(3)*x);
      }

      @Override
      protected void elabEvent(IApplMessage ev ) {
      CommUtils.outblue(name + " | elabEvent:" + ev);
      }

      @Override
        protected IApplMessage elabRequest(IApplMessage req ) {
           if( req.msgId().equals("eval")){
            double x      = Double.parseDouble(req.msgContent());
            double result = eval(x);
            IApplMessage replyMsg = 
              CommUtils.buildReply(name,req.msgId(),
                                   ""+result,req.msgSender());
            return replyMsg;
          }else{
            IApplMessage replyMsg = 
              CommUtils.buildReply(name,req.msgId(),
                             "requestUnkown",req.msgSender());
            return replyMsg;
          }
        }

      @Override
        protected void elabDispatch(IApplMessage m ) {
          CommUtils.outblue(name + " | elabDispatch from" + m.msgSender());
        }     
       
      protected void proactiveTask() {
        CommUtils.outgreenname + " | proactiveTask doing nothing ....."  );
      }

      public static void main(String[] args) {
          new SistemaSAsProtoactor("sistemaS") ;
       }
    }

Questo componente opera in modo **message-driven** in quanto i suoi metodi sono invocati dalla 'parte sommersa'   
del *MIcro-framework* elabora in modo FIFO i messaggi.

- Le operazioni ``void elabEvent(IApplMessage ev )`` e ``void elabDispatch(IApplMessage ev )``
  contengono la logica applicativa relativa alla gestione di un evento e di un dispatch rispettivamente.
- La operazione ``IApplMessage elabRequest(IApplMessage req)`` deve reastituire la **reply** che 
  la parte 'soomersa' (ereditata) farà pervenire a chi aveva inviato la richiesta,
  usando la relativa forma di comunicazione (WS o HTTP o MQTT).


L'operazione ``proactiveTask`` viene introdotta per enfatizzare il *problema dei due padorni* che sorge 
quando si introduce a livello applicativo un nuovo Thread ignorando che esiste un Thread ereditato 
che implementa la **Inversion of Control** (IoC) e che quindi 'inietta comportamenti' a livello applicativo.

Ad esempio:

.. _proactiveTask:

++++++++++++++++++++++++++++++++++++++++
proactiveTask
++++++++++++++++++++++++++++++++++++++++

In questo esempio, l'operazione *proactiveTask* (che viene opzionalmente eseguita in un Thread autonomo alla costruzione)
emette, ogni 2 sec,  un evento cche segnala l'ora corrente. 

.. code::

    @Override
    protected void proactiveTask() {
      CommUtils.outgreen("SistemaSAsProtoactor | proactiveTask started ....."  );
      while(true) {
        CommUtils.delay(2000);
        if( allConns.size() > 0) {
          String time = LocalTime.now().getMinute() + ":"  + LocalTime.now().getSecond();
          CommUtils.outyellow(name + " | emitInfo "  + time);						
          emitInfo( time );
      }
    }

Per un esempio di interazione con iquesto componente si veda:
``main.java.protoactor.CallerProtoactor.html``

In questo esempio, non vi sono'interferenze' con il task di gestione dei messaggi.
Tuttavia, questo modo di organizzare la struttura interna del componente potrebbe creare un conflitto tra le azioni
di gestione dei messaggi  e il thread che segue *proactiveTask*.
Per questo motivo, in una futura evoluzione del micro-framework, si imposterà la esecuzione del componente 
come un automa a stati finiti (FSM - *Finite State Machine*) .

--------------------------------------------
Visualizziamo quanto emesso dal server
--------------------------------------------

Il :ref:`SistemaSAsProtoactor` emette informazioni sulle connessioni WS attive
che fino ad ora sono state rese visibili 
aprendo gli **Strumenti per sviluppatori** (tasto **F12**) di un browser.

Non è però complicato fare in modo che queste informazioni siano rese visibili mediante una pagina HTML,
come quella definita nel file ``main.java.protoactor.SistemaSOutpage.html``: basta utilizzare la operazione
:ref:`emitInfo` definita nella classe astratta :ref:`AbstractProtoactor`.



+++++++++++++++++++++++++++++++++++++++++++++
SistemaSOutpage.html
+++++++++++++++++++++++++++++++++++++++++++++

In questa pagina HTML definiamo un elemento ``<ol>`` denominato **msgslist**
che popoleremo di item che rappresentano le informazioni emesse dal server sulle connessioni WS attive.

la funzione **addItem** aggiunge dinamicamente un elemento alla lista; essa viene invocate dall'handler
``socketWS.onmessage`` che a sua volta è attivato quando il server javalin del :ref:`SistemaSAsProtoactor`
'scrive' dati sulle connessioni WS attive. 

Un **button** attiva, quando cliecked,  la funzione **clearOutArea** che svuota la lista


.. code::

    <!DOCTYPE html>
    <html>
    <head><title>SistemaSOutpage</title></head>
    <body>
      <h2>SistemaS outpage</h2>
    <hr/>
      <!--  OUTPUT AREA -->
        <ol id="msgslist"></ol>
        <button type="button" onclick=
            clearOutArea()>Remove Messages</button>
    
    <script>
      function  connectWS(){
      /*1*/const socketWS = 
        new WebSocket("ws://localhost:8080/eval");

      /*2*/socketWS.onopen = () => {
          addItem("Connesso a eval");
        }

      /*3*/socketWS.onmessage = (event) => {
        if( event.data !== "PING" ){
              addItem(event.data);
          }
        }
      }//callWS
 
     //outarea.js 
      const list = document.getElementById("msgslist")

      function addItem(item){
        const li = document.createElement('li');
        li.appendChild(document.createTextNode(item))
        list.appendChild(li);			 
      }
      
      function clearOutArea(){
        const lista = document.getElementById('msgslist');  
        lista.innerHTML = ''; // Rimuovi tutti i nodi figli
      }
 
      connectWS();
    </script>    
    </body>
    </html>  

 

.. Gli eventi denominati **PING** vengono emessi periodicamente come **Heartbeat** dal sever per mantere attiva una connessione.
 





.. Per comprendere meglio questo punto, introduciamo nuovi requisiti per il nostro sistamaS.




   
   
.. In questo caso, LifeController può operare con la mediazione di un server WS 
    oppure può essere realizzato come un attore :ref:`LifeControllerAsProtoactor` 
    che comunica direttamente con la pagina HTML via WS.
  
    Il server eroga la pagina HTML al browser dell'utente e gestisce le connessioni WS.


.. I browser basati su Chromium (Chrome, Edge, Brave) hanno una funzione nascosta chiamata Application Mode.
    Questa lancia il browser in una finestra dedicata, senza schede, senza barra degli indirizzi 
    e con l'icona della pagina nella barra delle applicazioni.

    ..  "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"  
      --app=file:///C:/Didattica2026/protobook/src/main/java/conway/io/LifeGameOutGui.html




.. Successivamente, estendiamo la pagina HTML in modo che l'utente possa inviare comandi (``start/stop/clear)`` al ``LifeController`


 



 
.. _Game of Life con protoattori:

=================================================
Game of Life con protoattori
=================================================
 
Nella sezione :ref:`Costruiamo il Game of Life in Java`
abbiamo realizzato un sistema software che realizza il gioco :ref:`Game of Life di Conway`
impostandolo con una archicettura a oggetti, che riportiamo qui

.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .
        
        .. image:: ./_static/img/LifeGameJava+.jpg
          :align: center
          :width: 100%   

      -       
        - **Cell**: elemento fondamentale del gioco
        - **Grid**: aggregato di ``Cell``
        - **Life**: regole del gioco 
        - **IOutDev**: contratto per la visualizzazione dello stato di una ``Cell``
        - **LifeController**: controllo del gioco e visualizzazione della ``Grid``
        - **Gamecontroller**: contratto che ``LifeController`` impone ai dispositivi in input



Ridefiniamo ora il componente :ref:`LifeController` come una specializzazione 
della classe :ref:`AbstractProtoactor`: 


#. ``LifeController`` è un componente proattivo e reattivo che può elaborare messaggi 
   strutturati (di tipo :ref:`IApplMessage`) che gli giungono via WS sulla porta ``8080`` 
#. dunque ``LifeController`` può essere pensato come un **proto-attore** che riceve comandi
   da una pagina HTML ad esso connessa via WS
#. la parte proattiva del *proto-attore* esegue il controllo del gioco, sensibile 
   ai cambiamenti apportati dalla parte reattiva ai comandi.
#. ``LifeController`` eredita la possibilità di **inviare**  
   informazioni via WebSocket a una pagina ``HTML`` e **ricevere** da questa comendi di gsstione del gioco.

Ciò elimina la necessità di introdurre dispositivi di I/O , portando l'architettura del sistema ad evolvere 
come segue:

.. list-table:: 
    :widths: 55,45
    :width: 100%

    * - .
        
        .. image:: ./_static/img/LifeControllerProtoactor.png
          :align: center
          :width: 100%   
      -   La pagina HTML funge da:

          - **dispositvo di output** per visualizzare lo stato della ``Grid``
          - **dispositivo di input** per inviare comandi al ``LifeControllerProtoactor``.

.. _LifeControllerProtoactor:

+++++++++++++++++++++++++++++++++++++++
LifeControllerProtoactor
+++++++++++++++++++++++++++++++++++++++

Il :ref:`proactiveTask` del componente diventa ora il **task play** che fa evolvere il gioco
secondo quanto discusso in :ref:`Evoluzione di GofLife`

.. _MainConwayLifeCmdOnmemory:

+++++++++++++++++++++++++++++++++++++++++++++++++
MainConwayLifeCmdOnmemory
+++++++++++++++++++++++++++++++++++++++++++++++++

Il gioco può essere comandato anche da messaggi inviati 'onmemory':

.. code::

    public class MainConwayLifeJavaOnmemory  {
      private String startMsg = "msg(cmd,dispatch,caller1,lifectrl,start,0)";
      private String stopMsg  = "msg(cmd,dispatch,caller1,lifectrl,stop,0)";
      private String m        = "msg(cmd, dispatch, caller1, lifectrl, CELL, 0 )";
      private String nepoch   = "msg(nepoch, request, caller1, lifectrl, nepoch, 0 )";

      public void doJob() {
          Life life                   = new Life( 20,20 );   //ncell in iomap.js      
          LifeControllerProtoactor cc = new LifeControllerProtoactor("lifectrl",life);   		
          configureAndGo( cc );
      }
      protected void configureAndGo( LifeControllerProtoactor cc) {
        while( ! cc.isReady()) { //cc diventa ready quando è stata aperta la pagina
          CommUtils.delay(1000);
          CommUtils.outblue("configureAndGo waits ...");
        }
        /* Inizializza alcune celle vive */
        cc.forward( new ApplMessage( m.replace("CELL", "cell(0,1)") ));
        cc.forward( new ApplMessage( m.replace("CELL", "cell(1,1)") ));
        cc.forward( new ApplMessage( m.replace("CELL", "cell(2,1)") ));
        /* Avvia il gioco */
        cc.forward( new ApplMessage(startMsg) );
        /* Lascia evolvere il gioco*/        
        CommUtils.delay(3000);
        /* Richiede il numero di epoche trascorse */       
        try {
          IApplMessage answer = cc.request( new ApplMessage( nepoch ));
          CommUtils.outblack("caller answer=" + answer);
          CommUtils.delay(500);
          IApplMessage answer1 = cc.request( new ApplMessage( nepoch ));
          CommUtils.outblack("caller answer1=" + answer1);
        } catch (Exception e) { e.printStackTrace(); }
        /* Lascia evolvere il gioco ancora un po'*/
        CommUtils.delay(5000);
        /* Ferma il gioco */
        cc.forward(new ApplMessage(stopMsg));
        CommUtils.outblue("configureAndGo BYE");	
      }
      
        public static void main(String[] args) {
          CommUtils.aboutThreads("MainConway | STARTS " ); //Richiede dipendenze
          MainConwayLifeJavaOnmemory app = new MainConwayLifeJavaOnmemory();
          app.doJob();       
        }
    }

.. _Oltre comportamenti message-driven:

--------------------------------------------
Oltre comportamenti message-driven
--------------------------------------------

Emerge dunque una nuova idea: abbandonare lo schema *messag-driven* e fare in modo che sia il componente a **decidere** quando 
compiere azioni autonome oppure quando elaborare messaggi.

Questio obiettivo si può raggiungere strutturando il codice del componente come un **automa a stati finiti**.

E' quello che faremo nel capitolo :ref:`Il linguaggio qak`, introducendo anche un *nuovo linguaggio*,
per espriemere in modo
esplicito tutti i concetti che fino ad ora sono stati implicitamente introdotti mediante le librerie.
 


.. In alternativa, possiamo impostare un funzionamento del sistema che, osservato dall'esterno, si comporta 
   come un servizio di chat tra i client conessi. 

 





.. _Sistemi a Microservizi:

======================================
Sistemi a Microservizi
======================================

I sistemi software composti da microservizi rappresentano l'apice di un'evoluzione 
che ha visto i sistemi informatici 
trasformarsi da semplici programmi a complicate infrastrutture distribuite. 

Le principali tappe che hanno segnato questo cambiamento possono essere visualizzate e riassunte come 
riportato in `mshistory`_ .

..  .. image::  ./_static/img/microservices.jpg
    :align: left 
    :width: 100%  

Le motivazioni che spingono le aziende industriali verso i microservizi sono molteplici e spesso legate alla 
necessità di gestire sistemi complessi e scalabili, migliorare la resilienza, accelerare l'innovazione, 
e supportare la trasformazione digitale. 

 
---------------------------------------------------
Motivazioni all'uso dei microservizi  
---------------------------------------------------

L'architettura a microservizi offre la flessibilità necessaria 
per rispondere a queste sfide, permettendo alle aziende di adattarsi più facilmente alle evoluzioni 
del mercato e alle esigenze operative.


++++++++++++++++++++++++++++++++++++++++++++++++
Scalabilità e Prestazioni
++++++++++++++++++++++++++++++++++++++++++++++++

Le aziende industriali spesso gestiscono sistemi di produzione e automazione che richiedono una scalabilità 
elevata per supportare un numero crescente di sensori, macchine, impianti o clienti. 
L'architettura monolitica può diventare inefficiente quando i sistemi crescono in termini di carico e complessità.
 
**Microservizi**: Permettono di scalare singoli componenti (servizi) indipendentemente, 
senza dover scalare l'intera applicazione. Ciò è utile quando alcuni servizi, come 
l'elaborazione dei dati dei sensori o l'analisi in tempo reale, richiedono più risorse 
rispetto ad altri. Questo riduce i costi e ottimizza l'uso delle risorse.

++++++++++++++++++++++++++++++++++++++++++++++++
Manutenibilità e Aggiornamento
++++++++++++++++++++++++++++++++++++++++++++++++

I sistemi industriali tendono a diventare molto complessi e possono richiedere aggiornamenti continui 
per adattarsi a nuove tecnologie o standard di settore. 
La manutenzione di una grande applicazione monolitica può essere difficile e costosa, con rischi di downtime elevati.
  
**Microservizi**: Consentono di aggiornare e mantenere singoli componenti senza interrompere l'intero sistema. 
Le aziende possono effettuare modifiche e aggiornamenti a singoli servizi in maniera più rapida e con minori rischi, 
migliorando la produttività e riducendo il rischio di guasti durante gli aggiornamenti.

++++++++++++++++++++++++++++++++++++++++++++++++
Sviluppo autonomo e Time-to-Market
++++++++++++++++++++++++++++++++++++++++++++++++
In ambito industriale, le aziende spesso necessitano di sviluppare nuove funzionalità in tempi rapidi 
per rispondere a nuove richieste del mercato, integrare nuovi macchinari o tecnologie, 
o offrire nuove soluzioni ai clienti. Gli approcci monolitici rallentano lo sviluppo perché 
richiedono la coordinazione tra più team su un'unica base di codice.

**Microservizi**: Permettono ai team di sviluppo di lavorare in parallelo su servizi separati, 
con cicli di sviluppo indipendenti. 
Questo riduce i tempi di rilascio delle nuove funzionalità, migliorando il time-to-market delle innovazioni, 
e consente alle aziende di rispondere più rapidamente alle esigenze del settore.

++++++++++++++++++++++++++++++++++++++++++++++++
Flessibilità Tecnologica
++++++++++++++++++++++++++++++++++++++++++++++++

Le aziende industriali spesso utilizzano una vasta gamma di tecnologie e strumenti, che vanno dai 
sistemi legacy agli impianti moderni basati su IoT (`Internet of Things`_) o AI. 
Una singola tecnologia o piattaforma potrebbe non essere adatta per tutti i casi d'uso. 

**Microservizi**: Consentono di utilizzare diversi stack tecnologici per servizi diversi, 
permettendo alle aziende di scegliere la tecnologia più adatta per ogni componente del sistema. 
Questo offre una grande flessibilità e consente di integrare più facilmente nuovi strumenti 
o tecnologie all'interno dell'architettura aziendale.

++++++++++++++++++++++++++++++++++++++++++++++++
Resilienza e Tolleranza ai Guasti
++++++++++++++++++++++++++++++++++++++++++++++++

Le aziende industriali richiedono un'alta affidabilità nei loro sistemi, poiché anche brevi interruzioni 
nei processi produttivi possono causare perdite significative. 
In un'applicazione monolitica, un errore in un singolo componente può bloccare l'intero sistema.

**Microservizi**: Migliorano la resilienza poiché i servizi sono isolati e l'errore di un singolo 
servizio non comporta necessariamente il fallimento dell'intero sistema. 
Questo approccio permette di costruire architetture più robuste e con capacità di recupero automatico 
(self-healing), minimizzando l'impatto di eventuali guasti.

++++++++++++++++++++++++++++++++++++++++++++++++
Supporto per la Digital Transformation
++++++++++++++++++++++++++++++++++++++++++++++++
La trasformazione digitale è una priorità per molte aziende industriali, che puntano a modernizzare 
i loro impianti e processi tramite automazione, IoT, AI e analisi avanzata dei dati. 
Un'architettura monolitica può essere difficile da adattare a queste esigenze, limitando l'integrazione di nuove tecnologie.

**Microservizi**: Facilitano l'integrazione di nuovi paradigmi tecnologici come l'IoT, 
l'Industria 4.0 e la manutenzione predittiva. 
Offrono un'architettura flessibile per gestire grandi quantità di dati in tempo reale e 
permettono alle aziende di implementare strategie di trasformazione digitale in modo più efficace.

++++++++++++++++++++++++++++++++++++++++++++++++
Facilità di Deployment e Automazione
++++++++++++++++++++++++++++++++++++++++++++++++
L'automazione e il deployment continuo sono fondamentali per aziende che gestiscono complessi sistemi 
produttivi distribuiti in diverse località. 
La configurazione e il deployment di una grande applicazione monolitica possono essere lenti e complessi.

**Microservizi**: Si adattano bene agli approcci DevOps e CI/CD (Continuous Integration/Continuous Deployment). 
Permettono di automatizzare il deployment di singoli servizi e di gestire in modo efficiente 
l'infrastruttura distribuita tramite container e orchestratori come Docker e Kubernetes. 
Ciò accelera il rilascio di nuove versioni e migliora l'efficienza operativa.

++++++++++++++++++++++++++++++++++++++++++++++++
Conformità e Regolamentazioni
++++++++++++++++++++++++++++++++++++++++++++++++

Le industrie devono spesso rispettare normative complesse (es. norme di sicurezza o ambientali) 
che possono variare a seconda della regione o del mercato. 
L'aggiornamento di un'applicazione monolitica per garantire la conformità in più giurisdizioni 
può essere difficile e rischioso.

**Microservizi**: Consentono alle aziende di implementare logiche di conformità e requisiti regolatori 
specifici solo nei servizi necessari, senza dover modificare l'intero sistema. 
Questo facilita l'adattamento delle applicazioni alle normative locali e alle regole settoriali.

++++++++++++++++++++++++++++++++++++++++++++++++
Monitoraggio e Analisi in Tempo Reale
++++++++++++++++++++++++++++++++++++++++++++++++
Il monitoraggio in tempo reale è cruciale per le aziende industriali che gestiscono processi produttivi, 
dove il rilevamento immediato di guasti o inefficienze può prevenire danni o interruzioni.

**Microservizi**: Facilitano il monitoraggio dettagliato di ogni servizio e componente, offrendo 
una maggiore visibilità sui processi. I microservizi possono essere monitorati in modo indipendente, 
permettendo di analizzare i problemi in tempo reale e migliorare le prestazioni del sistema globale.


++++++++++++++++++++++++++++++++++++++++++++++++
Gestione delle Dipendenze e Interoperabilità
++++++++++++++++++++++++++++++++++++++++++++++++

In ambito industriale, le applicazioni devono spesso integrarsi con una varietà di sistemi legacy, 
impianti di produzione, robotica, sensori e strumenti di terze parti. Integrare queste dipendenze 
in un'applicazione monolitica può essere complesso e richiede un approccio monolitico pesante. 

**Microservizi**: Ogni servizio può gestire la propria integrazione con strumenti e tecnologie specifiche, 
riducendo la complessità e migliorando l'interoperabilità tra sistemi diversi. 
L'uso di API ben definite facilita l'integrazione e la comunicazione tra i vari componenti.




-------------------------------------------------
Problematiche dei microservizi 
-------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++
Gestione della complessità
++++++++++++++++++++++++++++++++++++++++++++++++
- Con i POJO (monolitico): In un'architettura monolitica, tutti i componenti risiedono nello stesso processo, il che semplifica la gestione della complessità interna. Le interazioni tra oggetti e componenti avvengono attraverso semplici chiamate di metodo e la gestione degli errori è più lineare.
- Con i microservizi: La complessità aumenta perché ogni microservizio è un'entità separata, e la comunicazione tra loro deve avvenire tramite chiamate di rete (HTTP, gRPC, messaggistica, ecc.). Questo introduce problemi di latenza, gestione degli errori distribuiti e coordinamento delle dipendenze tra i servizi.

++++++++++++++++++++++++++++++++++++++++++++++++
Comunicazione distribuita
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: Le interazioni tra i componenti avvengono tramite invocazioni di metodi locali, che sono rapide e sicure, senza il rischio di fallimenti di rete.
- Con i microservizi: La comunicazione tra i microservizi avviene tramite la rete, il che comporta latenza, errori di rete, timeout, e problematiche legate alla serializzazione/deserializzazione dei dati. Questo richiede anche la gestione delle API e protocolli di comunicazione, introducendo ulteriori livelli di complessità. Inoltre, è necessario implementare meccanismi di retry, circuit breaker, e gestione delle fallimenti parziali.


++++++++++++++++++++++++++++++++++++++++++++++++
Consistenza dei dati
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: I dati sono gestiti in un database comune all'interno di un'applicazione monolitica. È possibile garantire consistenza transazionale in modo relativamente semplice utilizzando transazioni ACID.
- Con i microservizi: Ogni microservizio potrebbe avere il proprio database, il che rende difficile garantire la consistenza transazionale globale (es. le transazioni distribuite). I microservizi spesso adottano modelli di consistenza eventuale attraverso la propagazione asincrona degli eventi o l'uso di saghe. Questo introduce complessità nella gestione dei dati e nella coerenza dei sistemi.

++++++++++++++++++++++++++++++++++++++++++++++++
Gestione delle dipendenze e orchestrazione
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: Tutte le classi e i componenti risiedono nello stesso ambiente di runtime, e le dipendenze tra di loro possono essere gestite attraverso un gestore delle dipendenze (come Maven o Gradle).
- Con i microservizi: Ogni microservizio è un'entità separata con le sue dipendenze. Questo può portare a problemi di compatibilità delle versioni tra servizi diversi. Inoltre, è necessario un sistema di orchestrazione per coordinare l'avvio, lo scaling, la gestione e l'aggiornamento di tutti i servizi, spesso con l'aiuto di strumenti come Kubernetes o Docker.

++++++++++++++++++++++++++++++++++++++++++++++++
Gestione dello stato
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: Lo stato viene gestito in memoria o attraverso il database centralizzato, ed è facile mantenere lo stato condiviso tra diversi componenti dell'applicazione.
- Con i microservizi: I microservizi dovrebbero essere stateless o mantenere uno stato isolato, poiché la gestione dello stato distribuito è complessa. Se un microservizio ha bisogno di gestire lo stato, deve fare affidamento su sistemi di storage distribuito o cache distribuita, il che introduce ulteriori complessità e sfide nella coerenza dello stato.

++++++++++++++++++++++++++++++++++++++++++++++++
Deployment e monitoraggio
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: In un'applicazione monolitica, il deployment è semplice: si distribuisce un singolo artefatto (es. un file .war o .jar) su un server. Il monitoraggio è anch'esso più semplice perché tutte le informazioni sullo stato del sistema sono in un unico posto.
- Con i microservizi: Ogni microservizio ha il proprio ciclo di vita di deployment e potrebbe essere distribuito indipendentemente. Questo richiede orchestrazione automatizzata, gestione delle versioni e coordinamento per evitare downtime. Inoltre, il monitoraggio diventa più complesso: è necessario tracciare il comportamento di ciascun microservizio, le loro dipendenze e le interazioni tra loro, spesso utilizzando strumenti come Prometheus, ELK stack o Jaeger per il tracing distribuito.

++++++++++++++++++++++++++++++++++++++++++++++++
Gestione degli errori e tolleranza ai guasti
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: Gli errori e le eccezioni possono essere gestiti in modo centralizzato, e in un ambiente monolitico è più facile fare rollback completo o ripristinare uno stato coerente in caso di guasti.
- Con i microservizi: Gli errori possono verificarsi in punti diversi del sistema, e devono essere gestiti a livello di ogni microservizio. Il fallimento di un servizio può non impattare l'intero sistema, ma i fallimenti parziali (ad es. un servizio chiave che non risponde) devono essere gestiti attentamente per evitare che il sistema vada in crash o degradi le performance. Tecniche come il circuit breaker, bulkhead pattern e retry sono essenziali per garantire la resilienza dell'architettura.


++++++++++++++++++++++++++++++++++++++++++++++++
Test e debugging
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: Il testing di un'applicazione monolitica è relativamente semplice. Si possono eseguire test unitari e di integrazione sull'intero sistema in un unico ambiente. Il debugging è diretto, poiché tutte le classi e i componenti sono parte dello stesso processo.
- Con i microservizi: Il testing diventa più complicato, poiché è necessario testare non solo i singoli servizi (test unitari) ma anche le interazioni tra di essi (test di integrazione e contratti). Il debugging di un sistema distribuito è molto più difficile a causa della natura asincrona e della comunicazione tra processi separati. Tecniche come il contract testing e l'uso di strumenti di tracing distribuito diventano fondamentali.


++++++++++++++++++++++++++++++++++++++++++++++++
Sicurezza
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: La sicurezza può essere gestita a livello di applicazione centralizzata, utilizzando autenticazione e autorizzazione in un unico punto.
- Con i microservizi: Ogni microservizio potrebbe richiedere un proprio sistema di sicurezza, o deve integrarsi in un framework di sicurezza distribuito (ad es. OAuth, JWT). Questo introduce complessità nella gestione delle credenziali, autenticazione tra microservizi, e nella protezione dei dati durante le comunicazioni. La gestione della sicurezza deve essere implementata in maniera consistente su tutti i servizi.

++++++++++++++++++++++++++++++++++++++++++++++++
Sovraccarico infrastrutturale
++++++++++++++++++++++++++++++++++++++++++++++++

- Con i POJO: Le risorse di calcolo, memoria e archiviazione sono generalmente centralizzate in un'unica applicazione. La gestione delle risorse è relativamente semplice, poiché tutte le componenti condividono lo stesso ambiente.
- Con i microservizi: Ogni microservizio richiede un proprio ambiente di esecuzione, che può comportare un aumento significativo del carico infrastrutturale. Ad esempio, potrebbero essere necessari più container, database separati, logging distribuito e capacità di gestione delle risorse. Questo può aumentare i costi operativi e richiede un'architettura cloud ben progettata per scalare in modo efficiente.

I microservizi ntroducono anche diverse problematiche e sfide rispetto all'approccio monolitico tradizionale basato su POJO.

-----------------------------------------------------
Dalla "Documentazione" al "Contratto"
-----------------------------------------------------

Nel caso dei microservizi, l'API non è più solo una descrizione, ma un Contratto (Design-First API). 
Lo standard permette di verificare che il contratto sia rispettato **prima ancora di scrivere una riga di codice**.



Ecco come i microservizi hanno guidato questa standardizzazione:

 

**OpenAPI: Lo standard de facto**

Prima dei microservizi, la documentazione delle API era spesso un file Word o un PDF scritto a mano. 
Con i microservizi è nato il bisogno di una documentazione **leggibile dalle macchine**.

- **Perché:** Se ho molti microservizi, non posso scrivere manualmente il client per ognuno.
- **Risultato:** È nato lo standard **OpenAPI**. Grazie a questo formato (JSON/YAML), 
  si può generare automaticamente il codice, i test e l'interfaccia grafica per testare l'API.

 

**Standard per il trasporto e le prestazioni: gRPC**

REST (HTTP/JSON) è ottimo ma "pesante" per la comunicazione interna tra migliaia di microservizi.

- **L'innovazione:** Google ha promosso *gRPC*, che utilizza **Protocol Buffers (protobuf)** come linguaggio 
  di descrizione dell'interfaccia. 
- **Lo standard:** *gRPC* definisce in modo rigoroso come i servizi si chiamano tra loro, 
  garantendo che un servizio in Java possa parlare con uno in Go senza ambiguità e con prestazioni elevatissime.

 

**Standard per gli Eventi: AsyncAPI**

Come abbiamo visto prima, le architetture software moderne sono spesso "Event-Driven".

- **La necessità:** Come standardizzare il formato dei messaggi che passano su Kafka o RabbitMQ?
- **Risultato:** È nato **AsyncAPI**, che ricalca la struttura di OpenAPI ma la adatta ai sistemi di messaggistica asincrona.

 

**Standard per l'osservabilità: CloudEvents**

In un sistema a microservizi, un evento (es. "Ordine Creato") può viaggiare tra sistemi diversi (AWS, Azure, server locali). 

- **Il problema:** Ogni sistema scriveva i metadati (ora, origine, ID) in modo diverso.
- **Lo standard:** La Cloud Native Computing Foundation (CNCF) ha creato **CloudEvents**, 
  un formato standard per descrivere i dati degli eventi in modo che siano interpretabili da qualsiasi piattaforma.

 

**Standard per la sicurezza: OAuth2 e JWT**

Con centinaia di microservizi, non si può chiedere il login ogni volta che un servizio ne chiama un altro.

- **La soluzione:** Si sono diffusi standard come **OAuth2** e **OpenID Connect**, insieme ai **JWT (JSON Web Tokens)**. 
  Questi standard permettono a un servizio di "fidarsi" dell'identità dell'utente passata da un altro servizio 
  tramite un "passaporto" digitale standardizzato.



--------------------------------------------------
Progettazione dei microservizi 
--------------------------------------------------

- Richardson: https://microservices.io/index.html
 
- Richardson Understanding Microservices (si veda il video): 
  https://microservices.io/microservices/2020/02/04/jfokus-geometry-of-microservices.html

- Richardson Microservice architecture patern languages: https://microservices.io/patterns/index.html
   
- Richardson Decomposizione per sottodominio: https://microservices.io/patterns/decomposition/decompose-by-subdomain.html : 
      
- Richardson Microservice Architecture: https://microservices.io/patterns/microservices.html :  
- Api Gateway, Service Discovery, Circuit Breaker, Event Sourcing, CQRS, Saga, etc. 
- Il concetto di `aggregator`. Un possibile riferimento 
  https://medium.com/nerd-for-tech/design-patterns-for-microservices-aggregator-pattern-99c122ac6b73





.. _Il linguaggio qak:

====================================================
Il linguaggio qak
====================================================

Nei capitoli precedenti abbiamo introdotto l'idea 
che gran parte del software contemporaneo possa essere descritto come un ecosistema 
di servizi e attori, considerando gli **attori**
come  un (nuovo) :ref:`paradigma computazionale<Gli attori come nuovo paradigma?>`
più adeguato ad affrontare le problematiche architetturali e computazionali 
di questa nuova generazione di sistemi.

Su questa base, abbiamo definito alcune librerie e classi per cercare di colmare 
:ref:`L'Abstraction gap` che si manifesta rispetto a Java, la nostra tecnologia-base di riferimento.
Ricordiamo in particolare:

- :ref:`unibo.basicomm23-1.0`.jar: un insieme di classi per superare le differenze tecnologiche relative 
  ai diversi protocolli di comunnicazione di rete, attraverso la introduzione del
  concetto (astratto) di :ref:`Interconnessione`
- :ref:`AbstractProtoactor`:  una classe come un *MicroFramework* per la costruzione di componenti 
  ispirati al modello ad attori.

Nella sezione :ref:`Oltre comportamenti message-driven`, abbiamo ipotizzato una **evoluzione**
del *MicroFramework* basata sulla idea che sia un attore a **decidere quando elaborare**
un messaggio, in modo da conciliare meglio il suo comportamento reattivo (di risposta ai messaggi)
con il suo comportamento proattivo.

Questo obiettivo può ancora essere raggiunto introducendo una libreria. Infatti:

- la libreria **unibo.qakactor23-5.0.jar**  fornisce il supporto che realizza il concetto 
  di attore come un **Automa  Stati Finiti** 
  (precisamente come una `Macchina di Moore`_), le cui transizioni di stato possono essere 
  dovute a decisioni interne ed autonome e/o alla volontà dell'attore di elaborare un messaggio.

----------------------------------
Attori qak
----------------------------------

Il concetto di attore che 'emerge' dalla libreria *unibo.qakactor23-5.0.jar* viene denominato :ref:`QActor`.
La libreria implementa i componenti *QActor* come 
specializzazione classe astratta :ref:`it.unibo.kactor.ActorBasicFsm.kt`
che a sua volta specializza la classe astratta **it.unibo.kactor.ActorBasic.kt**.

La ragione del prefisso **Q** (che significa **quasi**) nasce percheè
vi sono molteplici modi di concepire il concetto di *QActor*,
che è **interpretabile** in modi diversi:

.. La pluralità di possibili interpretazioni del concetto di QActor è la ragione del prefisso Q, 
   che significa **quasi** . Infatti gli attori sono il paradigma di riferimento di base, 
  ma l'intento è esprimere anche gli altri tipi di enti.


#. un **macro-componente** del sistema che opera seguendo il 
   :ref:`paradigma computazionale degli attori<Gli attori come nuovo paradigma?>`
#. un **nano-servizio**  che interagsice con altri nano-servizi del suo ambiente locale (una JVM)
   mediante canali Kotlin
#. un **(micro)servizio** che interagisce con il mondo esterno via TCP o MQTT
#. una **risorsa CoAP** che interagisce con il mondo esterno mediante il paradigma REST
#. un **componente cognitivo** dotato di una base di conoscenza interna e di capacità inferenziali 
   fornite da un interprete Prolog.

Un QActor **non è** un :ref:`Agente` vero e proprio, ma possiede proprietà e meccanismi che 
facilitiano la costruzione di agenti capaci di interagire tra loro e con l'ambiente.

Un **QActor cognitivo**  integra le sue azioni
con una base di conoscenza logica interna (``KB = fatti + regole``), che abilita ragionamento simbolico, 
inferenza e decisione basata sul contesto.


--------------------------------------------
Non solo libreria: il liguaggio qak
--------------------------------------------

Ma ora, la novità importante è che i concetti e i meccanismi realizzati dalla libreiria
sono formalmente esprimibili medianate un linguggio, dotato di una precisa 
sintassi e di una semantica operazionale definita proprio dalla libreria.

- la libreria smette di essere solo una collezione di strumenti e diventa 
  il **runtime** (sommerso) di un linguaggio denminato **qak**.

- la sintassi astratta di **qak** viene mappate direttamente sulle chiamate alla libreria
  (**proiezione semantica**).

++++++++++++++++++++++++++++++++++++++
Il q e il k in qak
++++++++++++++++++++++++++++++++++++++

Il 
prefisso **q**, che significa **“quasi”** (**a** sta per **actor**)
ha le stesse motivazioni del prefisso **Q** introdotte in precedenza.

Il suffisso **k**  significa **Kotlin** e richiama il fatto che ogni QActor è realizzato come 
:ref:`coroutine<La coroutine un nuovo vecchio concetto>` kotlin. 
Ciò permette la attivazione in una stessa JVM di migliaia di QActor, agevolando
la sperimentazione di fenomeni emergenti in sistemi formati da molti attori.
(:ref:`More is different`).

++++++++++++++++++++++++++++++++++++++++++++++++++++
La Proiezione Linguistica della Libreria. 
++++++++++++++++++++++++++++++++++++++++++++++++++++

Proiettare la libreria in un linguaggio, implica operare una trasformazione dei livelli di astrazione:

- **Livello Operativo** (libreria): Si concentra sui dettagli implementativi, sulla gestione dello stato 
  e sull'esecuzione (il "Come"). È complicato perché deve realizzare in modo opportuno 
  diversi meccanismi e poictiche di interazione.
- **Livello Espressivo** (linguaggio): Si concentra sull'intento del dominio. Eliminando il "rumore" 
  sintattico di Java (punti e virgola, tipi verbosi, boilerplate), si permette all'utente di 
  manipolare i concetti della libreria come se fossero **primitive del pensiero**.

Inoltre, si può difre che:

- La libreria  definisce lo **spazio delle possibilità**, mentre il linguaggio **qak**
  definisce il **modo di navigare questo spazio**.
- Invece di forzare l'utente a scrivere codice Java, si offre una "lente" (il linguaggio) 
  che restringe il campo d'azione esattamente a ciò che la libreria sa fare
  (si veda :ref:`ali e catene<Il motto di Alan Kay>`), 
  potenziandone però la leggibilità e la verifica formale.
  
  .. (grazie al sistema di tipi di Xtext).



.. _Come è stato realizzato Qak:

-------------------------------------------
Dalla libreria al linguaggio
-------------------------------------------

L'implementazione del Linguaggio Qak si basa du due parti principali:

- Il **Metamodello Qak**: definisce la sintassi e la semantica del linguanisceggio Qak, 
  basandosi sul framework **Xtext**. L'ecosistema **Eclipse** viene ampliato con appositi plugin
  così da realizzare la :ref:`Qak software factory`, che include
  un **editor guidato dalla sintassi**, e 
  un generatore di codice Kotlin che realizza la semantica del linguaggio.

- La **Qak infrastructure**: fornisce l'infrastruttura di runtime per eseguire i QActors 
  generati dal codice Qak. 

.. image:: ./_static/img/qakSoftwareFactory.png
          :align: center
          :width: 60%

.. _Qak infrastructure:

++++++++++++++++++++++++++++++++++++++
Qak infrastructure
++++++++++++++++++++++++++++++++++++++

E' defnita dalla libreria **unibo.qakactor23-5.0.jar** che 
implementa i QActor applicativi come specializzazione classe astratta :ref:`it.unibo.kactor.ActorBasicFsm.kt`
che a sua volta specializza la classe astratta **it.unibo.kactor.ActorBasic.kt**.

.. _Qak software factory:

++++++++++++++++++++++++++++++++++++++
Qak software factory
++++++++++++++++++++++++++++++++++++++
 
La factory (**Qak software factory**) genera il codice necessario 
per 'mappare' i concetti di alto livello (espressi nel modello definito dall'utente) 
in strutture di più basso livello, che possono essere eseguite avvelendosi di appositi supporti 
e librerie di utilità  application-independent.

La *Qak software factory* è legata alla definizione del linguaggio :ref:`qak come DSL`.

.. _qak come DSL:

++++++++++++++++++++++++++++++++++++++
qak come DSL
++++++++++++++++++++++++++++++++++++++

Il *Linguaggio qak* è definito come un :ref:`DSL Esterno` con lo scopo di:

- fornire agli ingegneri gli strumenti formali per definire e gestire 
  alcuni fondamentali 'meccanismi semantici' di comunicazione tra componenti software distribuiti
- proseguire nel solco della `Model-Driven engineering`_, con lo scopo di agevolare
  la rapida costruzione/prototipazione  di  **modelli eseguibili** di un sistema software, 
  utili (se non indispensabili) nelle fasi preliminari la progettazione, quali la analisi e la formalizzazione/ 
  dei requisiti e l'analisi del problema applicativo da risolvere
- assumere l':ref:`Actor Model<Gli attori come nuovo paradigma?>` come modello computazionale di base
 

  .. Non comunicare condividendo la memoria piuttosto, condividi la memoria comunicando 
 
L'idea alla base del *Linguaggio qak* è che un sistema software è composto da un insieme di 
:ref:`attori<Gli attori come nuovo paradigma?>` (detti **QActor**)
che interagsicono mediante messaggi scambiati in modo **asincrono**.


.. list-table::
  :widths: 45,50
  :width: 100%

  * - Un sistema qak è composto da una collezioni di :ref:`QActor`, attivati in uno o più :ref:`Context`,
      allocati in uno o piò nodi di elaborazione.

    - .
    
      .. image:: ./_static/img/Actor24sysqak.PNG
          :align: center
          :width: 100%


.. _QActor:

--------------------------------------
QActor
--------------------------------------

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - Un attore qak è un componente attivo che:
 
      - nasce, vive e muore in un :ref:`contesto<QakActors25: il contesto>` che può essere comune a (molti) altri attori;
      - ha un **nome univoco** nell'ambito di tutto il sistema;
      - è logicamente attivo, cioè dotato di flusso di controllo autonomo;
      - è capace di inviare messaggi ad un altro attore, di cui conosce il **nome**, incluso sè stesso;
      - è capace di eseguire elaborazioni autonome e/o elaborazioni di messaggi;
      - è dotato di una sua `coda locale` (**msgQueue**) in cui sono depositati i messaggi 
        a lui inviati da altri attori (dello stesso contesto o di contesti remoti) 
        oppure da componenti esterni al sistema.


    - . 
    
      .. image:: ./_static/img/actor24.png
          :align: center
          :width: 90%

 
.. _Context:

--------------------------------------
Context
--------------------------------------
 
Un QActor fa sempre parte di un componente detto **Context** che assume 
diversi, importanti ruoli. Un **Context**:

#. rappresenta un nodo di elaborazione, csstituito da una JVM che opera su un computer 
   fisico denotato da un indirizzo IP e una port 
#. include una base di conoscenza Prolog (``SYSKB``) che descrive tutto il sistema come collezione di Context   
   e di QActor all'interno dei Context
#. funge da gestore dell'insiene di QActor locali al Context
#. **abilita le comunicazioni** remote tra QActor, sfruttando la ``SYSKB`` per:

   - conoscere il *Context* (e quindi il nodo computazionale) del destinario di un messaggio
   - recapitare un messaggio ricevuto con il **protocollo di default TCP**, 
     che abbia un suo QActor locale come destinatario 

Il *Context* permette a un numero ``N>0`` di QActor di **condividere** i supporti necessari
a rendere gli attori capaci di ricevere e trasmettere messaggi, sia attraverso la rete,
sia usando la memoria dalla JVM su cui operano.

In altre parole, rispetto alla architettura introdotta in :ref:`Protoattori` i server 
del tipo javalin o i supporti MQTT **non sono incapsulati** in ogni QActor, ma sono 
definiti una volta sola nel *Context*.



.. list-table::
  :widths: 70,30
  :width: 100%
  
  * - Un contesto rappresenta un nodo logico di elaborazione dotato di server e di un porta di ingresso, 
      su cui altri contesti possono stabilire una :ref:`Interconnessione`, di solito basata su ``TCP``,
      ``CoAP`` e ``MQTT``.

      Un contesto deve essere allocato su un computer fisico o su un  virtual machine / container.

      .. Si veda :ref:`unibo.basicomm23.actors23.ActorContext23`

    - .

      .. image:: ./_static/img/actor24Ctx.png
          :align: center
          :width: 100%

  * - Un contesto mantiene una tabella  (**actorMap**)  con i riferimento agli attori locali e una tabella 
      (**proxyMap**) con i riferimenti ai Proxy che mantengono una :ref:`Interconnessione` con gli altri Context
      del sistema.

      .. Si veda :ref:`unibo.basicomm23.actors23.ActorBasic23` e   :ref:`unibo.basicomm23.actors23.Proxy`
    
    - .
    
      .. image:: ./_static/img/actor24CtxMaps.png
          :align: center
          :width: 100%


 
--------------------------------------
Uno sguardo alla sintassi di qak  
--------------------------------------

La descrizione della sintassi del linguaggio qak è riporata in `Qaksyntax`_.

In Xtext, la grammatica è scritta in un dialetto della Notazione d:ref:`Backus-Naur Estesa (EBNF)<La analisi sintattica>`, 
dove ogni regola non solo descrive cosa il parser deve leggere, ma anche **come trasformarlo** 
in un oggetto Java (di classe-base **EObject**).


Riportare qui tutte le regole sintattiche non è opportuno; tuttavia può essere utile dare uno sguardo ad alcune regole, 
utili per la specifica dei messaggi e per la gestione dei payload dei messaggi.


.. _Messaggi qak:

+++++++++++++++++++++++++++++++++++++++
Messaggi qak
+++++++++++++++++++++++++++++++++++++++

.. mediante le :ref:`Azioni per la trasmissione dei messaggi`

I messaggi che i **QActor** possono scambiarsi  
sono di tre tipi: **Dispatch**, **Request** (con **Reply**), ed **Event**, 
caratterzzati dai seguenti *Pattern*:

.. list-table:: 
  :widths: 15,30,20,35
  :width: 100%

  * - **Tipo msg**      
    - **Destinatario**
    - **Risposta**
    - **Uso**
  * - **Dispatch**      
    - Esplicito
    - No
    - Comandi, notifiche
  * - **Request**      
    - Esplicito
    - si (**Reply**)
    - Query (asincrone)
  * - **Event**      
    - Implicito 
    - No
    - Notifiche

I messagi con destinatrio esplicito devono designare il nome (``ID``) del QActor destinatario.

La sintassi dei messaggi è definita dal seguente frammento della grammatica qak:

.. code::

  Message : BasicMessage | Event | OtherMsg;
  BasicMessage: Dispatch | Request;
  OtherMsg : Reply | ... ;

  Event:    "Event"    name=ID ":" msg = PHead (cmt=STRING)?;
  Dispatch: "Dispatch" name=ID ":" msg = PHead (cmt=STRING)?;
  Request:  "Request"  name=ID ":" msg = PHead (cmt=STRING)?;
  Reply:    "Reply"    name=ID ":" msg = PHead ("for" reqqq=[Request])?(cmt=STRING)?;

Il non-terminale :ref:`PHead` descrive :ref:`Notazioni ispirate ai termini Prolog`.
Rimandando ulteriori dettagli alle sezioni relative, anticipamo qui che 
sono espressi cone **Atomi Prolog**:

- i nomi dei `QActor`_ (tutte minuscole, come ulteriore vincolo)
- i nomi dei `Context`_  (tutte minuscole, come ulteriore vincolo)
- i nomi dei messaggi e i nomi dei loro **payload**

.. note::

  Gli **Atomi** sono in  Prolog i **Termini** più semplici, quali ad esempio:

  - un nome che inizia con una lettera minuscola 
    e può essere seguito da lettere (maiuscole o minuscole), cifre (``0-9``) e il carattere underscore (``_``).
  - qualsiasi sequenza di caratteri racchiusa tra virgolette singole  
  - i simboli ``true``, ``fail``, ``[]`` (lista vuota) .





 
--------------------------------------
Descrivere un sistema in qak
--------------------------------------
Ricordando la :ref:`Visione WhiteBox` di un sistema, possiamo sintetizzare le capacità espressive del *Linguaggio qak*
nella tabella che segue:


.. list-table:: 
  :widths: 20,80
  :width: 100%

  *
    - **Struttura**      
    - Un sistema qak è composto da enti computazionalmente completi detti :ref:`QActor`, 
      contenuti in uno o più :ref:`Context`.

      Un :ref:`QActor` può contenere ed usare uno o più oggetti espressi in ``Java`` e/o ``Kotlin``, 
      con l'avvertenza che questi **non devono introdurre accessi concorrenti** a memoria comune
  *
    - **Comportamento** 
    - Un QActor si comporta (ed è strutturalmente organizzato) come un **Automa  Stati Finiti** 
      (precisamente come una `Macchina di Moore`_) e 
      può eseguire azioni (:ref:`Azioni di un QActor`) sia  di alto livello (*azioni qak*) sia di basso livello
      (qualunque *azione kotlin*)
      
      Il comportamento di QActor è:

      - **proattivo**, in quanto può eseguire azioni in autonomia, comportandosi di fatto come un :ref:`Agente`
      - **reattivo**, in quanto capace di reagire a messaggi che provengono da altri QActor o da 
        componenti software esterni al sistema.

  *
    - **Interazione** 
    - I QActor interagiscono scambiandosi :ref:`messaggi<Messaggi qak>`, secondo il motto: 

      .. code::

        Non comunicare condividendo la memoria. 
        Piuttosto, condividi memoria comunicando.


La descrizione di un sistema software nel linguaggio qak esprime:

#. una :ref:`Vista esterna` del sistema, costituita dall'insieme dei :ref:`Messaggi qak` usati dai :ref:`QActor`
   e dall'insieme dai :ref:`Context` che compongono il sistema
#. una :ref:`Vista interna` di ogni QActor, che ne rappresenta il comportamento come un 
   :ref:`automa a stati finiti<QActor come FSM>`
   (`Macchina di Moore`_)

.. _Azioni di un QActor:

+++++++++++++++++++++++++++++++++++++++++++
Azioni di un QActor
+++++++++++++++++++++++++++++++++++++++++++

Un QActor può eseguire *azioni qak* e *azioni Kotlin*. 

- Le **azioni qak** che consideriamo al momento, sono principalmente connesse 
  alla trasmissione e ricezione di messaggi, trasparenti rispetto ai meccanismi implementativi 
  e alla dislocazione fisica dei QActor. :ref:`Altre azioni qak` verranno introdotte in seguito.
- Le **azioni kotlin** sono espresse da codice Kotlin racchiuso tra i simobli **[#** e **#]**.
  La possibilità di esprimere queste azioni rende il linguaggio 
  :ref:`Computazionalmente completo`

.. _Azioni per la trasmissione dei messaggi:

++++++++++++++++++++++++++++++++++++++++++++++++
Azioni per la trasmissione dei messaggi
++++++++++++++++++++++++++++++++++++++++++++++++

A ciascun tipo di messaggio corrisponde, nel linguaggio qak, una specifica azione (sempre asincrona)
per la sua trasmissione.

.. list-table:: 
  :widths: 20,80
  :width: 100%

  *
    - **forward**    
    - azione connessa all'invio di un **dispatch** a un destinatario, di cui si conosce il nome  
  *
    - **request**    
    - azione connessa all'invio di una **request** a un destinatario, di cui si conosce il nome  
  *
    - **replyTo**    
    - azione connessa all'invio di una **reply** relativa a una specifica richiesta  
  *
    - **emit**    
    - azione connessa alla emissione di un **event**  verso tutti i QActor del sistema 
  *
    - **emitlocal**    
    - azione connessa alla emissione di un **event**  verso i QActor dello **stesso Context** dell'emettitore 
  *
    - **emitlocalstream**   
    - azione connessa alla emissione di un **event**  verso i QActor dello stesso Context dell'emettitore  
      che si sono **eplicitamente dichiarati interessati**.


.. _Azioni per la ricezione dei messaggi:

++++++++++++++++++++++++++++++++++++++++++++++++
Azioni per la ricezione dei messaggi
++++++++++++++++++++++++++++++++++++++++++++++++ 

Non esiste una azione esplicita (una *receive*) per la ricezione dei messaggi.
La ricezione dei messaggi è connessa alla specifica della **transizione tra stati**
dell'automa a stati finiti che modella il comportamento di un QActor.
Per un primo esempio, si veda :ref:`Un esempio di sistama qak con Claude`.


.. _Come un QActor gestisce i messaggi ricevuti:

++++++++++++++++++++++++++++++++++++++++++++++++
Come un QActor gestisce i messaggi ricevuti
++++++++++++++++++++++++++++++++++++++++++++++++

.. list-table::
  :widths: 30,70
  :width: 100%


  * - Un Server di contesto del :ref:`Context` depone i messaggi :ref:`IApplMessage<unibo.basicomm23.interfaces.IApplMessage>`
      ricevuti su una :ref:`Interconnessione` sulla  ``msgQueue`` 
      dell'attore destinatario.

      ---

      La figura mostra il caso di attori locali ad un nodo di elaborazione che possono 
      inviare/ricevere messaggi tra loro oppure elaborare messaggi inviati
      da componenti remoti.
    - .
    
      .. image:: ./_static/img/Actors24SingleNodeAndCtx.png
          :align: center
          :width: 100%

Il funzionamento di un QActor può essere descritto come segue:

#. Un QActor è dotato di una sua coda locale (**msgQueue**) in cui sono depositati i messaggi a lui inviati.
#. Un QActor possied una seconda coda (**msgQueueStore**), 
   in cui memorizza messaggi (di tipo *request* e *dispatch*) non ancora elaborati.
#. Ogni stato di un QActor può specificare una **Transition** in cui si specifica lo stato futuro da raggiungere
   in corrispondenza alla ricezione di un messaggio con uno specifico identificatore *msgId*.
#. Al termine delle sue azioni, lo stato corrente del QActor consulta, nell'ordine, 
   le sue code *msgQueueStore* e *msgQueue*, ciascuna in modo FIFO.

  - Se l'identificatore del messaggio prelevato da una coda è uguale a un *msgId* della *Transition* dello stato corrente, 
    si attiva il passaggio allo stato futuro corrispondente.
    Se no, un messaggio in  *msgQueueStore* viene lasciato dove è; oppure, 
    se è una *request* o un *dispatch* in *msgQueue*, viene trasferito in fondo alla coda *msgQueueStore*.

  - Un messaggio di tipo **event** in *msgQueue* il cui identificatore non compare nella *Transition* dello stato corrente, 
    viene scartato (e quindi **ignorato e dimenticato**).
 
  - Se nessuna transizione è attivabile in base ai messaggi nelle code, il QActor  rimane nello stato corrente; 
    all'arrivo di un nuovo messaggio, si riprende ad eseguire il punto 3. 



++++++++++++++++++++++++++++++++++++++++++++++++
Altre azioni qak 
++++++++++++++++++++++++++++++++++++++++++++++++

Oltre alla possibilità di specificare azioni di alto livello per la trasmissione di messaggi,
il linguaggio qak offre azioni 'primitive' che risultano importanti in molte appòicazioni.

In attessa di approfondire queste ulteiori azioni nei progetti che faremo, ne riportiamo qui un elenco:

- azioni di accesso al contenuto (payload) dei messaggi (si veda :ref:`onMsg`)
- azioni condizionali (scelte)
- operazioni per l'uso della base di conoscenza Prolog
- azioni relative alla osservabilità dello stato interno di un QActor
- azioni di delegazione di un messaggio ad un altro QActor dello stesso Context
- azioni per la creazione deinamica di attori locali allo stesso Context
- operazioni per l'uso di intereazioni mediante MQTT
- operazione di ritorno da uno stato di gestione di un messaggio visto come interruzione


.. _QActor come FSM:

+++++++++++++++++++++++++++++++++++
QActor come FSM
+++++++++++++++++++++++++++++++++++

Il linguaggio qak forza la descrizione del comportamento di un QActor  come una `Macchina di Moore`_ 
a stati finiti.

In altre parole, non sono i messaggi ricevuti a determinare il comportamento di un QActor, 
ma è un QActor che **decide** quali azioni compiere e quali messaggi ricevere ed elaborare 
in un dato momento (stato) della sua vita.


Ogni QActor: 

- possiede uno  **unico stato iniziale**
- possiede uno **stato corrente** di esecuzione
- può eseguire **azioni** in ogni stato
- può eseguire **transizioni** tra stati, come conseguenza della ricezione di messaggi 
  o come decisione autonoma (**Goto**)

Notiamo che

- la struttura a stati finiti (FSM) di un QActor non limita la sua capacità computazionale,
  in quanto ogni stato può eseguire azioni di calcolo di complessità arbitraria;
- la struttura FSM di un QActor facilita la comprensione del suo comportamento,
  in quanto ogni stato può essere visto come una modalità operativa ben definita.
- inoltre, la struttura FSM di un QActor facilita:
  
  - la **analisi** e la **verifica** del suo comportamento,
    in quanto è possibile esaminare tutte le transizioni tra stati e le azioni associate a ciascuno stato.
  - la **progettazione** e la **implementazione** del suo comportamento,
    in quanto è possibile suddividere il comportamento complessivo in sotto-comportamenti associati a ciascuno stato.
  - la **manutenzione e l'evoluzione** del suo comportamento,
    in quanto è possibile modificare o aggiungere stati e transizioni senza alterare l'intero comportamento.
  - il **testing** del suo comportamento,
    in quanto è possibile isolare e testare singoli stati e transizioni.
  - la **documentazione** e la comunicazione del suo comportamento,
    in quanto è anche possibile rappresentare graficamente il comportamento mediante diagrammi di stati.
  - l'**ottimizzazione** delle prestazioni,
    in quanto è possibile identificare e migliorare gli stati e le transizioni critiche. 

Osserviamo anche che:

- un QActor **solo proattivo** non esprime
  transizioni basate sulla ricezione di messaggi, ma solo transizioni autonome (**Goto**).
- un QActor che entra in un loop computazionale infinito in uno stato, 
  non è in grado di gestire messaggi ricevuti.



.. _Un esempio di sistama qak con Claude:

----------------------------------------------
Un esempio di sistama qak con Claude
----------------------------------------------

Da neofiti del linguaggio qk, proviamo a chidere a *Claude* (una AI versate nel coding) di costruire 
per noi un primo sistema.

.. note::

  Prompt per Cluade: Vorrei il codice di un sistema espresso nel linguaggio qak in cui un attore  di nome 'worker' 
  riceve la richiesta del valore dell'ora corrente nella forma HH::MM::SEC
  da parte di un altro attore di nome 'caller'. 

Claude risponde fornendo il codice che segue:

.. code::

  System timesystem

    // Messaggio di richiesta dell'ora corrente
    Request gettime : gettime(X)
    // Messaggio di risposta con l'ora corrente
    Reply currenttime : currenttime(TIME) for gettime 
                            //(1) for clause (optional) Added

  Context ctx ip [host="localhost" port=8050]

    QActor caller context ctx {
      State s0 initial {
         delay 1000
          println("Caller: richiedo l'ora corrente al worker")
          request worker -m gettime : gettime(now)
      }
      Transition t0 whenReply currenttime -> handleResponse
          
      State handleResponse {
          onMsg(currenttime : currenttime(TIME)) {
            println("Caller: ho ricevuto l'ora corrente: ${payloadArg(0)}")
          }
          [# System.exit(0) #] //(2) Added to terminate
          }
          //Goto s0  //(3) Removed to avoid loop
      }

    QActor worker context ctx {
      State s0 initial {
        println("Worker: in attesa di richieste...")
      }
      Transition t0 whenRequest gettime -> sendTime
          
      State sendTime {
    /*4*/onMsg(gettime : gettime(X)) {
          println("Worker: ricevuta richiesta, invio l'ora corrente")
          [# val now        = java.time.LocalTime.now().toString()
             val formatter  = 
              java.time.format.DateTimeFormatter.ofPattern("HH:mm:ss")
            val CurrentTime = "'"+now.format(formatter)+"'" 
                                //(5) Apici Added since Prolog term            	
          #]
          replyTo gettime with currenttime : currenttime($CurrentTime) 
                                //(6) CurrentTime e non currentTime
          }
        }
        Goto s0
      }

Il codice è corretto tranne al punto **(6)**, in cui il nome della variabile deve  
**iniziare con una maiuscola**, per vincoli sintattici sull'uso dell'operatore di referenziamento ``$`` 
entro la specifica del payload della reply.

Le modifiche al codice negli altri punti sono migliorie opzionali:

#. La clausola for correla la **reply** a un precisa **request**
#. Induce la terminazione del sistema, che rimerrebbe attivo per via dei server di contesto
#. Viene eliminato il ritorno allo stato  ``s0`` del *caller*, per evitare un ciclo infinito di richieste
#. La frase è corretta e permette di estrarre il valore del payload di un messaggio,
   come spiegato in :ref:`onMsg` (si veda anche :ref:`Azioni per la ricezione dei messaggi`)
#. Il valore *CurrentTime* viene incluso tra apici, in quanto il payload della *reply* 
   deve essere espresso da un atomo Prolog. 

.. _onMsg:

+++++++++++++++++++++++++++++++++++++++++
onMsg
+++++++++++++++++++++++++++++++++++++++++

La frase qak: 

.. code::

  onMsg( gettime : gettime(X) ){ ... }

ubbidisce alla seguente *regola sintattica*:

.. code::

  MsgCond: "onMsg" "(" message=[Message] ":" msg = PHead ")"
     "{" ( condactions += StateAction )*  "}"
     ("else" ifnot = NoMsgCond )? ;

  NoMsgCond: "{" (  notcondactions += StateAction )*  "}";

La sua **semantica** è la seguente:

- esegue il body *condactions* solo se il messaggio corrente (variabile **currentMsg**) 
  ha msgId ``gettime`` (in questo caso)
  e può essere **unificato** in Prolog con il *template* di messaggio definito nella dichiarazione 
  (``gettime(X)`` nella Dichiarazione dei messagg)
  e con il template specificato `gettime(X)`` (in questo caso).


+++++++++++++++++++++++++++++++++++++++++
Dal concentrato al distribuito
+++++++++++++++++++++++++++++++++++++++++

L'esempio prodotto da Claude introduce due attori nello stesso contesto.
Lo scambio di messaggi tra questi attori avviene usando la memoria della JVM 
in cui gli attori operano e non implicano l'uso della rete.

Volendo trasformare il sistema da concentrato a distribuito,
occorre introdurre un secondo Contesto (ad ese. **ctx1**) ed includere uno 
dei due attori in questo nuovo contesto. 

In questo modo si divide il sistema in due sottosistemi, che vengono concettualmente 
'legati' dalla specifica dello stesso insieme di messaggi e dalla specifica 
die contesti. 
Ad esempio:

**Sottositema caller**

.. code::

  System timesystem
    Request gettime   : gettime(X)
    Reply currenttime : currenttime(TIME) for gettime 

  Context ctx  ip [host="localhost"    port=8050]
  Context ctx1 ip [host="192.168.22.2" port=8060]

    QActor caller context ctx {
      State s0 initial {
         delay 1000
          println("Caller: richiedo l'ora corrente al worker")
          request worker -m gettime : gettime(now)
      }
      Transition t0 whenReply currenttime -> handleResponse
          
      State handleResponse {
          onMsg(currenttime : currenttime(TIME)) {
            println("Caller: ho ricevuto l'ora corrente: ${payloadArg(0)}")
          }
          [# System.exit(0) #]  
          }
      }                            

      ExternalQActor worker context ctx1


- Il contesto **ctx**  opera ora sul nodo di indirizzo ``IP=localhost`` con porta di accesso ``8050``.
- Il contesto **ctx1** opera ora sul nodo di indirizzo ``IP=192.168.22.2`` con porta di accesso ``8060``.

.. note::

  Ciascun componente sarà ora sviluppato in un progetto Java specifico,
  all'interno di un workspace specifico, in uno stesso computer o in due computer diversi.

  La :ref:`Qak software factory` genera codice solo per gli attori definiti in  
  un contesto che come IP il valore **localhost**. 

La frase ``ExternalQActor ...`` specifica che l'attore **worker** si trova su un  nodo
diverso da *caller* e può essere considerato come un altro componente del sistema,
di cui non si conosce la struttura interna.

Il codice di **caller** non cambia, anche se ora i messaggi dovranno essere scambiati via 
rete (con protocollo di deafault **TCP**). A questo penserà la :ref:`Qak infrastructure`
sulla base delle **conoscenze** racchise nel :ref:`Context`.

Il sottosistema che rappresenta il *worker* viene specificato in modo simile,
ma **senza inrodurre**:

- la specifica di ``Context ctx``
- la frase ``ExternalQActor ...``

Infatti il *Sottositema worker* opera come un **servizio** a sè stante, 
che può operare senza conoscere quali saranno i possibili 'caller' e dove 
essi si potranno trovare. 

L'unica **conoscenza necessaria è l'insieme dei messaggi** che garantiscono la 
possibilità di comunicazione (comprensione) tra le diverse parti.

**Sottositema worker**

.. code::

  System timesystem
    Request gettime   : gettime(X)
    Reply currenttime : currenttime(TIME) for gettime 

  Context ctx1 ip [host="192.168.22.2" port=8060]
  
    QActor worker context ctx {
      State s0 initial {
        println("Worker: in attesa di richieste...")
      }
      Transition t0 whenRequest gettime -> sendTime
          
      State sendTime {
        onMsg(gettime : gettime(X)) {
          println("Worker: ricevuta richiesta, invio l'ora corrente")
          [# val now        = java.time.LocalTime.now().toString()
             val formatter  = 
              java.time.format.DateTimeFormatter.ofPattern("HH:mm:ss")
            val CurrentTime = "'"+now.format(formatter)+"'"        	
          #]
          replyTo gettime with currenttime : currenttime($CurrentTime) 
          }
        }
        Goto s0
      }

Notiamo che, dal punto di vista del *worker*, non si ha una chiara visione di quali 
parti compongono il 'sistema' di cui fa parte.

Tuttavia il  *worker* 'sa' (o assume) che potranno 'fare sistema' con lui tutti i 
componenti che **'parlano' il suo stesso linguaggio**, 
come detto in :ref:`Conoscere per comunicare`.
 

---------------------------------------------------------
Impatto di qak sul processo di sviluppo
---------------------------------------------------------

Come anticipato in :ref:`qak come DSL`, il linguaggio qak ha come scopo la definzione 
di **modelli eseguibili** di un sistema software distribuito
e vuole fornire uno strumento più adatto (in quanto esplicitamente orientato allo scopo) 
rispetto a UML per abbattere i costi di produzione di un sistema distribuito.

La possibilià di definire fin dalle fasi di analisi del problema l'**architettura** di un 
sistema distribuito in termini di un modello eseguibile costitusice un solido punto di 
partenza per la progettazione e la costruzione cooperativa di un sistema software.

Operatori umani diversi (customer, responsabili aziendali, sviluppatori) possono trovare 
nel modello qak un **punto di confronto e reciproca comprensione**, 
premessa indispensabile per uno sviluppo consapevole, condiviso e motivato del prodotto, 
cioè per il passaggio da **WHAT** (cosa) a **HOW** (come).

Questo passaggio può essere visto e svolto come un **processo evolutivo** di 
trasformazione/specializzazione di questa del modello di partenza (architettura logica del sistema) 
prodotto in fase di analisi del problema.

L'architettura logica può essere anche il riferimento per la impostazione di **piani di testing**
(*TestPlans*) espressi in modo **non discorsivo** (in modo formale), comprensibile a una macchina.


Cerchiamo di approfondire questi punti, affrontando in qak la specifica, costruzione e testing
del sistema ``S``  introdotto in :ref:`Interagire con un sistema software`.
 
.. Il sistema service_s in qak
 

La struttura del **modello qak** del sistema ``S``  
deve essere espressa da una sequenza di dichiarazioni:

.. _1) Dichiarazione del sistema service_s:

++++++++++++++++++++++++++++++++++++++++++++++++++
1) Dichiarazione del sistema service_s
++++++++++++++++++++++++++++++++++++++++++++++++++

.. list-table:: 
  :widths: 35,65
  :width: 100%

  * -  .. code::

        System  service_s           
    - Il sistema ha nome *service_s*  (tutte minuscole)

.. _2) Dichiarazione dei messaggi:

++++++++++++++++++++++++++++++++++++++++++++++++++
2) Dichiarazione dei messaggi
++++++++++++++++++++++++++++++++++++++++++++++++++

La specifica dei messaggi concorre a formare il **Vocabolario del sistema**  
(si veda :ref:`Conoscere per comunicare`)
e parte della :ref:`Vista esterna`.

.. list-table:: 
  :widths: 60,40
  :width: 100%

  *
    - .. code::

        Dispatch insert : product(ID,P,W) "IN | inserire"
        Dispatch remove : pid(ID)        "IN | rimuovere"

        Request search  : pid( ID )    "IN | cercare"
        Reply searchAnswer: product(ID,P,W) for search 

        Event info : warning(S)  "OUT S=bufFull ..."  
    - 
      I messaggi con **commento IN** servono per *inserire, eliminare, cercare* 
      prodotti i cui attributi sono gli argomenti del payload ``product``:

      - ``ID`` : identificatore 
      - ``P`` : nome 
      - ``W`` : peso 

      I messaggi con **commento OUT** sono *notifiche* in forma di **Event** di nome ``info`` 
      e payload  ``warning(S)`` che il sistema può emettere.

.. _3) Dichiarazione dei contesti:

++++++++++++++++++++++++++++++++++++++++++++++++++
3) Dichiarazione dei contesti
++++++++++++++++++++++++++++++++++++++++++++++++++

Il sistema è costituito da un singolo :ref:`Context` di nome ``ctx_s``,
dislocato sull'host di indirzzo ``192.168.1.132`` alla porta ``8111`` 

.. list-table:: 
  :widths: 98,2
  :width: 100%

  *
    - .. code::

        Context ctx_s ip [ host="192.168.1.132" port=8111]   
    - 
.. _4) Dichiarazione degli attori:

++++++++++++++++++++++++++++++++++++++++++++++++++
4) Dichiarazione degi attori
++++++++++++++++++++++++++++++++++++++++++++++++++

Il sistema è costituito da un singolo :ref:`QActor` di nome ``productservice``,
che fa parte del :ref:`Context` ``ctx_s``.

.. list-table:: 
  :widths: 60,40
  :width: 100%

  *
    - .. code::

        QActor productservice context ctx_s{ 
          State s0 initial{  //stato iniziale (UNICO)
              println("$name | STARTS") color blue
          } 
          Goto work //Transizione di stato
          
          //Altri stati
          ...
        }    
    - 
      Il comportamento di ``productservice`` è descritto come una `Macchina di Moore`_ a stati finiti,
      il cui stato iniziale è ``s0``, in cui viene stampato un messaggio di avvio.

      .. Questo attore contiene al suo interno un oggetto locale (POJO) di nome ``buf`` di tipo ``Buffer``,
          usato per memorizzare i prodotti gestiti dal servizio.
      
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Vistae esterna di service_s
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La :ref:`2) Dichiarazione dei messaggi` e la :ref:`3) Dichiarazione dei contesti` 
forniscono la :ref:`Vista esterna` del sistema ``service_s``.

Da queste dichiarazioni un lettore umano e un computer possono ricavare
il :ref:`vocabolario del sistema<Conoscere per comunicare>` e le modalità logiche di interazione con esso.  


+++++++++++++++++++++++++++++++++++++++++++++++++
Il linguaggio qak come un prodotto in evoluzione
++++++++++++++++++++++++++++++++++++++++++++++++++

Notiamo che, al monento, **non** ci sono *capacità espressive esplcite* per qualificare se i 
messaggi specificati in :ref:`2. Dichiarazione dei messaggi`   
si intendono **inviati** al servizio o **emessi** dal servizio. In questo esempio, si sono 
usati i termini e **IN** e **OUT** nei commenti per cercare di ovviare a questa lacuna.

La :ref:`Vista esterna` del sistema è dunque limitata all'insieme dei messaggi **usati globalmente**
nel sistema stesso, ma ha elementi di ambiguità nel caso il sistema sia un servizio.
Ad esempio,  *service_s* potrebbe fare riferimento
a ciascun messaggio sia come **ricevitore** opuure come **emettitore** (o in entrambi i modi).
L'ambiguità potra, al momento, essere risolta solo esaminando la :ref:`Vista interna` di ogni QActor.
 
Questa carenza di capacità espressiva indica che il *linguaggio qak*, come ogni prodotto informatico, 
può essere ancora suscettibile di evoluzione.
Tuttavia , come si vedrà in seguito, il linguaggio è già sufficientemente espressivo per modellare
sistemi software di una certa complessità e per ragionare su di essi 
(come analisti e come progettisti) senza perdersi in troppi dettagli.

 


------------------------------------------
Interagire con il service_s
------------------------------------------

Prima di addentrarci in ulteriori dettagli del linguaggio qak
e nella :ref:`Vista interna del sistema service_s`, osserviamo che le attuali specifiche
permettono già di capire come un osservatore ``Obs``  potrebbe interagire con il sistema .



++++++++++++++++++++++++++++++++++++++++++++
Un osservatore 'alieno'
++++++++++++++++++++++++++++++++++++++++++++

Si può realizzare un client ``Obs`` usando un linguaggio di programmazione
qualsiasi (es. *Kotlin, Java, Python, JavaScript*, etc.), costruendo i messaggi secondo la sintassi
voluta dal servizio e inviandoli via 
**TCP** al nodo di indirizzo ``192.168.1.132`` e porta ``8111``.

.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        package main.java;
        import unibo.basicomm23.interfaces.IApplMessage;
        import unibo.basicomm23.interfaces.Interaction;
        import unibo.basicomm23.utils.CommUtils;
        import unibo.basicomm23.utils.ConnectionFactory;

        public class ObsClientJava {
          ...
        }
    - L'observer fa uso di molte classi de :ref:`La libreria unibo.basicomm23`.
       

- l'interfaccia **IApplMessage** per la rappresentazione dei messaggi applicativi
- l'interfaccia **Interaction** per la rappresentazione di una connessione astraendo dal tipo di protocollo
- la classe **CommUtils** che fornisce metodi statici per la costruzione e gestione dei messaggi
- la classe **ConnectionFactory** che fornisce metodi statici per la creazione di connessioni con diversi protocolli


.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::
 
        public class ObsClientJava {
        /*1*/private Interaction conn ;
        /*2*/private IApplMessage insertCmd = 
             CommUtils.buildDispatch(
              "obsclientjava", "insert", 
              "product(p4,printer,40)","productservice");
        /*3*/private IApplMessage get = 
              CommUtils.buildRequest(
              "obsclientjava", "search", 
              "pid(p4)", "productservice"); 			  

        /*4*/public void doJob() {
          ... 
          }
          
          public static void main(String[] args) {
            ObsClientJava client = new ObsClientJava();
            client.doJob();
          }
        }
    - L'observer 'alieno' di classe ``ObsClientJava`` definisce:
    
      #. variabile  di tipo ``Interaction`` per una connessione (TCP) verso il servizio ``productservice``
      #. messaggio di tipo **dispatch** di nome ``insert`` al servizio ``productservice`` 
         con sender ``obsclientjava``. 
         Il payload denota un prodotto con identificatore ``p4``, nome ``printer`` e peso ``40``.
      #. messaggio di tipo **request** (bloccante) di nome ``search`` al servizio ``productservice``
         con sender ``obsclientjava``. Il payload denota la ricerca del prodotto con identificatore ``p4``.
      #. metodo che include il codice per inviare i messaggi al servizio.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il comportamento dell'osservatore alieno
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        public void doJob() {
        try {		 
        /*1*/ conn = ConnectionFactory.createClientSupport23(
                  unibo.basicomm23.msg.ProtocolType.tcp, 
                  "localhost", "8111");
        /*2*/ conn.forward(insertCmd);
        /*3*/ IApplMessage answer = conn.request( get );
        /*4*/ CommUtils.outmagenta("answer="	+answer);
        }catch (Exception e) { e.printStackTrace(); } 
        }
    - 
      #. stabilisce la connessione TCP verso il servizio ``productservice``
      #. invia il messaggio di tipo **dispatch** di nome ``insert`` 
      #. invia la **request** di nome ``search``
      #. visualizza la risposta ricevuta dal servizio.


.. note::

  Un osservatore espresso da un
  programma scritto in un linguaggio diverso dal linguaggio qak,
  non potrà ricevere messaggi di tipo **Event**, a meno che ``service_s`` non li emetta 
  usando un broker MQTT (un argomento che affronteremo nel seguito).


.. confidando che le capacità espressive
   del linguaggio qak siano tali da permettere al lettore di comprenderne il significato.

.. _Osservazione e testing:

------------------------------------------------
Osservazione e testing
------------------------------------------------
La conoscenza del vocabolario di un sistema e della sua semnatica, fornisce una base
per **validare** il sistema, verificando che il comportamento osservato 
sia quello  previsto.

La possibilità di esprimere una interazione con ``service_s`` sulla base della 
:ref:`logica della comunicazione<Interazione come vincolo>`
legata ai messaggi specificati in :ref:`2. Dichiarazione dei messaggi`
anche senza conoscere i dettagli implementativi del servizio,
costituisce un importante strumento per la pianificazione di **test funzionali**.

I test possono anche essere eseguiti **in modo automatico**, utilizzando un framework di test 
come `JUnit`_.


.. code::

    import static org.junit.Assert.fail;
    import org.junit.After;
    import org.junit.Before;
    import org.junit.BeforeClass;
    import org.junit.Test;

    import unibo.basicomm23.interfaces.IApplMessage;
    import unibo.basicomm23.interfaces.Interaction;
    import unibo.basicomm23.utils.CommUtils;
    import unibo.basicomm23.utils.ConnectionFactory;

    public class ObsAsTester {
      private Interaction conn ;
      
        private IApplMessage insertCmd = CommUtils.buildDispatch(
          "obsclientjava", "insert", "product(p4,printer,40)", "productservice");
        private IApplMessage get = CommUtils.buildRequest(
          "obsclientjava", "search", "pid(p4)", "productservice"); 			  

      @Before
      public void setup() {
        conn = ConnectionFactory.createClientSupport23(
                  unibo.basicomm23.msg.ProtocolType.tcp, "localhost", "8111");		
      }

      @After
      public void down() {
        System.out.println("down");
        try {
          conn.close();
        } catch (Exception e) {
          fail("Connection close failed");
        }
      }

      @Test
      public void testAsObs() {
        try {		 
          String expected = "product(p4,printer,40)";
          CommUtils.outmagenta("insert" );
          conn.forward(insertCmd);
          CommUtils.outmagenta("search" );
          IApplMessage answer = conn.request( get );
          CommUtils.outmagenta("answer="	+answer);
          
          assert( answer.msgContent().equals(expected) );
        } catch (Exception e) { e.printStackTrace(); } 
      }

    }

Il codice sopra riportato è un esempio di test funzionale 
eseguito con il framework di test `JUnit`_.
Il test è definito in una classe di nome ``ObsAsTester`` che (in modo analogo a ``ObsClientJava``):   

- stabilisce una connessione TCP verso il servizio ``productservice`` nel metodo ``setup()``.
  Questo metodo viene eseguito prima di ogni test;
- chiude la connessione nel metodo ``down()``. Questo metodo viene eseguito dopo ogni test:
- esegue il test nel metodo ``testAsObs()`` in cui:
  - invia un messaggio di tipo **dispatch** di nome ``insert``
  - invia una **request** di nome ``search``
  - verifica che la risposta ricevuta sia quella attesa, 
    cioè che il contenuto del messaggio di risposta sia uguale a ``product(p4,printer,40)``

Per chi volesse approfondire, si vedano anche `JUnit FAQ`_.




--------------------------------------------------------------
Progettazione e sviluppo come processo evolutivo
--------------------------------------------------------------

L'uso dei modelli è utile (per non dire indispensabile) PER CONCENTRARE
l'attenzione SUGLI ASPETTI RITENUTI SALIENTI (tenendo conto anche
dei tempi, delle tecnologie disponibili  e dei costi).

Rispetto a UML, il linguaggio qak vuole fornire uno strumento  esplicitamente 
orientato alla specifica e realizzazione di sistemi distributi basati
su attori e/o microservizi, allo scopo di
abbattere i costri di produzione di un sistema distribuito.


.. Sebbene UML possa modellare sistemi distribuiti (ad esempio, con diagrammi di Componenti o di Sequenza), 
  mancano concetti nativi eseguiibili specifici per i sistemi distribuiti e le comunicazioni asincrone.
  Un concetto come quello di "Microservizio" deve essere decomposto manualmente in classi, 
  configurazioni di rete, e gestori di messaggi, un processo che richiede tempo ed è soggetto a errori.

La possibilià di definire fin dalle fasi di analisi del problema l'architettura di un sistema distribuito
in termini di un modello eseguibile (qak) costitusice un solido punto di partenza
per la progettazione e la costruzione cooperativa di un sistema software.

Operatori umani diversi (*customer, responsabili aziendali, sviluppatori*) possono trovare 
nel modello qak un punto di confronto e reciproca comprensione, premessa indispensabile
per uno sviluppo consapevole, condiviso e motivato del prodotto, cioè
per il passaggio da **WHAT** (cosa) a **HOW** (come).

 
Questo passaggio può essere visto e svolto come un `processo evolutivo` di trasformazione/specializzazione di questa
del modello di partenza (architettura logica del sistema) prodotto in fase di analisi del problema.
 
L'architettura logica può essere anche il riferimento per la impostazione di
PIANI di testing (**TestPlans**) espressi in MODO NON discorsivo (formale), comprensibile a una macchina. 

 


 
++++++++++++++++++++++++++++++++++++++++++++
Un osservatore come QActor
++++++++++++++++++++++++++++++++++++++++++++

Ovviamente un osservatore di ``service_s`` dovrebbe essere un componente che opera al di fuori del sistema ``service_s``.

Tuttavia, per agevolare la fase di messa a punto di un sistema, è spesso conveniente introdurre
un osservatore **locale** che operi nello stesso Context del sistema osservato.

In questo modo si facilita la sperimentazione e il debugging del sistema,
durante la sua fase di sviluppo e test.

Una volta che il sistema è stato validato, l'osservatore locale può essere
spostato in un Context diverso, senza dover modificare la specifica del suo comportamento.
 
Procediamo dunque a definire un QActor di nome ``client_s`` che opera nel Context ``ctx_s``
e interagisce con il servizio ``productservice``


.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        QActor client_s context ctx_s{ 
          State s0 initial{  
          /*1*/ println("$name | STARTS") color blue
          /*2*/     
            forward productservice 
                -m insert : product(p1,lampadina,10) 
            forward productservice 
                -m insert : product(p2,computer,20) 
            forward productservice 
                -m insert : product(p3,smartphone,50) 
          }
          /*3*/Goto work //Transizione di stato  
    - Nello stato iniziale, *client_s*:
      
      #. visualizza un messaggio di avvio usando l'azione qak **println**.
         Il simbolo **$** permette di usare l'interpolazione di stringhe in kotlin.
         **name** è una variabile qak che denota il nome del QActor che esegue l'azioneù
      #. invia tre volte il messaggio di tipo **dispatch** 
         di nome ``insert`` al servizio ``productservice``.
         I payload denotano tre prodotti diversi.
      #. Al termine delle azioni, transita nello stato ``work``.


.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        State work {
            //chiedi al servizio un prodotto
        /*1*/request  productservice -m search : pid(p2) 
        } 
        /*2*/Transition t0
            whenReply searchAnswer -> handleAnswerSearch
    - Nello stato  *work* , *client_s* :
    
      #. usa l'azione qak **request** per inviare 
         una **request** di nome ``search`` al servizio ``productservice``,
         con *payload* che denota l'identificatore del prodotto da cercare (``p2``).
      #. specifica una transizione di stato che si attiva alla ricezione
         di una **reply** di nome ``searchAnswer``, 
         che lo fa transitare nello stato ``handleAnswerSearch``.
 
.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

       State handleAnswerSearch{
       /*1*/printCurrentMessage color magenta
       /*2*/println("$name | received $currentMsg") 
       /*3*/onMsg(searchAnswer : product(ID,NAME,W)){
       /*4*/ [# 
                val Pid   = payloadArg(0) 
                val Name  = payloadArg(1)
                val Weight= payloadArg(2)
             #]
        /*5*/println("$name | data:$Pid,$Name,$Weight") 
            }
        /*6*/[# System.exit(0) #]
       }
    - In questi stato , *client_s* :
    
       #. visualizza il messaggio ricevuto con l'azione qak ``printCurrentMessage``
       #. visualizza il contenuto della variabile qak **currentMsg**, che denota il messaggio ricevuto
       #. usa l'azione qak **onMsg** per eseguire il *pattern matching* del messaggio ricevuto,
          estraendo i valori del payload della **reply** ``searchAnswer``
       #. usa azioni kotlin per assegnare i valori del payload a costanti kotlin locali. 
          La funzione **payloadArg(i)** estrae il valore del i-esimo argomento del payload
          (si noti che l'indicizzazione parte da zero)
       #. visualizza i valori estratti dal payload usando il simbolo **$** per l'interpolazione di stringhe in kotlin
       #. usa azioni kotlin per terminare l'esecuzione del programma con ``System.exit(0)``

 La   *semantica* della frase *onMsg* è la seguente:

- esegue il body *condactions* solo se il messaggio corrente (**currentMsg**) 
  ha msgId ``searchAnswer`` (in questo caso)
  e può essere unificato in Prolog con il *template* di messaggio definito nella dichiarazione 
  (``product(ID,P,W)`` in :ref:`2. Dichiarazione dei messaggi`)
  e con il template specificato ``product(ID,NAME,W)`` (in questo caso).



++++++++++++++++++++++++++++++++++++++++++++
Osservazione dell'evento info
++++++++++++++++++++++++++++++++++++++++++++

Il QActor ``client_s`` può essere facilmente modificato per osservare anche gli
eventi di nome ``info`` emessi dal servizio ``productservice``.

Basta aggiungere una specifica di transizione nello stato ``work``  relativa
di un messaggio di tipo **event** di nome ``info``: 

.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

      State work {
          //chiedi al servizio un  prodotto
          request  productservice -m search  : pid(p2) 
      }
      Transition t0
          whenReply searchAnswer -> handleAnswerSearch
          whenEvent info         -> handleInfoEvent
      
      State handleInfoEvent{
        /*1*/ printCurrentMessage color magenta
        /*3*/ onMsg( info : warning(S) ) {
        /*4*/   [# val Str = payloadArg(0)  #]
        /*5*/   println("$name | event data: $Str") 
              }
        /*6*/ Goto work
      }
    -  Nel caso di di ricezione di un messaggio di tipo **event** di nome ``info``,
      *client_s* passa allo stato ``handleInfoEvent``.
 
Osserviamo che *client_s* nello stato work potrebbe avere ricevuto sia una **reply** di nome ``searchAnswer``
che una **event** di nome ``info``.
In questo caso, la transizione viene decisa in base all'ordine di arrivo dei messaggi
(si veda :ref:`Come un QActor gestisce i messaggi ricevuti`).

.. Se entrambi i messaggi sono presenti nelle code del QActor, viene gestito prima quello che è arrivato per primo.


.. _Vista interna del sistema service_s:

------------------------------------------------------
Vista interna del sistema service_s
------------------------------------------------------


.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        QActor productservice context ctx_s{ 
          [# var Product = "" #]
          State s0 initial{ 
                println("$name | STARTS") color blue
        Goto work
        
        State work{
          
        }
        Transition t0
          whenMsg insert        -> handleinsert
          whenRequest search    -> handleSearch
        ....

        }//QA
    -  
    
       #.  
       #.  



.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        QActor productservice context ctx_s{ 
          [# var Product = "" #]
          State s0 initial{ 
                println("$name | STARTS") color blue
        Goto work
        
        State work{
          
        }
        Transition t0
          whenMsg insert        -> handleinsert
          whenRequest search    -> handleSearch
        
        ...
      
      }//QA
    -      
       #.  
       #.  



.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        QActor productservice context ctx_s{        
        ...
        State handleinsert{
          [# var PID  = ""
            var NAME = ""
            var WEIGHT = ""
            
          #]
          printCurrentMessage color blue
          onMsg( insert : product( ID,NAME,WEIGHT ) ){  
            [# PID    = payloadArg(0) #]
            [# NAME   = payloadArg(1) #]
            [# WEIGHT = payloadArg(2) #]
            
            [# Product = currentMsg.msgContent() #]
            println( "$Product" ) color green
            solve( assert(item($Product) ) )
            ifSolved{ 
              println( "sol=$currentSolution" ) color green
            }
            println( "$name |insert PID=$PID") color blue 
          }
          }
        Goto work
        ...
      }//QA
    -      
       #.  
       #.  


.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - .. code::

        QActor productservice context ctx_s{        
        ...
         
        State handleSearch{
          [# var ProductFound = "" #]
          printCurrentMessage color blue
          onMsg( search : pid( ID ) ){
            [# val R = payloadArg(0) #]
            println("$name | handleSearch $R ") color green
            solve( item(product($R,N,W)) )
              ifSolved{ 
                [# val N = getCurSol("N")
                  val W = getCurSol("W") 
                #]
                  println( "$N, $W" ) color green
                [# ProductFound = "product($R, $N, $W )" #]
              //println( "sol=$currentSolution" ) color green
              println( "found=$ProductFound" ) color green
              
            
            }else{
              println( "not found" ) color red
            }
          }
          println("$name | reply ") color green
          replyTo search with searchAnswer :  $ProductFound   
          emit info : warning(search)
          //product( '{\"productId\":31,\"name\":\"p31\",\"weight\":311}' )
        }
        Goto work

        ... 
        }//QA
    -      
       #.  
       #.  



.. _Come è stato realizzato Qak:

=============================================
Come è stato realizzato Qak
=============================================

--------------------------------------
La sintassi di qak  
--------------------------------------

In Xtext, la grammatica è scritta in un dialetto della Notazione di Backus-Naur Estesa (EBNF), 
dove ogni regola non solo descrive cosa il parser deve leggere, ma anche come trasformarlo 
in un oggetto Java (EObject).

**Keyword e Terminali**

La sintassi si avvale di un insieme di terminali definiti nella  `Xtext grammar`_ :

.. code:: 

  grammar it.unibo.Qactork with org.eclipse.xtext.common.Terminals
 
Le stringhe fisse (*keyword*) sono racchiuse tra apici singoli: ``'entity'``, ``'{'``. 
I terminali (come ``ID, INT, STRING``) descrivono i mattoni base (**token**) definiti solitamente tramite 
espressioni regolari a basso livello

A questi si aggiungono alcuni terminali definiti appositamente per il linguaggio qak:

.. code:: 

  //Identificatore di variabile
  terminal VARID : ('A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
 
**Operatori**

Xtext usa i classici operatori delle espressioni regolari per gestire la ripetizione degli elementi:

- ``?``: Opzionale (0 o 1).
- ``*``: Da 0 a molti.
- ``+``: Almeno uno (1 o molti).

**Feature Assignments**

A differenza della BNF classica, Xtext introduce il concetto di **Feature Assignment**. 
Non ci si limita a dire che dopo una "Entity" segue un nome, ma si istruisce Xtext a salvare quel nome 
in un attributo dell'oggetto.

Questa estensione, che permette di mappare i pezzi di sintassi alle proprietà della classe **Ecore** generata,
assume le seguenti forms:

- feature* **=*** Regola: Assegnamento semplice (per valori singoli).
- feature **+=** Regola: Add-to-list (per collezioni/liste).
- feature **?=** Regola: Boolean assignment (vero se l'elemento è presente).

**Cross-References**
Permette di riferirsi a un elemento definito altrove nel codice tramite il suo nome, 
gestendo automaticamente il linking:

- **[**Request**]**: Cerca un oggetto di tipo *Request* usando l'ID predefinito.

Esempio: ``req=[Request]``.

Dunque Xtext non si limita a definire la forma del linguaggio (la sintassi), 
ma modella contemporaneamente la struttura dei dati (l'Abstract Syntax Tree o AST) 
attraverso un'integrazione profonda con il framework EMF (**Eclipse Modeling Framework**).

**Regole di Enumerazione**
Xtext permette di definire tipi enumerativi che mappano direttamente a Enum Java. Ad esempio:

``enum Severity: INFO | WARNING | ERROR;``

**Azioni semplici**

Hanno la forma **{**TipoOggetto**}** e permettono di cambiare "al volo" il tipo dell'oggetto creato  durante il parsing. 
Ad esempio:

.. code::

  Saluto: {Buongiorno} 'ciao' | {Arrivederci} 'addio';

Se il parser legge "ciao", non crea un oggetto generico *Saluto*, ma un oggetto di tipo *Buongiorno*.

**Azioni Assegnate**
Hanno la forma *{*TipoOggetto.**feature=current**}* e permettono di costruire costruire 
alberi sintattici in modo incrementale. Il termine **current** rappresenta l'oggetto che il parser ha appena 
finito di costruire fino a quel punto. 

Sono utili per superare il problema della **ricorsione a sinistra**, che esclude regole 
del tipo:

.. code::
 
  Espressione: Espressione '+' Termine;

Per gestire la precedenza degli operatori (es. la moltiplicazione prima dell'addizione), 
Xtext usa le *Azioni Assegnate* per "impacchettare" ciò che ha appena letto in un nuovo oggetto.

Ad esempio:

  .. code::

    Addizione: Moltiplicazione ({Addizione.left=current} '+' right=Moltiplicazione)*;

  Quando il parser legge ``1 + 2 + 3``

  - Legge 1: Viene creato un oggetto (es. Numero) tramite la regola Moltiplicazione. 
    Questo oggetto diventa il *current*.

  - Incontra il +: Scatta l'azione {*Addizione.left=current*}.

    - Viene creato un nuovo oggetto di tipo Addizione.
    - Il "vecchio" *current* (il numero 1) viene assegnato alla proprietà **left** della nuova Addizione.
    - La nuova Addizione diventa il nuovo current.

  - Legge 2: Viene assegnato alla proprietà right.

  - Incontra un altro +: Il processo si ripete. La Addizione appena creata (che contiene 1+2) 
    viene "impacchettata" nel **left** di una nuova Addizione più grande.

  In sintesi: L'azione {``...=current``} prende quello che hai in mano, lo mette in un nuovo contenitore 
  e restituisce il contenitore stesso.


Un esempio più completo:

.. code::

  Espressione:
    Addizione;

  Addizione returns Espressione:
      Moltiplicazione ({Addizione.left=current} '+' right=Moltiplicazione)*;

  Moltiplicazione returns Espressione:
      Primario ({Moltiplicazione.left=current} '*' right=Primario)*;

  Primario returns Espressione:
      '(' Espressione ')' | {Numero} valore=INT;


- Scrivendo ``1 + 2 * 3``, il parser raggrupperà ``2 * 3`` dentro un oggetto *Moltiplicazione* 
  prima di finire l'oggetto *Addizione*, rispettando le regole matematiche
- L'uso di **returns Espressione** serve a far capire a Java che tutti questi oggetti 
  (*Addizione, Moltiplicazione, Numero*) appartengono alla stessa gerarchia di classi.


.. _Notazioni ispirate ai termini Prolog:

++++++++++++++++++++++++++++++++++++++
Notazioni ispirate ai termini Prolog
++++++++++++++++++++++++++++++++++++++

Molte elementi di qak usano notazioni ispirate ai *termini Prolog* 
che  sono denotati dal non-terminale :ref:`PHead`.

.. (nella versione `tuProlog`_ realizzata  dalla Università di Bologna) 

.. _PHead:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
PHead
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: 

  PHead : PAtom | PStruct | ... ;
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Atomi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

I temini più semplici sono gli **atomi**: 

- un nome che inizia con una lettera minuscola 
  e può essere seguito da lettere (maiuscole o minuscole), cifre (``0-9``) e il carattere underscore (``_``).
- qualsiasi sequenza di caratteri racchiusa tra virgolette singole  
- i simboli ``true``, ``fail``, ``[]`` (lista vuota) .

Atomi sono usati in qak, per denotare:

- i nomi dei `QActor`_ (tutte minuscole)
- i nomi dei `Context`_  (tutte minuscole)
- i nomi dei messaggi e i nomi dei loro **payload**
 
Numeri, identificatori di variabili e stringhe sono considerati in qak una sorta di atomi speciali.

.. code::

  PAtom : PAtomString | Variable |  PAtomic | PAtomNum  ...

  PAtomString : val = STRING ;
  Variable    : varName= VARID ;
  PAtomic     : val = ID ;
  PAtomNum    : val = INT ;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Strutture
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Termini non atomici sono le **strutture** (*functor* con argomenti):

.. code:: 

  PStruct : functor=ID "(" (msgArg += PHead) ("," msgArg += PHead)* ")" ; 
  //qak richiede almeno un argomento PHead

Le strutture permettono di denotare messaggi con payload articolati, ad esempio:

.. code:: 

  product( ID, Name, Weight ) 
  
La struttura ``product/3`` ha nome ``product`` e tre argomenti, denotati dalle variabili
``ID``, ``Name``, ``Weight``. A ciascuna di queste variabili può essere associato un termine
specifico al momento dell'invio del messaggio. Ad esempio: 

.. code:: 

  product( p1, lampadina, 10 ) 
 
Si noti che le variabili non sono vincolate a un tipo: i tipi dei dati vengono determinati 
dalla loro denotazione sintattica: ``p1`` e ``lampadina`` sono atomi, mentre ``10`` è un intero. Nella frase:

.. code:: 

  product( p2, computer(memory(500),"for gaming"), 100 ) 

il secondo argomento è una *struct* con due argomenti, di cui il primo è una *struct* e il secondo è una *PAtomString*.


++++++++++++++++++++++++++++++++++++++
Unificazione Prolog in qak
++++++++++++++++++++++++++++++++++++++
Il meccanisno di unificazione è usato in qak per realizzare
operazioni di matching tra messaggi ricevuti e messaggi attesi.

La frase qak:

.. code:: 

  solve( unify( product(p1,X,Y) , product(ID,lampadina,10) ) )
 
esegue la unificazione delle due strutture Prolog, producendo, in caso di successo, l'assegnazione di
valori (termini *PHead*) alle variabili.
 
Questa frase viene tradotta nel seguente codice Kotlin. 

.. code:: 

   solve("unify(product(p1,X,Y),product(ID,lampadina,10))","")  


Il metodo ``solve`` è
definito nella classe base (``QActorBasic``), da cui  ogni `QActor`_, 
nella sua definizione Kotlin  di basso livello, eredita:

Il metodo invoca il motore di inferenza Prolog integrato nel QActor (variabile **pengine**) 
per eseguire l'unificazione sintattica.

.. note::

  Il secondo argomento del metodo ``solve`` viene usato per denotare il nome di una variabile 
  del termine applicativo di cui interessa il valore. Tale valore viene memorizzato
  nella variabile denominata **resVar** del QActor. 

  Se si passa la stringa vuota, 
  il valore di ``resVar`` sarà *success* nel caso la unificazioneo  si realizzi o *fail*
  nel caso in cui le due strutture applicative non siano unificabili.

  Ad esempio:

  .. code:: 

    solve("unify(product(p1,X,Y),product(ID,lampadina,10))","X")  
    CommUtils.outblack("res=$resVar")    //res=lampadina

Il risultato del metodo ``solve`` viene memorizzato nella variabile **currentSolution** del QActor,
che può essere interrogata mediante il metodo ``getCurSol(varName: String)``. 
Ad esempio, il seguente codice Kotlin:

.. code::   

  CommUtils.outblack("res=$resVar")            
  CommUtils.outblue("sol=$currentSolution") 	  
  CommUtils.outblue( "--------------------------------" )
  if( currentSolution.isSuccess() ) {
    CommUtils.outblack("ID=${getCurSol("ID")} ")
    CommUtils.outblack("X=${getCurSol("X")}   ")
    CommUtils.outblack("Y=${getCurSol("Y")}   ")
  }else{
    CommUtils.outred("unification failed")
  }

produce il seguente output:

.. code:: 

   res=success
   sol=yes.
   X / lampadina  Y / 10  ID / p1  
   --------------------------------
   X  = lampadina
   Y  = 10
   ID = p1

L'accesso alla soluzione di **solve** può essere espresso direttamente in  qak. Ad esempio:

.. code:: 

  solve( unify(product(p1,X,Y) , product(ID,computer(memory(500),"for gaming"),100)) ) 
  ifSolved{ 
    println( "sol=$currentSolution" ) color blue
    println( "------------------------------------------------" )
    println( "ID=${getCurSol(\"ID\")} " )   // ID=p1
    println( "X=${getCurSol(\"X\")} "   )   // X=computer(memory(500),'for gaming')
    println( "Y=${getCurSol(\"Y\")} "   )   // Y=100
  }else{
    println( "unification failed" )
  } 

L'azione qak ``getCurSol(V)`` permette di ottenere il valore della variabile ``V``.


-----------------------------------------------
Le cassi della infrastruttura
-----------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++
it.unibo.kactor.ActorBasic.kt
++++++++++++++++++++++++++++++++++++++++++++

Realizza  il concetto di QActor come ente computazionale dotato di flusso di controllo autonomo, 
capace di recevere e gestire messaggi locali e/o remoti.


.. Si veda: :ref:`Kotlin actor` in :ref:`KotlinNotes`.

- Per le interazioni tra QActor nello stesso Context, si  
  avvale delle :ref:`coroutine <La coroutine: un nuovo vecchio concetto>` kotlin. 
  Gestisce i messaggi in modo FIFO, sfruttando un  :ref:`Kotlin actor` incapsulato.

++++++++++++++++++++++++++++++++++++++++++++
actor channel
++++++++++++++++++++++++++++++++++++++++++++

.. code::

    val actor = scope.actor<IApplMessage>( dispatcher, capacity=channelSize ) {
      for( msg in channel ) {
        if( msg.msgContent() == "stopTheActor") {  channel.close() }
        else actorBody( msg ) 
      }
    }

- Per i  meccanismi di comunicazione remota usa
  :ref:`La libreria unibo.basicomm23` che implementa il concetto astratto 
  di **Interaction** per diversi protocolli di comunicazione (es. ``MQTT``, ``CoAP``, ``TCP``).

.. _sendMessageToActor:

++++++++++++++++++++++++++++++++++++++++++++
sendMessageToActor
++++++++++++++++++++++++++++++++++++++++++++

Il metodo ``sendMessageToActor`` realizza l'invio di un messaggio ad un attore 
di cui è noto il nome (destName) o la connessione (conn).

.. code::

    suspend fun sendMessageToActor(msg : IApplMessage, 
           destName: String, conn : Interaction? = null ) {
      val destactor = context!!.hasActor(destName)
      /* 
        se destactor  è locale: destactor.kactor.send( msg )
        altrimenti usa il proxy verso il contesto di destactor
      */
    }

.. image:: ./_static/img/ActorBasic.png
          :align: center
          :width: 60%

.. list-table::
  :widths: 55,45
  :width: 100%
  
  * -  
      .. code::

         
        /*1*/ abstract class  ActorBasic(  
        /*2*/   name: String,
        /*3*/   val scope:CoroutineScope=GlobalScope,
        /*4*/   var discardMessages Boolean=false, 
        /*5*/   val confined :    Boolean = false,
        /*6*/   val ioBound :     Boolean = false,
        /*7*/   val channelSize : Int = 50
                ) : 
        /*8*/     CoapResource(name), 
        /*9*/      MqttCallback { 
              ...      
            //To be overridden by the application
        /*10*/ abstract suspend fun actorBody(
                  msg:IApplMessage)
          }

       
      .. Si veda: :ref:`actor channel`

    - 
      #. `class ActorBasic` Si veda :ref:`Oggetti e classi` in :ref:`KotlinNotes`.
      #. `name` Nome (**univoco** nel sistema) dell'attore
      #. `scope` Si veda :ref:`Le coroutines` in :ref:`KotlinNotes` e  `kotlinUniboCoroutinesIntro`_ in `kotlinUnibo`_.
      #. `discardMessages` scarta o meno i messaggi non attesi. Usato principalmente in  
         :ref:`ActorBasicFsm<it.unibo.kactor.ActorBasicFsm.kt>`
      #. `confined` Si veda :ref:`Confinamento` in :ref:`KotlinNotes`. 
      #. `ioBound` Si veda :ref:`Confinamento` in :ref:`KotlinNotes`. 
      #. `channelSize`  Si veda :ref:`I canali` in :ref:`KotlinNotes`.
      #. `CoapResource`  Si veda :ref:`Estende CoapResource`
      #. `MqttCallback` Si veda :ref:`Implementa MqttCallback` 
      #. `actorBody`  codice per la gestione dei messaggi :ref:`IApplMessage<unibo.basicomm23.interfaces.IApplMessage>` 
         ricevuti dall'attore.




La frase: 

.. code::

  class  ActorBasic( ... ) : CoapResource(name), MqttCallback

esprime in forma compatta che *ActorBasic* `eredita` dalla classe `CoapResource`_ e 
`implementa` l'interfaccia `MqttCallback`_ (si veda `kotlinInheritance`_).

.. note::

     
    **Estende CoapResource**
     
    Ogni attore è anche una risorsa CoAP, specializzazione della classe definita nella libreria 
    https://www.eclipse.org/californium/.

     
    **Implementa MqttCallback** 
     
    Ogni attore implementa anche l'interfaccia
    ``org.eclipse.paho.client.mqttv3.MqttCallback``. Pertanto
    ogni attore può gestire notifiche emesse da un MQTT client, attraverso il metodo 
    :ref:`messageArrived<MqttConnectionCallbackForReceive>`.  

     
    **evento kernel_rawmsg**
     

    Nel caso in cui il metodo 
    :ref:`messageArrived<MqttConnectionCallbackForReceive>` 
    riceva una stringa ``S`` che non corrisponde a un messaggio di tipo 
    :ref:`IApplMessage<unibo.basicomm23.interfaces.IApplMessage>`,
    l'attore emette un evento di tipo ``kernel_rawmsg : kernel_rawmsg( S )``.  

    Il componente applicativo che percepisce questo evento può convertire la stringa ``S`` in un messaggio qak.  
    Per un esempio si veda :ref:`cellOnRasp Punti salienti`.





.. _it.unibo.kactor.ActorBasicFsm.kt:

+++++++++++++++++++++++++++++++++++++++++++++++
it.unibo.kactor.ActorBasicFsm.kt
+++++++++++++++++++++++++++++++++++++++++++++++

.. code::

    abstract class ActorBasicFsm(  qafsmname:  String,
                fsmscope: CoroutineScope = GlobalScope,
                discardMessages : Boolean = false,
                confined :    Boolean = false,
                ioBound :     Boolean = false,
                channelSize : Int = 50
    ): ActorBasic(qafsmname,fsmscope,discardMessages,confined,ioBound,channelSize) { ... }

- Un attore che specializza questa classe opera come un automa a stati finiti (:ref:`QActor come FSM`).
- Il codice Kotlin viene generato dalla :ref:`Qak software factory`
- I messaggi ricevuti sul canale Kotlin
  (ereditato da :ref:`ActorBasic<it.unibo.kactor.ActorBasic.kt>`) sono gestiti in relazione 
  alle specifiche sulle transizioni associate allo stato corrrente dell'automa.




.. Grazie al meccansimo delle :ref:`coroutine <La coroutine: un nuovo vecchio concetto>` kotlin,
   nasce la possibilità di attivare centinaia / migliaia di QActors all'interno di una
  stessa *Java Virtual Machine- (**JVM**), aprendo la via alla costruzione di *sistemi software
  complessi- e alla sperimentazione di :ref:`architetture olarchiche<Gererchie e Olarchie>`.

============================================
Sistemi su RaspberryPi
============================================ 

 
Premessa: :ref:`RaspberrySoftware` e :ref:`RaspBasicCode`.

`Project it.unibo.raspIntro2024`


In questa sezione affrontimao i seguenti punti:

#. Costruzione di un sistena software Sonar-Led technology-dependent su RaspberryPi
#. Sofware per un Sonarche emette via MQTT la distanza rilevata  (`SonarMqtt.py`_) 
   che può essere visualizzata con un grafico ((`mqttPlotQakEvents.py`_)
#. Sistema :ref:`SonarAndLed` locale technology-dependent per :ref:`SistemaRilevamento`

Software da installare:

.. code::

    pip install paho-mqtt
    python -m pip install -U pip
    python -m pip install -U matplotlib


------------------------------------
Verifica dispositivi
------------------------------------

Riportiamo qui codice per sperimentare la corretta installazione del ``Led`` e del  sonar 
:ref:`HC-SR04<Usiamo un SONAR HC-SR04>` su RaspberryPi.


++++++++++++++++++++++++++++++++++++
Software per il Led
++++++++++++++++++++++++++++++++++++

.. list-table:: 
  :widths: 30,70
  :width: 100%

  * - `led25GpioTurnOn.sh`_, `led25GpioTurnOff.sh`_  
    -  Accensione/spegnimento in bash (NO su BullsEye)
  * - `led25OnOff.sh`_
    -  Blinking in bash (NO su BullsEye)
  * - `ledOnOff.c`_
    -  Blinking in C
  * - `ledPython25.py`_
    -  Blinking in Python


++++++++++++++++++++++++++++++++++++
Software per il Sonar
++++++++++++++++++++++++++++++++++++

:`ATTENZIONE`: per gli esempi in Python, si fa riferimento a `Python3`. Si veda
:ref:`Installazione del modulo GPIO per Python3`

.. list-table:: 
  :widths: 30,70
  :width: 100%

  * - `SonarAlone.c`_ 
    - Software per il ``sonarHCSR04`` scritto in C
  * - `sonar.py`_ 
    - Software per il ``sonarHCSR04`` scritto in Python
  * - `SonarMqtt.py`_  
      
      .. `LOGICAMENTE ERRATO`

    - Software per il ``sonarHCSR04`` scritto in Python che pubblica sul broker MQTT 
      `mqtt.eclipseprojects.io` TOPIC= `unibo/sonar/events` l'evento 
      ``msg(sonardata,event,sonar,none,distance(D),N)``.

      Si veda `mqttPlotQakEvents.py`_  come possibile receiver.

      .. e `radargui23.qak`_

  * - `mqttPlotQakEvents.py`_ 
    - Un ricevitore che fa subscribe a TOPIC= `unibo/sonar/events` per visualizzare
      su un grafico i dati del Sonar 
  * - `ControllerMqtt.py`_ 
    - Un controller che libera il Sonar da compiti di interazione applicativa.
      Da usarsi in una pipe insieme a `LedDevice.py`_ 

      .. code::

        python sonar.py | python ControllerMqtt.py | python LedDevice.py





:`Costruiamo applicazioni`



++++++++++++++++++++++++++++++++++++++++
SonarAndLed
++++++++++++++++++++++++++++++++++++++++

- Sistema `SonarAndLed`_ organizzato in funzioni  Python
- Ciascuna funzione ha una precisa responsbilità
- La funzione ``doJob()`` funge da coordinatore
- La funzione ``applLogic`` definisce la logica applicativa
- La funzione ``forward`` invia informazioni via MQTT

.. list-table::   
  :widths: 30,70
  :width: 100%

  * -  Inizializzazione
    -  
       
      .. code::

        import RPi.GPIO as GPIO
        import time
        import sys
        import paho.mqtt.client as paho

        ### CONFIGURATION FOR LED
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(25,GPIO.OUT)

        ### CONFIGURATION FOR SONAR
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)
        TRIG = 17
        ECHO = 27
        GPIO.setup(TRIG,GPIO.OUT)
        GPIO.setup(ECHO,GPIO.IN)
        
        ### MQTT
        brokerAddr="mqtt.eclipseprojects.io"   
        msg       = "msg(sonardata,event,sonar,none,distance(D),N)"
        n         = 1
        client    = paho.Client(paho.CallbackAPIVersion.VERSION1,"sonarAndLed")    
        

        def init():
            GPIO.output(TRIG, False)   #TRIG parte LOW
            client.connect(brokerAddr, 1883, 60) 
            print ('Waiting a few seconds for the sensor to settle')
            time.sleep(2)
        
  * -  Coordinatore e attivatore
    -  
       
      .. code::

   
        def doJob():   
            init()
            while True:
                d = sonarWork()                
                if( d  > 0.0 and d < 150.0 ): # FILTRO
                    #distance = d
                    print ( d  )
                applLogic(d)           # LOGICA APPLICATIVA
                sys.stdout.flush()
                time.sleep(0.25)

        if __name__ == '__main__':
            print ('sonarAndLed is starting ... ')
            try:
                doJob()
            except KeyboardInterrupt:   
                print ('sonarAndLed BYE ... ')
 
  * -  Logica applicativa
    -  
       
      .. code::

 
  
        def applLogic(distance):
                if( distance  > 0.0 and distance < 5.0 ):   
                    ledOn()
                    forward(distance)
                else:
                    ledOff()
 
 
  * -  Funzioni operative
    -  
       
      .. code::

 
        def ledOn():
          GPIO.output(25,GPIO.HIGH)
          ##forward()  #QUI???

        def ledOff():
          GPIO.output(25,GPIO.LOW)

        def sonarWork():
          GPIO.output(TRIG, True)    #invia impulsoTRIG
          time.sleep(0.00001)
          GPIO.output(TRIG, False)

          #attendi che ECHO parta e memorizza tempo
          while GPIO.input(ECHO)==0:
              pulse_start = time.time()

          # register the last timestamp  
          while GPIO.input(ECHO)==1:
              pulse_end = time.time()

          pulse_duration = pulse_end - pulse_start
          dist = pulse_duration * 17165   #distance = vt/2
          return dist

        def forward(distance):
            global n
            n = n + 1
            client.publish("unibo/sonar/events", 
             msg.replace("D",str(distance)).replace("N", str(n)))  


---------------------------------------
Progetto sonarqak24
---------------------------------------

`Progetto unibo.sonarqak24`

Goal: sviluppare un componente software che utilizza il :ref:`SONAR HC-SR04<Usiamo un SONAR HC-SR04>` 
e che sia in grado di:

- ricevere via rete ed eseguire comandi di ``sonarstart/sonarstop`` 
- inviare ad altri componenti software i vaori di distanza rilevati, filtrati in modo che ogni valore
  ``D`` emesso sia un valore intero tale che ``0<D<=150``
 

+++++++++++++++++++++++++++++++++++++++
sonarqak24: analisi del problema
+++++++++++++++++++++++++++++++++++++++

#. Disponiamo di codice di basso livello `sonar.py`_ che attiva il sonar fisico e scrive sul dispositivo
   standard di output, a intervalli temporali fissi, i valori della distanza corrente rilevata.
#. Il codice `sonar.py`_  non è in grado di inviare informazioi in rete nè di ricevere comandi di ``sonarstart/sonarstop``.
   Ha inoltre una forma di filtraggio dei valori molto limitata.
#. Non si ritiene opportuno modificare il codice di basso livello per rispondere alle esigenze applicative. 
   Si ritiene invece più opportuno procedere in modo top down, partendo dalla definizione di un 
   componente di alto livello, denominato ``sonar24`` e modellato come un Actor capace di gestire 
   i seguenti dispatch:

   .. code::

      Dispatch sonarstart : sonarstart(X)
      Dispatch sonarstop  : sonarstop(X)

   
#. Ricordando i concetti de :ref:`La Clean Architecture`, occorre ora rispondere alla seguente domanda:
   
   come ``sonar24`` `intende ricevere i valori D della distanza misurata`?

   Per motivi di modularità ed estendiblità, si propende per l'uso di un event:

   .. code::

      Event sonardata : distance(D)
  
   Eventi di questo tipo si suppongono  generati da un altro componente, denominato ``sonardevice``,
   anch'esso modellato come un Actor 


#. Per motivi di efficienza e per evitare l'inutile trasmissione di eventi via rete, si 
   ritiene opportuno utilizzare il concetto di :ref:`Attori streamer`,
   e le primitive :ref:`subscribeTo<Operazioni di messaggista publisch-subscribe>`
   e :ref:`emitLocalstream<Operazioni relative agli eventi>`

#. Il componente ``sonardevice`` può incapsulare il codice di basso livello `sonar.py`_ 
   e implementare i comandi ``sonarstart/sonarstop``, che gli possono essere delegati
   da ``sonar24``

Ne consegue la seguente Architettura Logica:

.. list-table::   
  :widths: 60,40
  :width: 100%

  * -  

       .. image:: ./_static/img/sonar24Analisi.PNG 
         :align: center
         :width: 100%

    -  La emissione di eventi con :ref:`emitLocalstream<Operazioni relative agli eventi>`
       non viene  visualizzata. Se fosse emesso con :ref:`emit<Operazioni relative agli eventi>` 
       si avrebbe:
      
       .. image:: ./_static/img/sonar24AnalisiEv.PNG 
         :align: center
         :width: 100%

+++++++++++++++++++++++++++++++++++++++
sonarqak24:progettazione
+++++++++++++++++++++++++++++++++++++++

Il componente ``sonardevice`` può essere realizzato in due modi:

- in modo esplicito, definendo un Actor nel modello applicativo
- in modo 'sommerso', definendo un :ref:`CodedQActor<Attori coded>`  come `sonarHCSR04Support23.kt`_

Inoltre  un filtraggio più accurato dei valori di distanza può essere ottenuto 
costruendo una pipe di attori che ha  `sonardevice` come sorgente-dati e 
un componente `dataCleaner` che provvede a eliminare dati spuri.


L'architettura logica di progetto diventa:

.. list-table::   
  :widths: 80,20
  :width: 100%

  * -  
      .. image:: ./_static/img/sonar24Progetto.PNG 
        :align: center
        :width: 80%  
    -  La emissione di eventi con :ref:`emitLocalstream<Operazioni relative agli eventi>`
       viene  visualizzata




 

Inoltre, la pipe può essere estesa introducendo un componente terminale
`distancefilter` capace di generare eventi significativi per il livello applicativo,
quali ad esenpio:


   .. code::

      Event obstacle  : obstacle(D)

.. .. list-table::   
  :widths: 80,20
  :width: 100%

  * -  
      .. image:: ./_static/img/sonar24Progetto1.PNG 
        :align: center
        :width: 80%  
    -  L'evento ``obstacle`` viene visualizzato in quanto emesso usando la primitiva
       :ref:`emit<Operazioni relative agli eventi>`

 
 
:worktodo:`TODO: affrontare la progettazione` del :ref:`SistemaRilevamento`.


Iniziamo com `sonarqak24base`_. I key-points sono:

.. list-table::   
  :widths: 40,60
  :width: 100%

  * -  
      .. image:: ./_static/img/sonar24ProgettoBase.PNG 
        :align: center
        :width: 80%  
    -   
      - definizione esplicita a livello di modello di ``sonardevice``
      - ``sonar24`` fa ``subscribeTo sonardevice for sonardata``
      -  ``sonardevice`` fa :ref:`emitLocalstream<Operazioni relative agli eventi>` dell'evento ``sonardata``
      - uso di `sonar.py`_ come dispositivo di basso livello attivato all'interno di ``sonardevice``
      - uso della feature :`lateinit` di Koltlin
      - uso di :`autodispatch` ``doread`` per continuare a consumare i valori 
        che  `sonar.py`_ scrive sul dispositivo di output
       

Una volta verificato che questo sistema minimale funziona, aggiungiamo i comandi di ``sonarstart/sonarstop``
e in componente esplicita a livello di modello di ``datacleaner``, come proposto 
nella  architettura logica di :ref:`progetto<sonarqak24:progettazione>`


Si veda: `sonarqak24`_. I key-points sono:

- ...


==========================================
VirtualRobot23
==========================================

`Progetto it.unibo.virtualRobot2023`

-------------------------------------------
VirtualRobot23 project
-------------------------------------------

Nel progetto  `it.unibo.virtualRobot2023`, il DISI ha sviluppato un ambiente virtuale (denominato ``WEnv``) 
che include un simulatore di *Differential Drive robot* (**DDR**). 

Un `DDR Robot`_ -> possiede due ruote motrici sullo stesso asse e una terza ruota condotta (non motrice).
La  tecnica *differential drive* consiste nel far muovere le ruote motrici a velocità
indipendenti l’una dall’altra.  

``WEnv`` fa riferimento a una forma semplificata di DDR in cui le possibìili mosse sono:

- muoversi avanti-indietro lungo una direzione costante
- fermarsi
- ruotare di 90° a destra o sinistra 

Queste mosse sono realizzate inviando opportuni comandi al robot simulato.   
        
Il robot virtuale (e in futuro anche quelli reali) viene considerato 

:`un oggetto inscrivibile in un cerchio di raggio R`.


`Usare WEnv`

--------------------------------------------
La scena di WEnv
--------------------------------------------

La scena del WEnv è costruita da una descrizione che può essere facilmente definita da un progettista di applicazioni
modificando il file ``node\WEnv\WebGLScene\sceneConfig.js``. 

Nel seguito, faremo riferimento a una stanza rettangolare (vuota o con ostacoli), racchiusa entro quattro pareti.
Procedendo dal bordo superiore e muovendoci in senso orario, i nomi delle pareti sono: 
``wallUp, wallRight, wallDown, wallLeft``.

La scena può anche presentare uno o più dispositivi `Sonar` che rilevano la presenza del robot e ne misurano la distanza.

Si veda :ref:`NaiveGui page`.

----------------------------------------
Come attivare WEnv
----------------------------------------

:`Usando il progetto it.unibo.virtualRobot2023`

- Installare `Node.js`_
- In ``it.unibo.virtualRobot2023\node\WEnv\server``, eseguire **npm install**
- In ``it.unibo.virtualRobot2023\node\WEnv\WebGLScene``, eseguire **npm install**
- In ``it.unibo.virtualRobot2023\node\WEnv\server\src``, eseguire **node WebpageServer.js**

:`Usando Docker`

WEnv viene anche distribuito come immagine Docker, attivabile direttamente o con *docker-compose*.

.. code::

   docker run -ti -p 8090:8090 -p 8091:8091 --rm  docker.io/natbodocker/virtualrobotdisi23:1.0
   docker-compose -f virtualRobot23.yaml  up
   //Per terminare: docker-compose -f virtualRobot23.yaml  down 

++++++++++++++++++++++++++++++++++++++++++
virtualRobot23.yaml
++++++++++++++++++++++++++++++++++++++++++

.. code::

    version: '3'
    services:
      wenv:
        image: docker.io/natbodocker/virtualrobotdisi23:1.0
        ports:
          - 8090:8090
          - 8091:8091

## -------------------------------------------------------------
## TODO See https://docs.docker.com/compose/startup-order/
## Compose does not wait until a container is “ready” (whatever that means for your particular application)
## - only until it’s running. There’s a good reason for this.
## The best solution is to perform this check in your application code,
## -------------------------------------------------------------
## docker-compose -f virtualRobot23.yaml up
## docker-compose down
## docker-compose run --service-ports wenv    starts wenv


Per un overview su Docker e DockerCompose si veda: `Introduction to Docker and DockerCompose`_.

----------------------------------------
Come interagire con WEnv
----------------------------------------

Stringhe che esprimono comandi di movimento al robot possono essere  inviate a WEnv in due modi:

- come messaggi HTTP POST inviati sulla porta **8090**. E' una forma di comunicazione `sincrona` (`request-response`).
- come messaggi inviati su un Websocket alla porta **8091**. 
  E' una forma di comunicazione `asincrona` (`fire-and-forget`) che implica l'emissione, 
  da parte di WEnv, di un :ref:`Messaggio di stato`

.. image::  ./_static/img/VirtualRobot/logicInteraction.PNG
    :align: center 
    :width: 80%
 

:`WEnv non acetta altre connessioni hhtp://HOSTADDR:8090  oltre la prima`

.. 0001058695 0000999689 0001058685 cd C:/Didattica/STUDENTI/BO2022/Temafinale2022/GianelliAndrucciMarconi/ISS-WasteService/sprint3/distribution/distributed

+++++++++++++++++++++++++++++
NaiveGui.html
+++++++++++++++++++++++++++++

Per consentire agli utenti umani prove di interazione con WEnv,
il progetto definisce una pagina HTML (file ``node/clients/NaiveGui.html``)  che permette di:

- visualizzare la scena corrente (il virtual robot deve essere stato attivato);
- inviare comandi :ref:`cril<Comandi-base per il robot in cril>` al VirtualRobot in modo sincrono (via HTTP)
  e in modo asicrono (via WebSocket) 
- visualizzare nella ``DisplayArea`` le informazioni emesse da WEnv (:ref:`Messaggio di stato`).

Ponendo il mouse sulla scena, si possono inviare al robot comandi tramite tastiera:

- tasto `w`: avanti
- tasto `s`: indietro
- tasto `a`: ruota a sinistra di `90°`
- tasto `d`: ruota a destra di `90°`

Sulla scena compare un menu `Open controls` che presenta comandi con cui modificare la scena,
inserendo/eliminando oggetti. Le modifiche vengono perse al reload della pagina.

%%%%%%%%%%%%%%%%%%%%%%%%
NaiveGui page
%%%%%%%%%%%%%%%%%%%%%%%%

La pagina si presenta come segue:

.. image::  ./_static/img/VirtualRobot/NaiveGui.PNG
    :align: center 
    :width: 50%

Attraverso questa GUI possiamo effettuare esperimenti come quelli che seguono:

- inviare un comando SYNCH e vedere l'esito sulla DISPLAY AREA
- inviare un comando SYNCH e interromperlo con i pulsanti HALTPOST oppure HALT
- inviare un comando SYNCH e subito dopo un altro comando ASYNCH o SYNCH (not allowed)
- inviare un comando ASYNCH e vedere l'esito sulla DISPLAY AREA.
- inviare un comando ASYNCH e subito dopo un  comando SYNCH (not allowed)
  
Si noti che un valore di tempo ``-1`` significa 'forever' e occorre sempre inviare un comando HALT
per poterne effettuare un altro. Si consiglia di evitare l'uso del valore -1, a favore di valori 
interi positivi adeguatamenti alti in relazione al dominio applicativo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esperimento misto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#. Eseguire il comando

   .. code:: 

      curl -d "{\"robotmove\":\"moveForward\", \"time\":\"2000\"}"  
           -H "Content-Type: application/json"  -X POST http://localhost:8090/api/move

#. Entro ``2000`` msec premere il pulsante ``HALT`` (o ``HALTPOST``) di :ref:`NaiveGui.html`

WEnv invia la risposta ``{"endmove":false,"move":"moveForward-interrupted"}`` per il comando curl e la stessa
informazione ai client-WS (che viene visualizzata sulla DISPLAY AREA di :ref:`NaiveGui.html`):

`Il linguaggio-base del vritual robot`

++++++++++++++++++++++++++++++++++++
Comandi-base per il robot in cril 
++++++++++++++++++++++++++++++++++++

Il linguaggio per esprimere comandi di movimento del robot virtuale 
viene detto `cril` (*concrete-robot interaction language*) e consiste di 
stringhe JSON secondo la sintassi che segue:

.. code::

    {"robotmove":"CMDMOVE", "time":T}    
    CMDMOVE ::= "turnLeft" | "turnRight" | "moveForward" | "moveBackward" | "alarm"
    T    ::= <NaturalNum>

%%%%%%%%%%%%%%%%%%%%%%%
alarm
%%%%%%%%%%%%%%%%%%%%%%%

Il comando **"alarm"** non è stato denominato ``halt`` per introdurre l'idea che il robot può fermarsi anche in caso 
di situazioni anomale, come ad esempio un calo dell'alimentazione o un incendio.

`Parlare con il vritual robot in modo sincrono o asicrono`

- Il comando *alarm* inviato con :ref:`Interazione sincrona` produce sempre la risposta ``{"endmove":true,"move":"halt"}``.
- Il comando *alarm* inviato con :ref:`Interazione asincrona` non produce messaggi di risposta.

`Comandi di tipo sincrono`

+++++++++++++++++++++++++++++++++
Interazione sincrona
+++++++++++++++++++++++++++++++++

In una interazione request-response, la `risposta` è espressa in forme di stringhe JSON che assumono valori diversi
in relazione alle situazioni che si possono avere. 

.. code::

    {"endmove":"RESULT", "move":"MINFO" }          
    RESULT  ::= true | false  | notallowed 
    MINFO   ::= MOVEID | MOVEID-collision | MOVEID-interrupted  
    MOVEID  ::= moveForward | moveBackward | turnLeft | turnRight

Un comando attivato con ``HTTP POST`` con durata ``T``, potrebbe terminare prima del tempo  ``T`` in quanto:

- il robot ha ricevuto (prima del tempo  ``T``)  il comando :ref:`alarm`.  

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/VirtualRobot/MoveForwardOk.png
    - mossa che termina con successo
  * - .. image:: ./_static/img/VirtualRobot/MoveForwardHalted.png
    - mossa interrotta da :ref:`alarm` 


Nel caso di interazione sincrona, si ha che:

- :`Non si può interrompere un comando con un altro comando sincrono diverso da alarm.`

+++++++++++++++++++++++++++++++++
Collision
+++++++++++++++++++++++++++++++++

Se un comando provoca il contatto del robot con un ostacolo, 
il comando ha comunque durata ``T``.

.. list-table::
  :widths: 60,40
  :width: 100%
  
  * - .. image:: ./_static/img/VirtualRobot/MoveForwardCollision.png 
    - mossa sincrona che provoca collisione

Tuttavia, i client-WS ricevono ANCHE l'informazione (:ref:`Messaggio di stato`) *collision*, che assume la forma che segue:

  ``{"collision":"moveForward","target":"OBSTACLEID"}`` 

Il mondo virtuale permette di inserire nel messaggio anche il nome dell'ostacolo (``OBSTACLEID``). Questo ovviamente 
non è possibile nel mondo reale, ma al momento può essere utile per comprendere meglio il comportamento 
delle applicazioni.

:`Esempi di comandi di tipo sincrono`

Riportiamo nel seguito  alcuni casi rilevanti, dopo avere collocato il robot nello stato iniziale convenzionale `HOME`.

`HOME`

+++++++++++++++++++++++++++++++++
Stato iniziale del virtualrobot
+++++++++++++++++++++++++++++++++

- il robot è rivolto verso il basso e si trova
  nell'angolo superiore sinistro (locazione denotata d'ora in poi come `HOME`). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esempi di comandi sincroni al VirtualRobot23
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

I comandi sono inviati, al momento, usando il tool `curl`_ e hanno la forma:

``curl CMD  -H "Content-Type: application/json" -X POST http://localhost:8090/api/move``


Gli esempi che seguono sono riferiti alla scena-base del progetto `it.unibo.virtualRobot2023`; 
in essi riporteremo solo la forma di ``CMD``.

#. - Movimento in avanti normale
       
     **Comando**: muovi in avanti per `1300 msec`:
        ``curl -d "{\"robotmove\":\"moveForward\", \"time\":\"1300\"}" ...``
     **Risposta**:
         ``{"endmove":true,"move":"moveForward"}``
#. - Movimento in avanti che provoca collisione con la parete *wallDown*:

     **Comando**: muovi in avanti per `2200 msec`:
        ``curl -d "{\"robotmove\":\"moveForward\", \"time\":\"2200\"}" ...``
     **Risposta**:
         ``{"endmove":false,"move":"moveForward-collision"}``
#. - Movimento in avanti con interruzione
 
     **Comando**: *comando1* seguito da :ref:`alarm` prima della fine:
         ``curl -d "{\"robotmove\":\"alarm\", \"time\":\"10\"}" ...``
     **Risposta**:
         ``{"endmove":false,"move":"moveForward-interrupted"}``
#. - Ritazione a sinistra normale
  
     **Comando**:ruota a sinistra con time `300 msec`:
        ``curl -d "{\"robotmove\":\"turnLeft\", \"time\":\"300\"} ..."``
     **Risposta**:
        ``{"endmove":true,"move":"turnLeft"}``
#.  - Movimento in avanti subito seguito da rotazione
 
     **Comando**: *comando1* seguito (prima della fine) da *comando4* o  altro comando SYNCH, diverso da ``HALTPOST``
     **Risposta**:
        
        ``{"endmove":"notallowed","move":"turnLeft"}``
        
        ``{"endmove":true,"move":"moveForward"}``

Esempi di interazione sincrona con WEnv basati su programmi Java saranno introdotti nella sezione 
:ref:`TestMovesUsingHttp`.


`Comandi di tipo asincrono`

+++++++++++++++++++++++++++++++++
Interazione asincrona
+++++++++++++++++++++++++++++++++

Inviare un comando in modo `fire-and-forget` significa non attendere risposta. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Messaggio di stato
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Una volta eseguto il comando, il server WEnv invia a tutti i client connessi attraverso la connessione Websocket
informazioni sull'esito del comando  (*Messaggio di stato*), con la seguente sintassi:

.. code::

    {"endmove":"RESULT", "move":"MINFO"}          
    RESULT  ::= true | false   
    MINFO   ::= MOVEID |  MOVEID_notallowed (asynch) | MOVEID-interrupted
    MOVEID  ::= moveForward | moveBackward | turnLeft | turnRight

Il significato dei valori di ``MINFO`` è il seguente:

- **MOVEID-interrupted**: mossa ``MOVEID`` interrotta perchè il robot ha ricevuto un comando  ``alarm``
- **MOVEID_notallowed (asynch)**: mossa ``MOVEID`` rifiutata (non eseguita) in quanto la mossa relativa al comando precedente 
  non è ancora terminata.

L'invio asincrono di un comando non blocca il chiamante; di conseguenza, un client può inviare un nuovo 
comando su Websocket prima che il precedente sia terminato o sia stato interrotto. 
Vale la seguente regola:

- :`Wenv NON esegue un comando, se un comando precedente non è terminato.`

.. WEnv adotta anche la regola che segue: :`E' possibile interrompere un comando con il comando alarm inviato su Websocket.`
 
Dunque:

- si invio un comando che dura un tempo ``T`` e questo provoca **collisione**, non posso inviare un altro 
  comando (che non sia :ref:`alarm`) prima della scadenza di ``T``.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esempi di comandi asincronit al VirtualRobot23
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Test di interazione asincrona con WEnv basati su programmi Java saranno `introdotti più avanti` (si veda 
:ref:`TestMovesUsingWs`).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Messaggio dall'ambiente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Un cliente connesso a WEnv mediante Websocket può ricevere anche *informazioni 
su variazioni dello stato del 'mondo'*, quali:

- dati emessi dai *sonar* presenti nella scena quando rilevano un oggetto in movimento;
- dati emessi dai *sensori di impatto* posti davanti e dietro al robot, quando rilevano un ostacolo. 
  Questi dati sono automaticamente convertiti in messaggi :ref:`Collision`.


Se nell'ambiente è presente un sonar e il robot vi passa davanti, WEnv genera: 

  .. code::

    {"sonarName": "<sonarName>", "distance": <int>, "axis": "AXIS" }
    AXIS = x | y  //a seconda dell'orientamento del sonar

    //Esempio:
    {"sonarName":"sonar1","distance":-6,"axis":"y"}

.. Messaggi di stato relativi a sonar presenti nella scena possono essere emessi indipendentemente dalla esecuzione
.. di mosse del robot, ad esempio in relazione alla rilevazione di ostacoli mobili. 



`Come è fatto WEnv`

--------------------------------------
WEnv - note di implementazione
--------------------------------------

L'implementazione di WEnv si basa su due componenti principali: 

- **server**: che definisce il programma ``WebpageServer.js`` scritto con il framework  `Node Express`_  ->
- **WebGLScene**: componente che gestisce la scena 

++++++++++++++++++++++++++++++++++++++++++++
Architettura di WEnv
++++++++++++++++++++++++++++++++++++++++++++

.. image::  ./_static/img/VirtualRobot/WenvArch.PNG
    :align: center 
    :width: 100%


``WebpageServer.js`` utilizza due diversi tipi  di WebSocket:

- un socket (detto **sceneSocket**) basato sulla libreria `socket.io`_ che viene utilizzato per gestire 
  l'interazione con **WebGLScene**.

  :`socket.io non è un'implementazione WebSocket.`

  Sebbene `socket.io`_ utilizzi effettivamente WebSocket come trasporto quando possibile, 
  aggiunge alcuni metadati a ciascun pacchetto: il tipo di pacchetto, lo spazio dei nomi  
  e l'ID di riconoscimento quando è necessario un riconoscimento del messaggio.
  Ecco perché un client WebSocket non sarà in grado di connettersi correttamente a un server Socket.IO 
  e un client `socket.io`_ non sarà in grado di connettersi a un server WebSocket.


- il websocker **8091** basato sulla libreria `ws`_ : questo socket viene utilizzato per gestire comandi 
  applicativi asincroni per muovere il robot inviati da client remoti e per inviare a client remoti un
  :ref:`Messaggio di stato`.

  WEnv utilizza la libreria Node `einaros`_ per accettare questi comendi.

  :`Il modulo ws non funziona nel browser: bisogna utilizzare l'oggetto WebSocket nativo.`


Quando ``WebvGLScene`` rileva una collisione tra il robot virtuale e un ostacolo, 
invoca l'utilità ``eventBus.js`` per 'emettere un evento collisione' 
oltre lo **sceneSocket**. 

Questo evento è gestito da un apposito handler (vedi ``sceneSocketInfoHandler`` in ``WebpageServer.js``), 
che reindirizza le informazioni a tutti i client connessi sulla  ``8091``.

++++++++++++++++++++++++++++++++++++
WEnv come immagine docker
++++++++++++++++++++++++++++++++++++

WEnv viene anche distribuito come immagine Docker.
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dockerfile e creazione dell'immagine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Il file di nome **Dockerfile** nella directory ``it.unibo.virtualRobot2020`` contiene le istruzioni per creare una 
immagine Docker (per una introduizione a Docker si veda `Introduction to Docker and DockerCompose`_).

.. code::

    node:17-alpine
    RUN mkdir -p /home/node      
    EXPOSE 8090
    EXPOSE 8091
    COPY ./node/WEnv/server /home/node/WEnv/server 
    COPY ./node/WEnv/WebGLScene /home/node/WEnv/WebGLScene
    #set default dir so that next commands executes in it
    WORKDIR /home/node/WEnv/WebGLScene
    RUN npm install
    WORKDIR /home/node/WEnv/server
    RUN npm install
    WORKDIR /home/node/WEnv/server/src
    CMD ["node", "WebpageServer"]    

L'immagine Docker può essere creata sul proprio PC eseguendo il comando (nella directory che contiene il *Dockerfile*):

    ``docker build -t virtualrobotdisi23:1.0 .``    //Notare il .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Esecuzione della immagine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

L'immagine Docker di WEnv può essere attivata sul PC con il comando:

.. code::

    docker run -ti -p 8090:8090 -p 8091:8091 --rm  virtualrobotdisi23:1.0
    

Il comando:

.. code::

   docker run -ti -p 8090:8090 -p 8091:8091 
                 --rm  virtualrobotdisi23:1.0 /bin/sh

permette di ispezionare il contenuto della macchina virtuale e di attivare manualmente il sistema
(eseguendo  ``node WebpageServer.js``).


        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Modificare la scena nella immagine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Una volta attivata l'immagine docker, il comando 

  ``dockerps ps -a`` 

restituisce una tabella con 7 campi:

     ``CONTAINERID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES``

Per modificare il file che definisce la scena, si può copiare una nuova versione attraverso il comando ``docker cp`` 
e rendere permanente la modifica salvando il container.

.. code::

    //change the scene
    docker cp sceneConfig.js  
           CONTAINERID:/home/node/WEnv/WebGLScene/sceneConfig.js
    //Save the cotainer
    docker commit  CONTAINERID



`Programmi naive di uso di WEnv`

-----------------------------------------
Programmi naive 
-----------------------------------------

L'ambiente WEnv verrà utilizzato nello sviluppo di applicazioni proattive/reattive basate su 
componenti che interagiscono a scambio di messaggi con interazioni sincrone e/o asincrone.

Durante lo sviluppo di queste applicazioni, a complessità via via crescente, avremo modo di costruire
infrastrutture di supporto e astrazioni di comunicazione capaci di agevolare il compito dell'application-designer.

Prima di procedere in questa direzione, introduciamo alcuni esempi di controllo del robot attraverso programmi
Java scritti in modo 'naive', :`avvalendoci nel modo più semplice e diretto 
delle librerie` disponibili come supporto alle comunicazioni vie rete.

 

:`Uso di HTTP library`

+++++++++++++++++++++++++++++++++
TestMovesUsingHttp
+++++++++++++++++++++++++++++++++

In ``javasrc/it/unibo/virtualRobot2023/clients``  

.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - :`TestMovesUsingHttp.java`
    
      Esegue  mosse di base del robot inviando vie ``HTTP``  
      comandi espressi in in :ref:`cril<Comandi-base per il robot in cril>`

    - `Key point`: Richiesta `sincrona`. 

      Richiede 1 thread.

Dal punto di vista 'sistemistico' osserviamo che:

- Il codice di comunicazione è scritto completamente dal progettista dell'applicazione che usa la libreria *org.apache.http*.
- La gestione delle risposte JSON viene eseguita utilizzando la libreria  `json-simple`_.

Dal punto di vista 'applicativo', osserviamo che:

- Il chiamante esegue comandi nella forma *request-response*.
- Un eventuale :ref:`Messaggio di stato` inviato da WEnv non viene percepito.
- E' possibile `interrompere` la esecuzione di una mossa inviando il comando :ref:`alarm`.
- Una mossa che termina prima del tempo indicato nel comando (per interruzione o :ref:`Collision`, 
  restituisce la risposta ``{"endmove":"false", "move":"MINFO" }`` introdotta in :ref:`Interazione sincrona`.  

L'interazione mediante ``HTTP`` viene realizzata da un client ``org.apache.http.client`` invocato entro
una procedura di utilità definita come segue: 

%%%%%%%%%%%%%%%%%%%%%%%%%%%
callHTTP
%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: java

  private  JSONParser simpleparser = new JSONParser();

  protected JSONObject callHTTP( String crilCmd )  {
  JSONObject jsonEndmove = null;
   try {
     StringEntity entity = new StringEntity(crilCmd);
     HttpUriRequest httppost = RequestBuilder.post()
        .setUri(new URI(URL))
        .setHeader("Content-Type", "application/json")
        .setHeader("Accept", "application/json")
        .setEntity(entity)
        .build();
     CloseableHttpResponse response = httpclient.execute(httppost);
     String jsonStr = EntityUtils.toString( response.getEntity() );
     jsonEndmove    = (JSONObject) simpleparser.parse(jsonStr);
   } catch(Exception e){...}
   return jsonEndmove;
  }

:`Operazioni di test`

%%%%%%%%%%%%%%%%%%%%%%%%%%%
TestMovesUsingHttp tests
%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - .. image:: ./_static/img/VirtualRobot/testHttpForwardOk.png
    - `Muovi in avanti senza collisioni`
     
      .. code:: java

        public void doForward() {
          String forwardcmd="{\"robotmove\":\"moveForward\",\"time\":\"1000\"}";
          CommUtils.waitTheUser("PUT ROBOT in HOME  and hit");
          JSONObject result = callHTTP(  forwardcmd  );
          CommUtils.outblue("moveForward endmove=" + result);
        }
  * - .. image:: ./_static/img/VirtualRobot/testHttpForwardCollision.png
    - `Muovi in avanti con collisione`
    
      .. code:: java

        public void doCollision() {
          String forwardcmd="{\"robotmove\":\"moveForward\",\"time\":\"3000\"}";
          JSONObject result = callHTTP(  forwardcmd  );
          CommUtils.outblue("moveForward endmove=" + result);
        }

  * - .. image:: ./_static/img/VirtualRobot/testHttpForwardHalted.png
    - `Muovi in avanti e ferma prima della fine`
     
      .. code:: java

        public void doHalt() {
          String forwardcmd="{\"robotmove\":\"moveForward\",\"time\":\"3000\"}";
          sendAlarmAfter(1000);
          JSONObject result = callHTTP(  forwardcmd );
          CommUtils.outblue("moveForward endmove=" + result);
        }

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Invio di alarm
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Per inviare al robot un comando *halt* (messaggio :ref:`alarm`) si possono usare diversi modi:

- Usare :ref:`NaiveGui.html`.
- Lanciare una nuova applicazione Java.
- Attivare (come fatto in ``doHalt``) un Thread interno a :ref:`TestMovesUsingHttp`, ma **senza riusare** 
  lo stesso metodo :ref:`callHTTP`:
  
  .. code:: java

    protected void sendAlarmAfter( int time ){
      new Thread(){
        protected JSONObject mycallHTTP( String crilCmd )  {
         ... 
        }
        public void run(){
          CommUtils.delay(time);
          JSONObject result = mycallHTTP(  haltcmd  );
          CommUtils.outgreen("sendAlarmAfter result=" + result);
        }
      }.start();
    } 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
AutomaticTestHTTP 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Grazie a JUnit, possiamo includere le azioni di :ref:`TestMovesUsingHttp tests`
all'interno di una unità di testing che le esegue in modo automatizzato.

.. code::

   import org.junit.Before;
   import org.junit.Test;
   import org.apache.http.impl.client.CloseableHttpClient;
   import org.apache.http.impl.client.HttpClients;
   public class AutomaticTestHTTP {

   private CloseableHttpClient httpclient;
  
    @Before
    public void init(){
        httpclient = HttpClients.createDefault();
        //ASSUNZIONE: prima di ogni test il robot deve essere in HOME
    }

    @Test
    public void doForward() {
        JSONObject result = callHTTP(  forwardcmd  );
        assert( result.get("endmove").equals("true") && result.get("move").equals("moveForward")) ;
        //BACK TO HOME
        JSONObject result1 = callHTTP(  backwardcmd  );
        assert( result1.get("move").toString().contains("moveBackward")) ;
    }

   }


:`Uso di  websocket`

+++++++++++++++++++++++++++++++++
TestMovesUsingWs
+++++++++++++++++++++++++++++++++

In ``javasrc/it/unibo/virtualRobot2023/clients``  

.. list-table:: 
  :widths: 60,40
  :width: 100%

  * - :`TestMovesUsingWs.java`

      Esegue  mosse di base del robot inviando via ``WebSocket``  comandi espressi in :ref:`cril<Comandi-base per il robot in cril>`

    - `Key point`: Richiesta `asincrona`

      Richiede 4 thread, a causa della libreria ``javax.websocket``.

**Dal punto di vista 'sistemistico'**, osserviamo che:

- Il codice di comunicazione è scritto completamente dal progettista dell'applicazione, che utilizza 
  la libreria ``javax.websocket``  (vedi anche `I WebSocket Comunicazione Asincrona Full-Duplex Per Il Web`_)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Uso di annotazioni
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  Gli eventi del ciclo di vita dell'endpoint WebSocket sono gestiti mediante :ref:`Annotazioni`
  secondo lo schema che segue:

  .. code:: 
   
     @ClientEndpoint  //La classe viene trattata come un client WebSocket   
     public class ... {    
        @OnOpen //chiamato quando si avvia una nuova connessione WebSocket
        public void onOpen(Session userSession){ ... }
            
        @OnMessage //chiamato quando  arriva un  messaggio di stato
        public void onMessage(String message){ ... }

        @OnError //chiamato quando si verifica un problema con la comunicazione
        public void onError (sessione di sessione, errore lanciabile){...}
            
        @Chiudi //chiamato alla chiusura della connessione WebSocket
        public void onClose(Session userSession,CloseReason reason){...}
      }

**Dal punto di vista 'applicativo'**, osserviamo che:

- Il chiamante esegue concettualmente una *fire-and-forget*.
- Un eventuale :ref:`Messaggio di stato` viene 'iniettato' nell'applicazione tramite una chiamata al metodo annotato 
  con ``@OnMessage``.
- E' possibile `interrompere` la esecuzione di una mossa inviando il comando :ref:`alarm`.
- Per una mossa che termina prima del tempo indicato nel comando (per interruzione o :ref:`Collision`, 
  vengono percepiti due :ref:`Messaggio di stato`: ``{"collision":MOVEID, "target":"..." }`` 
  e ``{"endmove":"false", "move":"MINFO" }``
   

L'interazione mediante ``WebSocket`` viene realizzata dalla libreria ``javax.websocket`` invocato entro
una procedura di utilità definita come segue: 

%%%%%%%%%%%%%%%%%%%%%%%%%%%
callWS
%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: java

    //Fase iniziale di connessione
    private Session userSession  = null;
    WebSocketContainer container = ContainerProvider.getWebSocketContainer();
    container.connectToServer(this, new URI("ws://"+addr));

    @OnOpen
    public void onOpen(Session userSession) {
         this.userSession = userSession;
    }

    protected void callWS(String msg )   {
        this.userSession.getAsyncRemote().sendText(msg);
        // try {
        //   this.userSession.getBasicRemote().sendText(msg);
        //   //synch version: blocks until the message has been transmitted
        // }catch(Exception e) {}       
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%
TestMovesUsingWs onMesage
%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code:: java

    @OnMessage
    public void onMessage(String message)  {
        long duration = System.currentTimeMillis() - startTime;
        try {
          //{"collision":"true ","move":"..."} or 
          //{"sonarName":"sonar2","distance":19,"axis":"x"}
          JSONObject jsonObj = (JSONObject) simpleparser.parse(message);
          if (jsonObj.get("endmove") != null ) {
                boolean endmove = jsonObj.get("endmove").toString().equals("true");
                String  move    = (String) jsonObj.get("move") ;
                CommUtils.outgreen("TestMovesUsingWs | endmove:" + endmove + " move="+move);
                if( count++ == 0 ) { //test
                    callWS(  turnleftcmd  );CommUtils.delay(350);
                    callWS(  turnrightcmd  );
                }
          }else if (jsonObj.get("collision") != null ) {
                String move   = (String) jsonObj.get("collision");
                String target = (String) jsonObj.get("target");
                //halt();
                //senza halt il msg {"endmove":"false","move":"moveForward-collision"} arriva dopo T
          }else if (jsonObj.get("sonarName") != null ) { //JUST TO SHOW ...
                String sonarName = (String) jsonObj.get("sonarName") ;
                String distance  = jsonObj.get("distance").toString();
          }
        } catch (Exception e) {
        	CommUtils.outred("onMessage " + message + " " +e.getMessage());
        }
    }


%%%%%%%%%%%%%%%%%%%%%%%%%%%
TestMovesUsingWs tests
%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - .. image:: ./_static/img/VirtualRobot/testHttpForwardOk.png
    - `Muovi in avanti senza collisioni`
     
      .. code:: java

        public void doForward() {
          String forwardcmd="{\"robotmove\":\"moveForward\",\"time\":\"1000\"}";
          CommUtils.waitTheUser("PUT ROBOT in HOME  and hit");
          startTime = System.currentTimeMillis();
          callWS(  forwardcmd  );
          CommUtils.waitTheUser("Hit to terminate doForward");
        }

        //MESSAGGI DI STATO
        onMessage:{"endmove":"true","move":"moveForward"} duration=1055

  * - .. image:: ./_static/img/VirtualRobot/testWsForwardCollision.png

      .. image:: ./_static/img/VirtualRobot/testWsForwardCollisionWithHalt.png
  
    - `Muovi in avanti con collisione`
     
      .. code:: java

        public void doCollision() {
          String forwardcmd   = "{\"robotmove\":\"moveForward\", \"time\":\"3000\"}";
          startTime = System.currentTimeMillis();
          callWS(  forwardcmd  );
        }

        //MESSAGGI DI STATO
        //SENZA halt in onMessage relativo a collision
        onMessage:{"collision":"moveForward","target":"wallDown"} duration=841
        onMessage:{"endmove":"false","move":"moveForward-collision"} duration=3019

        //CON halt in onMessage relativo a collision
        onMessage:{"collision":"moveForward","target":"wallDown"} duration=1256
        onMessage:{"endmove":"false","move":"moveForward-collision"} duration=1310

  * - .. image:: ./_static/img/VirtualRobot/testWsNotallowed.png
    - `Muovi in avanti e ruota a sinistra prima della fine`
      
      .. code:: java

        public void doNotAllowed() {
          String forwardcmd="{\"robotmove\":\"moveForward\",\"time\":\"1200\"}";
          callWS(  forwardcmd  );          
          CommUtils.delay(400);
          callWS(  turnleftcmd  );
        }

        //MESSAGGI DI STATO
        onMessage:{"endmove":"false","move":"turnLeft_notallowed (asynch)"}
        onMessage:{"endmove":"true","move":"moveForward"}

  * - .. image:: ./_static/img/VirtualRobot/testHttpForwardHalted.png
    - `Muovi in avanti e ferma prima della fine`
      
      .. code:: java

        public void doHalt() {
          String forwardcmd="{\"robotmove\":\"moveForward\",\"time\":\"3000\"}";
          callWS(  forwardcmd  );          
          CommUtils.delay(1000);
          callWS(  haltcmd  );
        }

        //MESSAGGI DI STATO
        onMessage:{"endmove":"false","move":"moveForward-interrupted"} duration=1028


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
AutomaticTestWs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La definizione di una classe di testing automatizzato analoga :ref:`AutomaticTestHTTP` potrebbe non essere 
di immediata realizzazione. Il lettore è inviatato a individuare i problemi che sorgono a livello di scrittura 
del codice, sui quali noi torneremo in seguito.

`Programmi applicativi di uso di WEnv`

-------------------------------------------------
Programmi applicativi di uso del VirtualRobot 
-------------------------------------------------

#. Si veda il `progetto` :ref:`VirtualRobotUsage25`

========================================
VirtualRobotUsage25
========================================

-----------------------------------
Verso l'uso del VirtualRobot
-----------------------------------

Procediamo in modo top-down definendo le interazioni 
`dal punto di vista del livello applicativo`.

   .. list-table::
    :widths: 60,40
    :width: 100%
    
    * - :`Protocolli`
    
        L'applicazione vuole comunicare con il robot senza conoscere i dettagli della comunicazione.

        A tal fine ricordiamo :ref:`unibo.basicomm23.interfaces.Interaction`.

      -  
      
        .. code:: java

          ProtocolType protocol = ProtocolType.ws;   
          //ProtocolType protocol = ProtocolType.http;
          Interaction conn =
          ConnectionFactory.createClientSupport(
               protocol, "localhost", "8090/api/move");

        Per un esempio si veda: `TestMovesUsingWs.java`_, in cui i comandi sono esprressi in 
        :ref:`cril<Comandi-base per il robot in cril>`.
    * - :`Informazioni da WEnv`
    
        L'applicazione potrebbe voler ricevere le informazioni di stato 
        dovute al robot ( (:ref:`Messaggio di stato`)  e da :ref:`WEnv<Interazione asincrona>` in 
        forma di eventi
      -  
      
        .. code:: java

          Event vrinfo : vrinfo(A,B)
    
    * - :`Comandi di movimento`
    
        L'applicazione vorrebbe inviare al robot i comandi di movimento come dispatch
      
      -        
        .. code:: java

          Dispatch move : move(M)  "M = w|s|a|d!r!l"
          


    * - :`Console`
    
        L'applicazione vorrebbe rendere disponibile ad un utente umano  una console per inviare comandi al robot
        e per visualizzare ogni :ref:`Messaggio di stato`
      -  
        Si veda  `NaiveGui.html`_


`Per avvicinarci ai desideri del livello applicativo`:

All `parola 'robot'` possono corrispondere diversi tipi di **componenti software** che 
ne realizzano il significato in termni di struttura, interazione e funzionamento.

Nel seguito, introduciamo i seguenti componenti:

-------------------------------------------------
VrobotLLMoves24: Robot come POJO a eventi qak
-------------------------------------------------

.. list-table::
  :widths: 20,80
  :width: 100%

 
  * - :ref:`VrobotLLMoves24`
    - un POJO che **può possedere** un `owner` di tipo :ref:`ActorBasic<QakActors25Actors>`  
      che realizza i comandi di movimento definiti dalla interfaccia ``IVrobotLLMoves``:
      
      .. code::

        public interface IVrobotLLMoves {
          //Ispirate da VirtualRobot23
            public void turnLeft() throws Exception;
            public void turnRight() throws Exception;
            public void forward( int time ) throws Exception;
            public void backward( int time ) throws Exception;
            public void halt() throws Exception;

          //Nuove operazioni
            public boolean step(long time) throws Exception;
        }

      Questo componente:

      - converte i comandi di movimento in comandi per il virtual robot in 
        espressi con il :ref:`cril<Comandi-base per il robot in cril>`
      - trasforma i :ref:`messaggi di stato` emessi da :ref:`WEnv:` in dispatch ed 
        eventi applicativi che possono
        essere percepiti dall'owner, se esiste. In assenza di owner, gli **eventi** emessi 
        possono essere percipiti da altri aqttoriqak del sistema, mentre i dispatch non sono
        generati.
      - introduce anche una nuova mossa: ``step(time:int)`` (si veda :ref:`step`)


--------------------------------------------------------------
VrobotHLMoves24: Robot come POJO a eventiqak e stepAsynch
--------------------------------------------------------------

.. list-table::
  :widths: 20,80
  :width: 100%

  * - :ref:`VrobotHLMoves24`
    - un POJO che opera come :ref:`VrobotLLMoves24` con le segeunti differenze:

      - Implementa la interfaccia ``IVrobotMoves``
        
        .. code::
          
          public interface IVrobotMoves {
            //Ispirate da VirtualRobot23
              public void turnLeft() throws Exception;
              public void turnRight() throws Exception;
              public void forward( int time ) throws Exception;
              public void backward( int time ) throws Exception;
              public void halt() throws Exception;

            //Nuove operazioni
              public boolean step(long time) throws Exception;
            public void stepAsynch(int time) throws Exception;
            
            //Aril (Abstract Robot Interaction Lanaguage)
            //cmd=w | s | l | r | h"
            public void move(String cmd ) throws Exception;
          }

      - introduce comandi `move` che formano :ref:`Il linguaggio aril` 
        (**Abstract Robot Interaction Language**)
      - definisce la nuova 'mossa' `stepAsynch`  basato sulle seguente specifica logica:
        (si veda l'esempio `vrusage25B.qak`_):

        .. code::

          Request step       : step(TIME)   
          Reply stepdone     : stepdone(V)                 for step
          Reply stepfailed   : stepfailed(DURATION, CAUSE) for step

        Poichè il componente è un POJO, le `reply` sono emesse in forma di **Dispatch** 
        inviati all'onwer (se eisie).



-------------------------------------------------
vrqak: Robot come microservizio-base
-------------------------------------------------

.. list-table:: 
  :widths: 20,80
  :width: 100%

  * - :ref:`vrqak<Il microservizio vrqak24>`
    - un MICROSERVIZIO che:
     
      - permette l'uso remoto del :ref:`VirtualRobot23` 
        attraverso invio di messaggi
      - opera come una :`risorsa osservabile`
        che permette ai clienti di percepire informazioni di stato su robot
        e sull'ambiente in cui il robot opera.


-------------------------------------------------
BasicRobot24: Robot come agente evoluto
-------------------------------------------------

.. list-table::
  :widths: 20,80
  :width: 100%

  * - :ref:`BasicRobot24`
    - un AGENTE SITUATO che  realizza  un robot che:

      - risulta indipendente dalla tecnologia 
        con cui è realizzato uno specifico DDR robot (virtuale o reale)
        attraverso l'uso di adapter e di un file di configurazione
      - estende in modo rilevante l':ref:`insieme di funzioni<BR24 Le funzioni>`
        che è capace di eseguire, includendo sequenze di movimenti, posizionamenti
        del robot ed esecuzione di piani di movimento mediante un :ref:`planner` interno.
      - richiede la conoscenza di una :ref:`mappa<BR24 e le mappatura dell'ambiente>` 
        dell'area in cui il robot è chiamato a muoversi.

+++++++++++++++++++++++++++++++++++++++++++++++++
AI-Overview dei componenti-robot
+++++++++++++++++++++++++++++++++++++++++++++++++
   
Per un ulteriore sommario (prodotto dalla AI), si veda: :ref:`VirtualRobotUsage25Survey`.

-------------------------------------------
VrobotLLMoves24
-------------------------------------------

- Definiamo un adapter (:ref:`VrobotLLMoves24`) che converta comandi di movimento in comandi per il robot in 
  :ref:`cril<Comandi-base per il robot in cril>`
  e che trasformi i messaggi di stato in eventi applicativi.

   .. image:: ./_static/img/VrobotLLMsgStatocomando24.png
      :align: center
      :width: 60%
  
  Questo adapter introduce anche una nuova mossa: ``step(time:int)`` (si veda :ref:`step`)


--------------------------------------------------
Esempi di uso di VrobotLLMoves24
--------------------------------------------------

Progetto `virtualrobotusage25`

- Gli esempi sono elencati in ordine crescente di 'astrazione'. 
- :slidekp:`KEY-POINT-1`: il supporto :ref:`VrobotLLMoves24` fornisce metodi per muovere
  il robot usando il linguaggio :ref:`cril<Comandi-base per il robot in cril>` 
  ed :`emette informazioni` (messaggi ed eventi) nel caso abbia un *actorqak*  come owner. 
  
  L'`owner svolge il ruolo di una  "mente"` capace di svolgere compiti applicativi
  tenendo conto di 'dati sensoriali' provenienti dal robot e dall'ambiente.
- :slidekp:`KEY-POINT-2`: esempi 'evoluti' usano il metodo `step` che
  può rendere più semplice la progrewttazione e la realizzazione di applicazioni.
- :slidekp:`KEY-POINT-3`: il metodo `step` viene realizzato in modo **sincrono**
  dal supporto :ref:`VrobotLLMoves24` e viene realizzato in modo :`asincrono`
  dal nuovo supporto :ref:`VrobotHLMoves24` che estende il linguaggio comprensibile al robot
  con :ref:`Il linguaggio aril`.
- :slidekp:`KEY-POINT-4`: gli esempi costituiscono la `"premessa evolutiva"` per la 
  defiizione di un micro-servizio (:ref:`Il microservizio vrqak24`) 
  che  permettere l'uso remoto del robot da parte di componenti applicativi
  mediante :ref:`Il linguaggio aril`.

++++++++++++++++++++++++++++++++++++++++++++++++
Robot come agente che provoca eventi
++++++++++++++++++++++++++++++++++++++++++++++++

.. list-table::
  :widths: 40,60
  :width: 100%
  
  * - `TestVrrobotLLMoves24.java`_
    - Un programma Java che usa il supporto senza owner qak. 

      Le informazioni emesse dal supporto NON sono visibili a livello applicativo, ma 
      possono essere visualizzate ponendo ``setTrace(true)`` 

  * - `BoundaryWalkNaiveUsingWs.java`_
    - Un programma Java che usa il supporto senza owner qak e muove il robot
      lungo il perimetro (privo di ostacoli) della stanza, inviando un comando ``forward``
      di durata tale da garantire l'incontro del robot col muro di front  

  * - `vrusage25_basic.qak`_ 
    - Un attore qak che opera come owner di :ref:`VrobotLLMoves24` eseguendo 
      mosse-base che provocano l'emissione delle seguenti info:

      .. code::

        {"endmove":"true","move":"turnLeft"}
        {"sonarName":"sonar1","distance":-4,"axis":"y"}
        {"collision":"moveForward","target":"wallRight"}
        {"endmove":"false","move":"moveForward-collision"}

++++++++++++++++++++++++++++++++++++++++++++++++
Robot come agente proattivo-reattivo
++++++++++++++++++++++++++++++++++++++++++++++++

.. list-table::
  :widths: 40,60
  :width: 100%

  * - `vrusage25A.qak`_ 
    - Un attore qak che opera come owner di :ref:`VrobotLLMoves24`.
      Induce il robot a percorrere il boundary della stanza (SUPPOSTO PRIVO DI OSTACOLI)
      fermandolo per ``2 sec`` quando rilevato dal SONAR della stanza

      Le informazioni emesse dal supporto sono  percepite a livello applicativo come:

      .. code::

        Dispatch vrinfo  : vrinfo(MOVE,T)        "inviato dal supporto dopo mossa ok "
        Dispatch vrinfo  : vrinfo(T,collision)   "inviato dal supporto dopo mossa ko "

        Event vrinfo   : vrinfo(obstacle,unknown)   "emesso dal supportp dopo collisione"
        Event obstacle : obstacle(unknown)          "emesso dal supporto dopo mossa ko"

      L'owner usa il comando  `step sincrono` e invia un ``autodispatch`` alla 
      ricezione del risultato.


      :slidekp:`OSSERVO CHE` la reattività richiede che l'agente non esegua azioni che lo rendono
      insensibile agli eventi. Per questo una mossa **step** a tempo limitato è opportuna.

  * - `vrusage25B.qak`_ 
    - Un attore qak che opera come `vrusage25A.qak`_ usando il supporto :ref:`VrobotHLMoves24`
      ed il comando `stepAsynch(370)`` da questi definito, che implica
      l'invio all'owner di un messaggio di **reply** da parte del supporto.

      .. code::

        Request step       : step(TIME)    //LOGICAMENTE eseguito da stepAsynch
        Reply stepdone     : stepdone(V)                 for step  //emesoo dal supporto
        Reply stepfailed   : stepfailed(DURATION, CAUSE) for step  //emesoo dal supporto


      :slidekp:`OSSERVO CHE` 
      **stepAsynch** 'libera' l'owner dall'onere di generare ``autodispatch`` al termine di uno **step sincrono**
      e rende l'owner capace di gestire allarmi che sorgono durante la esecuzione di uno *step*.
      
      Concettualmente, una invocazione `stepAsynch(370)`` è una **request** al supporto, 
      che è obbligato a risondere con una **reply**  all'owner.
      
      .. Un contatore conta il numero dei passi eseguiti cone successo.

+++++++++++++++++++++++++++++++++++++++++++++++++++
Il microservizio vrqak24
+++++++++++++++++++++++++++++++++++++++++++++++++++
 

- Definiamo un servizio :ref:`vrqak24` per permettere l'uso remoto del :ref:`VirtualRobot23`.

  Per un esempio, si veda: `vrqak24.qak`_ nel `progetto vrqak24`.
  
  Questo servizio può costituire il punto di partenza per la realizzazione di un servizio più esteso,
  che includa anche la gestione di uno specifico robot fisico.
  (d'ora in poi denominato :`basicrobot`) 

- Usiamo il **nuovoadapter** (:ref:`VrobotHLMoves24`)  

:slidekp:`1- OSSERVO CHE`: l'analisi e la progettazione del (micro)servizio cominciano 
dalla `specifica della interazione` tramite messaggi. Ad esempio:

.. list-table::
  :widths: 50,50
  :width: 100%

  * -   

      .. code::

        /*!*/ Dispatch move : move(M)  

        /*2*/ Request step     :step(TIME)	   
        /*2a*/ Reply stepdone  :stepdone(V)          for step
        /*2b*/ Reply stepfailed:stepfailed(T, CAUSE) for step

        /*3*/ Event  sonarval : distance( DISTANCE ) 	    

    - 
      1. Comando in :ref:`aril<Il linguaggio aril>`: ``M = w|s|a|d|p``
      2. Comando ASINCRONO con due possibili risposte
      3. Evento emesso dal servizio per segnalare che il ``SONAR`` (di **WEnnv**)
         ha calacolato la distanza di un ostacolo mobile (il robot)

:slidekp:`2- OSSERVO CHE`: la specifica dei messaggi di interazione corrisponde alla specifica
di una `Interface` di un POJO:


:slidekp:`3- OSSERVO CHE`: in accordo con Alan Kay, possiamo dire che :slide3`Languages are like wings and chains.`

In effetti,
il linguaggio Qak :`abilita` alla costruzione di (modelli di) sistemi distributi (nascondendo dettagli rilevanti come 
la realizzazione delle comunicazioni locali e remote tra attori) mentre :`costringe` il programmatore a impostare
il codice come un Aitoma a Stati Finiti. Questa :`costrizione è voluta` per 'indirizzare' lo sviluppatore del software
a una impostazione 'pulita' del codice (e prima ancora dei suoi pensieri ...).


:slidekp:`4- OSSERVO CHE`: la costruzione di un (micro)servizio in linguaggio Qak consente di utilizzare questo componente
`anche a livello locale`. Si veda come esempio: `mapobstconservice.qak`_ in :ref:`RobotMap<Mappa usando un servizio locale>`.

+++++++++++++++++++++++++++++++++++
VrobotHLMoves24
+++++++++++++++++++++++++++++++++++

Questo adapter opera come :ref:`VrobotLLMoves24` con due differenze:

  - introduce comandi nel :ref:`Il linguaggio aril` (**Abstract Robot Interaction Language**)
  - permette l'invio di un comando `stepAsynch`  basato sulle seguente specifica
    (si veda l'esempio `vrusage25B.qak`_):

    .. code::

      Request step       : step(TIME)   
      Reply stepdone     : stepdone(V)                 for step
      Reply stepfailed   : stepfailed(DURATION, CAUSE) for step


+++++++++++++++++++++++++++++++++++
Il linguaggio aril
+++++++++++++++++++++++++++++++++++

Poichè l'uso di un robot virtuale è **solo un passo intermedio** verso un robot fisico,
che potrebbe avere  un linguaggio di comando diverso,
può essere opportuno introdurre un linguaggio di comando ‘technology-independent', 
che  denominiamo `linguaggio aril` (**Abstract Robot Interaction Lanaguage**)
con cui esprimere i comandi-base di spostamento con la sintassi che segue:

.. code::

    MOVE = w | s | l | a | r | d| h | p 

    w : muove avanti per 2500 msec
    s: muove indietro per 2500 msec
    l,a:  gira a sinistra di 90 per 300 msec
    r,d:  gira a destra di 90 per 300 msec
    p: step asincrono per 370 msec


.. Dispatch cmd : cmd( M ) "aril M=MOVE


----------------------------------------
Mappa della stanza
----------------------------------------

Un (micro)servizio relativo al robot potrebbe/dovrebbe incudere anche comandi per 

- posizionare il robot in uno specifico punto della stanza
- muovere il robot da un punto A a un punto B della stanza (liberi da ostacoli)

Un premessa utile al raggiungimento di questi obiettivi è la costruzione di una
**rappresentazione a livello software della stanza**.

:slidekp:`OSSERVO CHE` la rappresentazione software di entità "del mondo reale" quali la stanza o il robot
conduce rapidamente all'idea del `Gemello digitale` (si veda `Digital twin`_).

Per la costruzione di una mappa, si veda :ref:`RoomMap`.