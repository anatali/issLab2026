
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>APIDescription &#8212; protobook 1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="protobook documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="apidescription">
<h1>APIDescription<a class="headerlink" href="#apidescription" title="Permalink to this heading">¶</a></h1>
<section id="openapi-specification">
<span id="id1"></span><h2>OpenAPI Specification<a class="headerlink" href="#openapi-specification" title="Permalink to this heading">¶</a></h2>
<p><a href="#id4"><span class="problematic" id="id5">`OpenAPI`_</span></a> (precedentemente noto come <strong>Swagger</strong>) è oggi lo standard de facto per descrivere
API HTTP/REST.</p>
<p>Un <em>documento OpenAPI</em> rappresenta una descrizione formale di un’API,
(endpoint, metodi (GET, POST, …), parametri, tipi di dato, schemi di richiesta/risposta,
sicurezza, metadati, ecc) che può essere utilizzata da diversi
strumenti per generare codice, documentazione, test case e altro ancora.
Il documento:</p>
<ul class="simple">
<li><p>può essere serializzato in JSON o YAML ed essere letto da tool che <strong>generano</strong>
<em>client</em>, <em>server-stub</em>, <em>documentazione interattiva</em>, <em>test automatici</em>, ecc.</p></li>
<li><p><strong>REST API</strong>
rappresenta il contratto formale che definisce <strong>cosa offre il servizio</strong>, senza esporre l’implementazione.
Questo facilita interoperabilità, evoluzione indipendente dei servizi.</p></li>
<li><p>non è un formalismo “semantico” come quelli della teoria del calcolo.
Serve a descrivere <em>API</em>, <strong>non</strong> a definire <em>comportamenti dinamici, proprietà concorrenti, tipologie di stato,
invarianti, transazioni, sincronizzazione</em></p></li>
</ul>
<p>Una specifica come la <strong>OAS</strong> (<a class="reference internal" href="#openapi-specification"><span class="std std-ref">OpenAPI Specification</span></a>) può servire come <strong>contratto di superficie</strong>
(quello che un sistema-servizio “dichiara di offrire”, come <strong>endpoint</strong> e - nelle versioni più recenti -
anche <strong>eventi</strong>, <strong>webhooks</strong>),
ma <strong>non</strong> come modello completo per la dinamica del servizio.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>webhooks sono una funzionalità introdotta nativamente con la versione 3.1,
per descrivere comunicazioni “out-of-band” o asincrone iniziate dal server.</p>
<p>A differenza delle API tradizionali (<strong>PULL</strong>), dove il client interroga il server,
i <em>webhooks</em> seguono un modello <strong>PUSH</strong>: il server invia proattivamente dati al client
quando si verifica un evento specifico.</p>
</div>
<p>Il livello descrittivo <strong>OAS</strong> rimane un’astrazione relativamente semplice,
vicina al modello ‘REST + callback HTTP’.</p>
<p>Poichè <strong>non tutti i sistemi software sono servizi</strong>,
per sistemi complessi, distribuiti, dinamici, event-driven — la documentazione API non basta:
serve un formalismo di <strong>comportamento e coordinazione</strong>, non soltanto di interfaccia.</p>
</section>
<section id="asyncapi">
<span id="id2"></span><h2>AsyncAPI<a class="headerlink" href="#asyncapi" title="Permalink to this heading">¶</a></h2>
<p>Mentre per un’API HTTP è il Client a decidere quando chiamare il sistema,
con gli <em>eventi</em> è il sistema che decide quando informare il mondo esterno.
Per le forme di interazione ad eventi uno standard usato è <strong>AsyncAPI</strong>
che (in un file <em>asyncapi.yaml</em>) elenca i <strong>Channels</strong> e le operazioni di <em>Publish</em> (quello che il sistema emette)
e <em>Subscribe</em> (quello che il sistema riceve).</p>
<p><em>AsyncAPI</em> non è una tecnologia di comunicazione, ma uno standard di documentazione.
È nato per affiancare OpenAPI per coprire ciò che OpenAPI non poteva fare: il mondo asincrono.
Permette di documentare cosa succede quando un servizio lancia un messaggio (es. su <code class="docutils literal notranslate"><span class="pre">RabbitMQ</span></code> o <code class="docutils literal notranslate"><span class="pre">Kafka</span></code>)
per avvisare tutti gli altri di un allarme o di un fatto applicativo.</p>
<ul class="simple">
<li><dl class="simple">
<dt><em>OpenAPI</em>: Descrive una conversazione <em>Domanda -&gt; Risposta immediata</em> (<strong>Sincrona</strong>) con possibile</dt><dd><p>semplici notifiche con webhooks</p>
</dd>
</dl>
</li>
<li><p><em>AsyncAPI</em>: Descrive un <em>flusso di messaggi</em> dove chiunque può inviare qualcosa in qualsiasi momento (<strong>Asincrona</strong>).
È perfetto per le WebSocket perché gestisce sia chi “Invia” (<em>Publish</em>) sia chi “Ascolta” (<em>Subscribe</em>).</p></li>
</ul>
<p><em>AsyncAPI</em> ricalca la struttura di OpenAPI ma la adatta ai sistemi di messaggistica asincrona
e permette di definire il “contratto” di un’interfaccia <span class="xref std std-ref">WebSockets</span> in modo
che sia leggibile dalle macchine.</p>
<p><em>AsyncAPI</em> usa un file (<code class="docutils literal notranslate"><span class="pre">YAML</span></code> o <code class="docutils literal notranslate"><span class="pre">JSON</span></code>) per descrivere formalmente:</p>
<ul class="simple">
<li><p><strong>Servers</strong>: L’indirizzo del server (es. <code class="docutils literal notranslate"><span class="pre">ws://localhost:8080</span></code>).</p></li>
<li><p><strong>Channels</strong> (I percorsi): Specifica che esiste un canale <code class="docutils literal notranslate"><span class="pre">/xxx</span></code>.</p></li>
<li><p><strong>Messages</strong> (Il contenuto): Descrive la forma dei dati.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asyncapi</span><span class="p">:</span> <span class="mf">2.6.0</span>
<span class="n">info</span><span class="p">:</span>
  <span class="n">title</span><span class="p">:</span> <span class="n">Sistema</span> <span class="n">S</span> <span class="n">API</span>
  <span class="n">version</span><span class="p">:</span> <span class="mf">1.0.0</span>
<span class="n">channels</span><span class="p">:</span>
  <span class="o">/</span><span class="n">f1</span><span class="p">:</span>
    <span class="n">subscribe</span><span class="p">:</span> <span class="c1"># Messaggi che il CLIENT riceve dal server</span>
      <span class="n">message</span><span class="p">:</span>
        <span class="n">payload</span><span class="p">:</span>
          <span class="nb">type</span><span class="p">:</span> <span class="n">string</span>
          <span class="n">description</span><span class="p">:</span> <span class="s2">&quot;Il risultato dell&#39;elaborazione di f1&quot;</span>
    <span class="n">publish</span><span class="p">:</span> <span class="c1"># Messaggi che il CLIENT può inviare al server</span>
      <span class="n">message</span><span class="p">:</span>
        <span class="n">payload</span><span class="p">:</span>
          <span class="nb">type</span><span class="p">:</span> <span class="nb">object</span>
          <span class="n">properties</span><span class="p">:</span>
            <span class="n">inputString</span><span class="p">:</span>
              <span class="nb">type</span><span class="p">:</span> <span class="n">string</span>
</pre></div>
</div>
<p>A partire da questo documento, è possibile:</p>
<ul class="simple">
<li><p><strong>Documentazione Automatica</strong>: Esistono tool che leggono il file AsyncAPI e generano una pagina web
(simile a Swagger UI) dove chiunque può vedere come interagire con il  sistema .</p></li>
<li><p><strong>Generazione del Codice</strong>: Dal file è possibile generare automaticamente le classi Java o i client JavaScript.
Invece di scrivere manualmente frasi del tipo <code class="docutils literal notranslate"><span class="pre">socket.send(...)</span></code>, le funzioni generate impediscono di
commettere errori.</p></li>
<li><p><strong>Validazione</strong>: Si può inserire nel server un “validatore” che controlla se i messaggi in arrivo
rispettano il contratto. Se un client invia un numero invece di una stringa, il sistema lo rifiuta automaticamente.</p></li>
</ul>
<p>Ad esempio, una volta scritto il contratto in <a href="#id6"><span class="problematic" id="id7">`AsyncAPI Studio`_</span></a> (editor visuale online), si potrebbe usare:</p>
<ul class="simple">
<li><p><a href="#id8"><span class="problematic" id="id9">`Modelina`_</span></a> per generare le classi Java dei messaggi.</p></li>
<li><p><a href="#id10"><span class="problematic" id="id11">`AsyncAPI Generator`_</span></a> per creare lo scheletro del client che i tuoi colleghi useranno.</p></li>
<li><p><a href="#id12"><span class="problematic" id="id13">`Microcks`_</span></a> per simulare il server mentre si scrive la logica reale in Javalin o Vert.x.</p></li>
</ul>
</section>
<section id="grpc">
<span id="id3"></span><h2>gRPC<a class="headerlink" href="#grpc" title="Permalink to this heading">¶</a></h2>
<p><strong>gRPC</strong> sta per <a href="#id14"><span class="problematic" id="id15">`gRPC Remote Procedure Call`_</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>la <strong>“g”</strong> non ha un significato fisso. Sebbene il framework sia stato creato originariamente da Google,
il significato della lettera cambia per ogni versione rilasciata.
Ad esempio, nella versione 1.1 significava “gentle”, nella 1.10 “glowing”, e così via.</p>
</div>
<p>gRPC è un’architettura e un sistema API open source governati dalla <em>Cloud Native Computing Foundation</em>.
È è un’implementazione specifica basata sul modello <strong>RPC</strong> (<em>Remote Procedure Call</em>).</p>
<p>Mentre in <em>REST</em> un client richiede o aggiorna i dati sul sistema-servizio,
in <em>gRPC</em>, il client chiama o invoca funzioni specifiche del server, visto come un altro componente software.</p>
<p>gRPC è stato progettato da Google specificamente per essere più efficiente di REST nella comunicazione
tra <span class="xref std std-ref">microservizi</span>.</p>
<ul class="simple">
<li><p>gRPC è progettato per far sì che un client possa invocare un metodo su un server remoto
come se fosse una chiamata a una funzione locale, scoendo un ‘contratto’ definito nel file <code class="docutils literal notranslate"><span class="pre">.proto</span></code>.</p></li>
<li><p>un server gRPC è solitamente stateless</p></li>
<li><p>REST usa JSON (testuale, pesante da leggere per le macchine).
gRPC usa <em>Protocol Buffers</em> (binario, molto più piccolo e veloce da processare).</p></li>
<li><p>gRPC usa <strong>HTTP/2</strong>, che permette di inviare più richieste contemporaneamente
sulla stessa connessione (multiplexing).</p></li>
<li><p>gRPC non è un sostituto totale di REST: È <strong>difficile da usare direttamente dal browser</strong> (richiede dei proxy).
Inoltre, essendo binario, non puoi “leggere” i messaggi semplicemente guardando
il traffico di rete senza strumenti appositi.</p></li>
<li><p>in architetture a m <span class="xref std std-ref">microservizi&lt;Microservices&gt;`icroservizi, se due servizi risiedono nello stesso processo,
la specifica può indicare un trasporto locale **In-Process**. Questo elimina l’overhead della rete e
della serializzazione, pur mantenendo l’interfaccia definita nel file di configurazione (`</span>.proto``).</p></li>
<li><p>gRPC ha come uso ideale: Comunicazione interna tra <span class="xref std std-ref">microservizi</span> (<strong>Backend-to-Backend</strong>).</p></li>
</ul>
<p>gRPC è estremamente efficiente per lo sviluppatore perché genera automaticamente il codice per il client
e per il server. Non occorre scrivere a mano  chiamate o gestire gli errori di parsing JSON:
il codice generato si comporta come se si stesse chiamando una funzione locale sul client.</p>
<section id="grpc-vs-oas">
<h3>gRPC vs. OAS<a class="headerlink" href="#grpc-vs-oas" title="Permalink to this heading">¶</a></h3>
<p>Il rapporto tra gRPC e OAS è un tema centrale nell’architettura moderna, poiché rappresenta l’incontro tra due mondi:
quello della comunicazione binaria ad alte prestazioni e quello della documentazione testuale standardizzata.</p>
</section>
<section id="code-first-vs-contract-first">
<h3>Code-First” vs “Contract-First<a class="headerlink" href="#code-first-vs-contract-first" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>OAS (REST)</strong>: Nasce per descrivere interfacce HTTP esistenti o per progettarne di nuove basate su verbi (GET, POST)
e risorse. È molto flessibile e orientato all’essere umano.
Molte implementazioni REST fatte con Spring Boot o ASP.NET Web API partono (<strong>Code-First</strong>)
da una classe in C# o Java, in cui si aggiungono dei metadati (es. &#64;Annotation);
un software scansiona il codice per produrre un file descrittivo (come <em>swagger.json</em>).</p></li>
<li><p><strong>gRPC (Protobuf)</strong>: Il contratto <code class="docutils literal notranslate"><span class="pre">.proto</span></code> non è solo una documentazione, ma è il codice stesso.
Dal file <em>.proto</em> si generano le classi e le funzioni da usere nel software.
È un approccio “Schema-First” o  <strong>Contract-First</strong> ((Il contratto prima di tutto)) per definizione.</p></li>
</ul>
<p>In generale si può dire che:</p>
<ul class="simple">
<li><p>il rapporto OAS/gRPC evideniza un punto fondamentale dell’ingegneria del software:
la distinzione tra interfaccia di superficie (contratto ‘passivo’ su cosa si può chiamare - endpoint, verbi, parametri) e
contratto funzionale (contratto “Vincolante”: Tipizzazione Forte, Gestione degli errori, …).</p></li>
<li><p>gRPC sposta il contratto dalla documentazione alla compilazione e
il contratto include aspetti inerenti alla <strong>logica della comunicazione</strong>
Client e Server usano lo stesso identico codice generato dal file <code class="docutils literal notranslate"><span class="pre">.proto</span></code>.
Se il contratto cambia, entrambi devono essere ricompilati.
È impossibile avere un client che “pensa” che l’API sia fatta in un modo mentre il server la implementa in un altro.
Dunque gRPC fa meglio se l’obiettivo è la correttezza del sistema: evita ambiguità, elimina gli errori di parsing
e garantisce che la dinamica tra i servizi sia coerente.</p></li>
<li><p>OAS fa meglio se l’obiettivo è l’accessibilità: chiunque, con un semplice browser o un comando <strong>curl</strong>,
deve poter interagire con la superficie del servizio senza dover scaricare compilatori o file di schema.
OAS rimane superiore anche per la scoperta (<strong>Discoverability</strong>) dei servizi</p></li>
</ul>
<p>Nelle architetture a <span class="xref std std-ref">microservizi</span>, <code class="docutils literal notranslate"><span class="pre">gRPC</span></code> e <code class="docutils literal notranslate"><span class="pre">OAS</span></code> convivono spesso secondo questo schema:</p>
<ul class="simple">
<li><p><strong>Front-End - Back-End</strong> (<code class="docutils literal notranslate"><span class="pre">OAS/REST</span></code>): Per la comunicazione verso il mondo esterno (browser, app mobile, partner esterni),
si usa OAS. È universale, facile da testare con un browser e attraversa facilmente i firewall.</p></li>
<li><p><strong>Back-End - Back-End</strong> (<code class="docutils literal notranslate"><span class="pre">gRPC</span></code>): Per la comunicazione interna tra i microservizi, si usa gRPC.
È molto più veloce, riduce il carico della CPU e garantisce che se un servizio cambia il suo “contratto”
(il file <code class="docutils literal notranslate"><span class="pre">.proto</span></code>), gli altri se ne accorgano in fase di compilazione.</p></li>
</ul>
<p>La comunità ha creato strumenti per trasformare l’uno nell’altro. Il più famoso è il <strong>gRPC-Gateway</strong>.
Si tratta di un plugin che i file .proto e genera automaticamente:</p>
<ul class="simple">
<li><p>Un server Reverse Proxy che accetta chiamate REST/JSON e le traduce in gRPC.</p></li>
<li><p>Un file OpenAPI che documenta quegli stessi endpoint.</p></li>
</ul>
<p>In questo modo, si può scrivere il  servizio  in gRPC e fornire agli utenti
una documentazione OAS standard per usare il servvio via HTTP.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">protobook</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">APIDescription</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#openapi-specification">OpenAPI Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#asyncapi">AsyncAPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grpc">gRPC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#grpc-vs-oas">gRPC vs. OAS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-first-vs-contract-first">Code-First” vs “Contract-First</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">protobook documentation</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, AN-ED.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/APIDescription.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>