
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Preludio &#8212; iss26 1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/custom.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Labiss2026 documentation" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Labiss2026 documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">iss26 1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Preludio</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="preludio">
<h1>Preludio<a class="headerlink" href="#preludio" title="Permalink to this heading">¶</a></h1>
<p>L’idea di <strong>Ingegneria</strong> pone enfasi sulla</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">costruzione</span> <span class="n">consapevole</span> <span class="n">e</span> <span class="n">motivata</span> <span class="n">di</span> <span class="n">artefatti</span> <span class="n">basata</span> <span class="n">su</span> <span class="n">analisi</span><span class="p">,</span> <span class="n">progettazione</span><span class="p">,</span>
<span class="n">sviluppo</span><span class="p">,</span>  <span class="n">distribuzione</span> <span class="n">e</span> <span class="n">manutenzione</span> <span class="n">di</span> <span class="n">prodotti</span>
</pre></div>
</div>
<p>Gli <em>ingegneri del software</em> sono abituati ad avvelersi di molti diversi strumenti per costruire
<a class="reference internal" href="#sistemi-software"><span class="std std-ref">Sistemi software</span></a>: linguaggi di programmazione, framework, librerie, ambienti di sviluppo, etc.</p>
<p>Oggi esiste un nuovo, potente strumento: le Chat basate su <em>Intelligenza Artificiale</em> (<strong>IA</strong>).</p>
<p>Sempre più spesso, le IA generative (come ChatGPT, Gemini, Claude, ecc.) vengono utilizzate per assistere
gli sviluppatori nel processo di scrittura del codice, nella generazione di documentazione e molto altro.</p>
<p>Ad esempio, posso chiedere a ChatGPT di generare un programma  che realizza il gioco
<a class="reference external" href="https://it.wikipedia.org/wiki/Gioco_della_vita">Conway Life</a>. A tal fine imposto il seguente <strong>prompt</strong>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&quot;Genera un programma che implementa il gioco di Conway Life.
 Il programma deve utilizzare una griglia 10x10 e visualizzare
 lo stato della griglia ad ogni iterazione.
 Includi commenti esplicativi nel codice.&quot;
</pre></div>
</div>
<ul class="simple">
<li><p>Il risultato di questa rochiesta a <strong>ChatGpt</strong> è un programma <em>Python</em> riportato in  <a class="reference external" href="https://github.com/anatali/protobook/blob/main/material/source/code/ConwayLife.py">ConwayLife.py</a>.</p>
</li>
</ul>
<p>Posso anche ottenere una versione in JavaScript, specificando questa rihiesta nel prompt. Il file <a class="reference external" href="https://github.com/anatali/protobook/blob/main/material/source/code/conway25JsGemini.js">conway25Gemini.js</a>.
riporta il risultato del codice generato da <strong>Gemini</strong>.</p>
<p>Modificando ulteriormente il prompt, è possibile generare programmi che eseguono il gioco in un browser web,
utilizzando <code class="docutils literal notranslate"><span class="pre">HTML5</span></code> e <a class="reference external" href="https://www.w3schools.com/html/html5_canvas.asp">canvas</a> per la visualizzazione grafica o che utilizzano librerie grafiche come <em>Pygame</em>
per una visualizzazione più avanzata in Python.</p>
<section id="c-e-ancora-possibilita-di-lavoro">
<h2>C’è ancora possibilità di lavoro?<a class="headerlink" href="#c-e-ancora-possibilita-di-lavoro" title="Permalink to this heading">¶</a></h2>
<p>E’ noto che quando una attività diventa riproducibile da una macchina, cessa di avere valore per gli
esseri umani e, automaticamente cessano di avere valore le persone che continuano a
svolgere quell’attività.</p>
<p>Dunque, la professione del costruttore di software rischia di essere messa in crisi.
Proviamo a chiedere alla IA ‘cosa ne pensa’:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&quot;L&#39;avvento della IA generativa potrebbe mettere in crisi la professione
 del programmatore di computer.
 Vorrei avere una panoramica delle ragioni che possono rendere meno probabile
 questo fenomeno  o, meglio, le attività nel campo della costruzione del software
 che possono ancora essere svolte in modo migliore da un essere umano&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Risponde Gemini</p>
<blockquote>
<div><p>È vero che l’avvento dellIA Generativa ha sollevato preoccupazioni sulla professione di programmatore.</p>
<p>Tuttavia, la maggior parte degli esperti concorda che l’IA sia destinata a diventare uno
strumento di potenziamento piuttosto che un sostituto completo, soprattutto nelle fasi
più critiche e astratte del ciclo di vita del software.</p>
<p>Ecco una panoramica delle attività in cui l’essere umano mantiene un vantaggio distintivo
e in cui è meno probabile che venga sostituito dall’IA.</p>
</div></blockquote>
<p><strong>Comprensione del Dominio e Astrazione</strong></p>
<p>L’IA generativa (come ChatGPT o Gemini o Copilot) eccelle nella <strong>traduzione sintattica</strong> (scrivere codice da istruzioni chiare), ma fallisce nella <strong>comprensione semantica</strong> profonda del dominio aziendale o scientifico.</p>
<ul class="simple">
<li><p><strong>Identificazione del Problema Reale:</strong> Un ingegnere del software umano è fondamentale per interagire con il cliente,
comprendere i requisiti ambigui, definire i <em>casi limite</em> (edge cases) e distinguere ciò che il cliente <em>vuole</em>
da ciò di cui il cliente <em>ha bisogno</em>. L’IA può scrivere codice per una funzione, ma non può ancora guidare una
riunione di <em>discovery</em> per definire i modelli di business.</p></li>
<li><p><strong>Architettura e Design a Livello Olistico</strong> : L’IA può generare codice per singoli componenti o <a class="reference external" href="https://en.wikipedia.org/wiki/Microservices">Microservizi</a>,
ma la creazione di un’<strong>architettura software</strong> coerente, scalabile, e che rispetti vincoli di costo e tempo
(<em>Design Patterns, Olarchia, Coreografia vs. Orchestrazione</em>) richiede un giudizio e una visione sistemica
che l’IA non possiede.</p></li>
</ul>
<p><strong>Gestione della Complessità e Integrazione</strong></p>
<p>I sistemi software reali sono raramente applicazioni <em>greenfield</em> (nuove da zero);
sono complessi intrecciati di sistemi legacy, API di terze parti e vincoli operativi.</p>
<ul class="simple">
<li><p><strong>Integrazione di Sistemi Legacy:</strong> Il codice generato dall’IA è spesso ottimale, ma si scontra
con la necessità di integrarsi con un codice legacy vecchio di 20 anni, spesso non documentato
e con <em>side effects</em> non ovvi. Solo un umano può <strong>decifrare e manutenere</strong> in modo
sicuro queste interfacce complesse.</p></li>
<li><p><strong>Debug di Sistemi Distribuiti:</strong> Identificare la causa radice di un <em>bug</em>
in un sistema distribuito (che coinvolge rete, database, latenza e interazioni asincrone)
richiede ragionamento causale e ipotesi basate su esperienza, non solo sul pattern matching del codice.</p></li>
</ul>
<p><strong>Fattore Umano ed Etica</strong></p>
<p>La programmazione non è solo un esercizio tecnico, ma un atto sociale, etico e di gestione del rischio.</p>
<ul class="simple">
<li><p><strong>Responsabilità Etica e Legale:</strong> Chi è responsabile se un codice generato dall’IA causa danni
(es. in un sistema finanziario o medico)? L’ingegnere umano mantiene la <strong>responsabilità finale</strong>
per la validazione, il test e l’implementazione sicura del codice.</p></li>
<li><p><strong>Leadership e Mentoring:</strong> L’IA non può gestire un team, mediare conflitti,
fare <em>mentoring- a sviluppatori junior</em>, o difendere una decisione tecnica davanti a stakeholder
non tecnici. Queste sono soft skills cruciali nella professione.</p></li>
</ul>
<p><strong>Attività Specifiche in cui l’Umano eccelle</strong></p>
<p>Ecco le aree dove il programmatore sposta il suo valore aggiunto:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Area di Attività</strong></p></td>
<td><p><strong>Ruolo Umano Distintivo</strong></p></td>
</tr>
<tr class="row-even"><td><p><em>Ingegneria dei Requisiti</em></p></td>
<td><p>Interazione diretta con gli utenti, conversione di necessità vaghe in specifiche
tecniche formali (definizione dell’obiettivo).</p></td>
</tr>
<tr class="row-odd"><td><p><em>Architettura Software</em></p></td>
<td><p>Selezione del paradigma (OOP, Funzionale, Olonico), progettazione di schemi di
database e definizione delle interfacce tra i macro-servizi.</p></td>
</tr>
<tr class="row-even"><td><p><em>Validazione e Test Strategico</em></p></td>
<td><p>Non solo scrivere unit test (che l’IA può fare),
ma definire <strong>scenari di test complessi</strong> e non banali, test di carico e strategie di <em>chaos engineering</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><em>Sicurezza e Hardening</em></p></td>
<td><p>Identificazione di vulnerabilità logiche e attacchi a livello di business.
L’IA può scrivere codice, ma un umano deve garantire la <strong>robustezza contro gli intenti malevoli</strong>.</p></td>
</tr>
<tr class="row-even"><td><p><em>Innovazione e Ricerca</em></p></td>
<td><p>L’IA è addestrata su dati esistenti (ciò che è stato fatto).
La creazione di <strong>nuovi algoritmi</strong>, paradigmi o linguaggi di programmazione per risolvere problemi non ancora risolti
sembra richiedere ancora creatività umana.</p></td>
</tr>
</tbody>
</table>
<p>In conclusione, l’IA Generativa solleverà il programmatore dai compiti di scrittura di
codice <em>boilerplate</em> e di <em>routine</em> (codifica), ma amplificherà la necessità di concentrarsi
sulla <strong>soluzione dei problemi</strong>, sulla <strong>gestione della complessità</strong> e sul <strong>giudizio etico-architetturale</strong>.</p>
<p>La professione non scompare, ma si <strong>eleva</strong> da programmatore a <strong>ingegnere del software di sistema</strong>.</p>
</div>
</section>
</section>
<section id="cosa-si-intende-per-sistema">
<h1>Cosa si intende per Sistema<a class="headerlink" href="#cosa-si-intende-per-sistema" title="Permalink to this heading">¶</a></h1>
<p>Il termine ‘Sistema’ deriva da una parola greca che significa “ciò che è posto insieme” o “un insieme organizzato”.</p>
<p>Non esiste una singola definizione formale universalmente accettata di <strong>“sistema”</strong> poichè
la parola evoca un concetto categoriale che assume significati diversi in fisica, ingegneria, biologia,
sociologia, informatica.</p>
<p>Un prima, possibile definizione ‘informale’ può essere:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Un sistema è un insieme di elementi interconnessi o interagenti,
organizzati in modo coerente per raggiungere un determinato scopo
(o per svolgere una funzione specifica).`
</pre></div>
</div>
<section id="descrivere-e-classificare">
<h2>Descrivere e classificare<a class="headerlink" href="#descrivere-e-classificare" title="Permalink to this heading">¶</a></h2>
<p>Descrivere significa <strong>selezionare e organizzare informazione</strong>
per rappresentare un oggetto o un sistema <strong>in modo utile</strong>, spesso <em>compattato</em>,
privilegiando <strong>relazioni e regole</strong> rispetto a elenchi e dettagli.</p>
<p>Una descrizione può assumere la forma di una <strong>classificazione</strong>, cioè:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>classificare = assegnare ogni elemento di un insieme
a una categoria, in base a criteri scelti.
</pre></div>
</div>
<p>Dobbiamo essere consapevoli che
ogni classificazione è <strong>costruita</strong>, e
dipende dagli <strong>scopi</strong> e dalla <strong>cultura</strong> dell’osservatore.
Non esistono categorie “naturali” e assolute:
<em>decidere cosa distinguere e aggregare</em> è sempre <strong>interpretazione</strong>.
Le categorie non “esistono” nelle cose. Le creiamo noi per raggiungere uno scopo.</p>
<p>Nel tentativo di comprendere il mondo, si è affermata una tassonomia molto diffusa che distingue
i sistemi in <em>semplici, complicati, complessi e caotici</em>.
Questa classificazione permette di riconoscere la <em>natura</em> di un sistema
e di scegliere gli strumenti più adatti per analizzarlo o progettarlo.</p>
<p>Questa tassonomia serve non tanto per incasellare i sistemi, quanto per:
guidare il modo in cui li <strong>modelliamo</strong>, quali strumenti formali utilizziamo
e quali aspettative abbiamo sul loro comportamento.</p>
<p>A ciascuna delle categorie possiamo far corrispondere una diversa classe di fenomeni
e diverse possibili azioni di governo.</p>
</section>
<section id="sistemi-semplici">
<span id="id12"></span><h2>Sistemi semplici<a class="headerlink" href="#sistemi-semplici" title="Permalink to this heading">¶</a></h2>
<p><strong>Caratteristica</strong>: comportamento prevedibile, descrivibile con poche regole lineari; facile da modellare e prevedere.</p>
<p>I sistemi semplici provocano fenomeni semplici. Il principio causa-effetto indica,
a partire dall’effetto, qual è la causa che lo determina.</p>
<p><strong>Azioni</strong>: Un’azione di intervento sul sistema consiste nell’applicare un protocollo risolutivo predefinito.
E’ il regno delle persone <strong>executive</strong> che applicanon <strong>Best Practices</strong>.
<em>Esempio</em>: hostess di un aereo.</p>
</section>
<section id="sistemi-complicati">
<span id="id13"></span><h2>Sistemi complicati<a class="headerlink" href="#sistemi-complicati" title="Permalink to this heading">¶</a></h2>
<p><strong>Caratteristica</strong>:  Molti elementi e molte relazioni, ma ingegnerizzabile— decomponibile, prevedibile;
molte possibili casue per un dato fenomeno.</p>
<p>Questi sistemi provocano fenomeni complicati, per i quali occorre studio e analisi.</p>
<p><strong>Azioni</strong>: Un’azione di intervento consiste nell’analizzare le possibili cause, pianificare l’intervento
risolutivo e realizzarlo.
Sono necessarie persone <strong>expert</strong> capaci di definire a priori
un modello di funzionamento, in base al quale pianificare l’intevento.
<em>Esempio</em>: pilota di un aereo a motore.</p>
</section>
<section id="sistemi-complessi">
<span id="id14"></span><h2>Sistemi complessi<a class="headerlink" href="#sistemi-complessi" title="Permalink to this heading">¶</a></h2>
<p><strong>Caratteristica</strong>:  Molti elementi, relazioni non lineari, adattamento, emergenza;
il comportamento non è predicibile solo dalle parti, ma <strong>emerge</strong> dalle interazioni.</p>
<section id="il-termine-emergenza">
<span id="emergenza"></span><h3>Il termine ‘emergenza’<a class="headerlink" href="#il-termine-emergenza" title="Permalink to this heading">¶</a></h3>
<p>Con il termine <strong>emergenza</strong> intenderemo sempre indicare l’idea di</p>
<p><strong>Affioramento/manifestazione di nuovi comportamenti o proprietà</strong> non riducibili alle proprità
o comportamenti di singoli componenti presi isolatamante.</p>
<p>Un sistema complesso non può essere ‘controllato’; può al massimo essere ‘perturbato’.</p>
<p><strong>Azioni</strong>:  Un’azione di intervento non può essere basata su un modello a-priori, ma richiede l’azione come
scelta/scommessa, apprendimento (degli effetti) e adattamento continuo (<strong>try and learn</strong>).
<em>Esempio</em>: pilota di un aliante.</p>
<p>E’ l’azione (<strong>agency</strong>) costruttiva a generare conoscenza. Quando non si conosce il
modello di comportamento di un fenomeno, <strong>agire</strong> significa sperimentare e questo
per gli esseri umani (dice il biologo <em>Stuart Kauffman</em>) significa generare nuovi artefatti e modelli
chiamando in causa competenze e approcci diversi, con una proliferazione di attività eterogenee.</p>
</section>
</section>
<section id="sistemi-caotici">
<span id="id15"></span><h2>Sistemi caotici<a class="headerlink" href="#sistemi-caotici" title="Permalink to this heading">¶</a></h2>
<p><strong>Caratteristica</strong>:  Estremamente sensibile alle condizioni iniziali (effetto farfalla);
può essere anche “semplice” dal punto di vista strutturale, ma
impossibile da prevedere a lungo termine.</p>
<p>Per i sistemi che provocano fenomeni caotici non c’è mai ripetizione di alcuna traiettoria
e non è possibile apprendimento.</p>
<p><strong>Azioni</strong>:  L’unica strategia è azione-adattamento continuo.
<em>Esempio</em>: pilota che cerca di atterrare in condizioni meteo avverse.</p>
<section id="macchine-agenti-organismi">
<h3>Macchine, agenti, organismi<a class="headerlink" href="#macchine-agenti-organismi" title="Permalink to this heading">¶</a></h3>
<p>Per un ingegnere (del software, ma non solo) è anche utile introdurre una ultriore distinazione/classificazione
tra sistemi, distinguendo tra <em>macchine, agenti, agenti intelligenti e organismi</em>.
Ma prima, premettiamo alcune puntualizzazioni:</p>
<ul class="simple">
<li><p><strong>Le categorie non sono necessariamente disgiunte né nette</strong>: un sistema può trovarsi “a metà” tra macchina e agente
oppure tra agente e agente intelligente, a seconda delle caratteristiche reali.</p></li>
<li><p><strong>Dipendenza dalla scala di osservazione</strong>: un “organismo” visto dall’esterno può mostrarsi come “molti agenti intelligenti”
o come “un agente intelligente”: la classificazione dipende da <strong>chi osserva</strong>, <strong>come osserva</strong>, e <strong>perché</strong>.</p></li>
<li><p><strong>Arbitrarietà e finalità</strong>: come per ogni classificazione, le categorie riflettono aspettative progettuali o analitiche:
cambiano se vogliamo modellare un software, un sistema biologico, un network sociale, un ecosistema.</p></li>
<li><p><strong>Pericolosità di antropomorfismi</strong>: attribuire “intelligenza”, “vita”, “autonomia” a sistemi software è
spesso metaforico: bisogna chiarire cosa intendiamo con quei termini, per evitare ambiguità o aspettative irrealistiche.</p></li>
</ul>
<section id="macchina">
<span id="id16"></span><h4>Macchina<a class="headerlink" href="#macchina" title="Permalink to this heading">¶</a></h4>
<p>Una macchina è un sistema chiuso, deterministico e creato artificialmente per raggiungere un obiettivo specifico.</p>
<p>Sistema fatto di parti che esistono l’una per l’altra.</p>
<p>Spesso non varia il proprio comportamento se non in modi predeterminati.</p>
<p>Le relazioni tra le parti sono lineari e l’analisi è di tipo scompositivo (riduzionistico).
La modifica di una macchina è di tipo reattivo (si aggiunge o toglie una parte)</p>
</section>
<section id="sistema-cibernetico">
<span id="id17"></span><h4>Sistema cibernetico<a class="headerlink" href="#sistema-cibernetico" title="Permalink to this heading">¶</a></h4>
<p>Un sistema cibernetico è un sistema che regola il proprio comportamento tramite meccanismi di controllo e retroazione (feedback),
adattandosi alle variazioni dell’ambiente per mantenere uno stato o conseguire uno scopo.</p>
<p>Il termine cibernetica deriva da una parola greca che significa “timoniere”, “colui che guida”.</p>
<p>Norbert Wiener (1894-1964), matematico statunitense, è considerato il padre della cibernetica.
Per Wiener, ciò che accomuna sistemi naturali e artificiali è la capacità di:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>percepire → confrontare → correggere
</pre></div>
</div>
<p>Il ciclo percezione → controllo → azione → percezione è l’essenza del sistema cibernetico,
che offre modelli generaleidi regolazione e controllo capaci di unificare
biologia, ingegneria, matematica, neuroscienze,
formalizzando il concetto di <strong>feedback</strong>.</p>
</section>
<section id="agente">
<span id="id18"></span><h4>Agente<a class="headerlink" href="#agente" title="Permalink to this heading">¶</a></h4>
<p>Sistema (hardware-software) che interagisce con un ambiente: percepisce input (sensori o messaggi),
produce output (attuatori o messaggi), ha un ciclo percezione - azione.</p>
<p>Opera in modo autonomo e prende decisioni senza essere controllato.</p>
<p>Ogni agente è un sistema cibernetico avanzato.
Non ogni sistema cibernetico è un agente.</p>
<p>L’idea di Russell &amp; Norvig è
che un agente sia un sistema che mappa percezioni in azioni per massimizzare una misura di performance.</p>
<p>Questa definizione generalizza l’idea cibernetica:
i sistemi di Wiener erano soprattutto regolatori;
gli agenti introducono scelte orientate al futuro.</p>
<p>Occorrono precise assunzioni:</p>
<ul>
<li><p>Esistenza di un <strong>ambiente con regolarità</strong>: se l’ambiente fosse completamente caotico
<em>nessuna strategia sarebbe possibile</em></p></li>
<li><p>Esistenza di <strong>obiettivi</strong> (<strong>telos</strong> Aristotelico) e metriche di successo: un agente senza obiettivo è una macchina.
Gli obiettivi possono esseere espliciti (goal logici), normativi,
funzioni di utilità nella Reinforcement Learning (RL)</p></li>
<li><p>Capacità di <strong>previsione</strong> e (spesso) <strong>modello del mondo</strong>:
<strong>modelli espliciti</strong> (mondo rappresentato → <a class="reference external" href="https://en.wikipedia.org/wiki/GOFAI">GOFAI</a> (<em>Good Old-Fashioned Artificial Intelligence</em>) ),
<strong>stimatori statistici</strong> (policy without model → <a class="reference external" href="https://en.wikipedia.org/wiki/Reinforcement_learning">RL</a> (<em>Reinforcement learning</em>)),
<strong>pattern reattivi</strong> (modello implicito → <a class="reference external" href="https://it.wikipedia.org/wiki/Stigmergia">Stigmergia</a>)</p>
<p>Il modello può essere <strong>interno o distribuito</strong>.
Nelle società di agenti l’ambiente stesso può essere <em>parte della memoria collettiva</em>.</p>
</li>
</ul>
</section>
<section id="agente-intelligente">
<span id="id19"></span><h4>Agente intelligente<a class="headerlink" href="#agente-intelligente" title="Permalink to this heading">¶</a></h4>
<p>Un agente dotato di capacità di decisione flessibile, adattamento, ragionamento o apprendimento:
cioè un sistema che, oltre a reagire, elabora conoscenza, valuta opzioni, può perseguire obiettivi.</p>
<p>Risulta efficace in una varietà di situazioni/ambienti.</p>
<p>Una defizione data da <strong>Albus</strong> nel 1991 è: agente capce di agire in modo appropriato in un abiente incerto
(ma regolare) dove le azioni appropriate sono quelle che aumentano la possibilià di successo.</p>
</section>
<section id="organismo">
<span id="id20"></span><h4>Organismo<a class="headerlink" href="#organismo" title="Permalink to this heading">¶</a></h4>
<p>Un organismo è un sistema aperto, dinamico che interagisce con l’ambiente e si adatta ad esso.</p>
<p>Sistema (vivente) le cui parti esistono anche l’una per mezzo dell’altra.</p>
<p>Esibisce <em>autopoiesi, omeostasi, adattamento evolutivo, autorganizzazione</em>:
un insieme di sottosistemi integrati, capace di mantenerne l’identità, di auto-regolarsi, di evolvere.</p>
<p>Le relazioni tra le parti sono non lineari, con feedback complessi e l’analisi è di tipo olistico
(si privilegia il tutto).</p>
<p>La modifica di una organismo è di tipo proattivo/evolutivo (si auto-organizza).</p>
</section>
</section>
</section>
<section id="come-si-descrive-un-sistema">
<span id="id21"></span><h2>Come si descrive un sistema<a class="headerlink" href="#come-si-descrive-un-sistema" title="Permalink to this heading">¶</a></h2>
<p>La descrizione di un sistema può essere affrontata da diverse prospettive: una visione interna
(analitica o <strong>WhiteBox</strong>  o <em>come è fatto</em>),
una visione esterna (o <strong>BlackBox</strong> o <em>come si usa</em>)
e una visione <strong>globale</strong> o <em>sistemica</em> per sistema complessi,
che descrive le proprietà ‘emergenti’.</p>
<section id="visione-blackbox">
<span id="id22"></span><h3>Visione BlackBox<a class="headerlink" href="#visione-blackbox" title="Permalink to this heading">¶</a></h3>
<p>La ‘visione’ dall’esterno di un sistema è lagata al modo con cui è possibile interagire
(scambiare informazione) con il sistema.</p>
<ul>
<li><p>La semantica Black Box di un <strong>sistema fisico</strong>  è la funzione matematica o l’equazione differenziale
che lega l’Input all’Output nel tempo.</p>
<p>Una funzione del tipo <code class="docutils literal notranslate"><span class="pre">O(t)</span> <span class="pre">=</span> <span class="pre">f(I(t))</span></code> definisce il
significato del sistema per l’osservatore.
Questo approccio è fondamentale per la Progettazione di <em>Sistemi di Controllo</em>, dove il controllore
(l’osservatore) deve interagire con la Black Box basandosi esclusivamente
sui segnali di ingresso e uscita per manipolare il suo comportamento.</p>
</li>
<li><p>La semantica Black Box di un <strong>sistema software</strong>, è legata all’output emesso dal sistema
sollecitato da un certo input; un osservatore del sistema non è interessato
quanti thread Java, quali protocolli di routing o quali algoritmi
il sistema utilizza internamente.</p>
<p>L’interazione è legata
al concetto di <strong>Interfaccia Pubblica</strong> del sistema
(ad esempio, le <a class="reference internal" href="#api"><span class="std std-ref">Le API</span></a> di un servizio, la <em>Interface</em> di un object, la <em>signature</em> di una funzione).
Questa interfaccia funge da contratto tra il sistema e il mondo esterno, stabilendo l’unico
modo permesso per scambiare informazioni.</p>
<p>L’atto di nascondere i dettagli implementativi ed esporre solo il comportamento essenziale è noto
come <strong>Astrazione</strong> o Occultamento dell’Informazione (<strong>Information Hiding</strong>).</p>
</li>
</ul>
</section>
<section id="visione-whitebox">
<span id="id23"></span><h3>Visione WhiteBox<a class="headerlink" href="#visione-whitebox" title="Permalink to this heading">¶</a></h3>
<p>Per descrivere un sistema ‘dall’interno’ occorrono <strong>almeno tre dimensioni</strong>:
la dimensione <strong>strutturale</strong>, la dimensione della <strong>interazione</strong> e la dimensione
del <strong>comportamento</strong> dei singoli componenti.</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 15%" />
<col style="width: 40%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Struttura</strong></p></td>
<td><p>Descrive la disposizione fisica o logica degli elementi; i nodi e i collegamenti.
Risponde a: Quanti sono? Come sono connessi?</p></td>
<td><p>Distingue tra sistemi semplici (poche connessioni) e sistemi complicati o complessi (molte connessioni).</p></td>
</tr>
<tr class="row-even"><td><p><strong>Comportamento</strong></p></td>
<td><p>Descrive Le regole interne e le capacità di elaborazione di ogni singolo elemento del sistema.
Risponde a: Cosa fa ogni parte?</p></td>
<td><p>Distingue i componenti rigidi/prevedibili da quelli autonomi/adattativi (essenziale per l’autoorganizzazione).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Interazione</strong></p></td>
<td><p>Descrive la natura, la forza e la frequenza degli scambi di informazione/energia tra i componenti.
Risponde a: Come si influenzano a vicenda?</p></td>
<td><p>Cruciale per distinguere complicato (interazioni lineari e fisse) da complesso (interazioni non lineari e dinamiche) e caotico (estrema sensibilità).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="dimensioni">
<span id="id24"></span><h3>Dimensioni<a class="headerlink" href="#dimensioni" title="Permalink to this heading">¶</a></h3>
<p>Un sistema software si può quindi pensare collocato in uno spazio concettuale a tre dimemsioni
specificato attraverso uno dei tanti
<a class="reference internal" href="#linguaggi-di-programmazione"><span class="std std-ref">Linguaggi di programmazione</span></a>:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>.</p>
<a class="reference internal image-reference" href="_images/Dimensioni.PNG"><img alt="_images/Dimensioni.PNG" class="align-center" src="_images/Dimensioni.PNG" style="width: 100%;" /></a>
</td>
<td><ul class="simple">
<li><p>l’organizzazione del sistema in parti (<strong>struttura</strong>);</p></li>
<li><p>il modo in cui le diverse parti scambiano informazione implicita o esplicita tra loro (<strong>interazione</strong>);</p></li>
<li><p>il funzionamento del tutto e di ogni singola parte (<strong>comportamento</strong>).</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="visione-sistemica">
<h3>Visione sistemica<a class="headerlink" href="#visione-sistemica" title="Permalink to this heading">¶</a></h3>
<p>Questo livello descrive le proprietà che appaiono solo quando il sistema viene visto nel suo insieme,
quali la resilienza, l’adattabilità, il grado di prevedibilità e le proprietà emergenti.</p>
<p>E’ un livello di descrizione tipico dei sistemi complessi, indipendente dal tipo di componente. Pone
il focus su pattern di interazione, topologie, coordinazione, flussi informativi.</p>
<section id="more-is-different">
<span id="id25"></span><h4>More is different<a class="headerlink" href="#more-is-different" title="Permalink to this heading">¶</a></h4>
<p>Quando un sistema cresce in dimensione, diventa diverso in natura.
<em>Philip W. Anderson</em> sintetizza gia nel 1972 questa idea con il celebre motto <strong>“More is different”</strong>.
L’aumento del numero di elementi porta all’emergere di proprietà globali non prevedibili analizzando
i singoli componenti.</p>
<p>Le proprietà di un insieme di molti elementi non sono riducibili alla somma delle proprietà dei singoli elementi.</p>
<p>Tali proprietà richiedono un diverso linguaggio descrittivo, focalizzato sulle interazioni
e sugli schemi collettivi, aprendo la strada a una visione sistemica del software.
Per sistemi complessi software — come gli ecosistemi di servizi distribuiti o gli insiemi massivi di attori —
questa visione è oggi indispensabile per comprendere e progettare comportamenti emergenti, robustezza e adattamento.</p>
<p>La frase di Anderson diventa anche un principio di progettazione:</p>
<p>Quando i componenti diventano molti, ciò che conta non è cosa fanno, ma come interagiscono</p>
</section>
</section>
</section>
<section id="perche-i-sistemi-complessi">
<h2>Perchè i sistemi complessi<a class="headerlink" href="#perche-i-sistemi-complessi" title="Permalink to this heading">¶</a></h2>
<p>Per un ingegnere del software è necessario avere consapevolezza di cosa sia un sistema complesso
perchè:</p>
<ul class="simple">
<li><p>i sistemi software moderni non sono solo più macchine gerarchiche e deterministiche:
sono ecosistemi di servizi, microservizi, agenti, attori, componenti autonomi.</p></li>
<li><p>il software moderno è quindi distribuito, eterogeneo, autonomo, adattivo, connesso in rete:
cioè possiede molte delle proprietà osservate nei sistemi complessi naturali.</p></li>
</ul>
<p>Mentre il ‘pensiero sistemico’ iniziò la sua ascesa negli anni Venti del secolo scoro,
la scienza ha cominciato a parlare esplicitamente e a fondo di “sistemi complessi” con le teorie di <em>Prigogine</em>
(anni Settanta)
e con l’emergere della matematica non lineare (caos, frattali, dinamica dei sistemi,
formalizzata dagli anni Ottanta in poi), portando alla nascita della <strong>Scienza della Complessità</strong> negli anni Novanta.</p>
<p>Si può usare la metafora di una montagna: per molti anni la scienza ha concentrato l’attenzione sulla “<strong>fisica dell’ordine</strong>”
(sistemi semplici) e sulla “<strong>fisica del disordine</strong>” (sistemi con moltissime variabili non correlate),
lasciando la “complessità organica” (la vetta del monte) in gran parte inesplorata fino alla fine del <code class="docutils literal notranslate"><span class="pre">XX</span></code> secolo.</p>
<p>La possibilità di <em>scalare la vetta della complessità</em> si è aperta con l’avvento dei computer e delle nuove
tecniche matematiche, che hanno permesso di esplorare la “scala mesoscopica” dei fenomeni biologici e sociali.</p>
<p>Alcuni tratti ricorrenti in questo nuovo campo disciplinare sono riassunti nella tabella che segue:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tratto distintivo</p></th>
<th class="head"><p>Significato</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Molte entità interagenti</p></td>
<td><p>Un sistema è composto da un gran numero di componenti autonomi che agiscono localmente.</p>
<p><strong>Esempi:</strong> Formicai, reti di microservizi, reti neurali biologiche o artificiali.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Interazioni non lineari</p></td>
<td><p>Le interazioni non si sommano in modo proporzionale: piccole cause possono produrre grandi effetti e viceversa.</p>
<p><strong>Esempi:</strong> Mappa logistica, epidemie, amplificazione in reti sociali.</p>
</td>
</tr>
<tr class="row-even"><td><p>Retroazioni (feedback)</p></td>
<td><p>Gli effetti delle azioni dei componenti ritornano a influenzarli, creando cicli di amplificazione o stabilizzazione.</p>
<p><strong>Esempi:</strong> Controllo ormonale, circuiti di feedback nei sistemi autonomi e nei sistemi ecologici.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Auto-organizzazione</p></td>
<td><p>L’ordine globale emerge spontaneamente dalle interazioni locali, senza un controllo centralizzato.</p>
<p><strong>Esempi:</strong> Sincronizzazione delle lucciole, flocking degli uccelli, clustering spontaneo in robotica swarm.</p>
</td>
</tr>
<tr class="row-even"><td><p>Transizioni ordine/disordine</p></td>
<td><p>Il sistema può passare bruscamente da stati stabili a stati caotici o viceversa, spesso in corrispondenza di soglie critiche.</p>
<p><strong>Esempi:</strong> Transizioni di fase nella materia, collasso di reti infrastrutturali, criticalità auto-organizzata.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Emergenza di pattern globali</p></td>
<td><p>Comportamenti collettivi non prevedibili dalle singole parti, ma derivanti dalle loro interazioni.</p>
<p><strong>Esempi:</strong> Pattern del Game of Life, onde di traffico, comportamenti collettivi nei social network.</p>
</td>
</tr>
</tbody>
</table>
<p>Inoltre:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tratto distintivo</p></th>
<th class="head"><p>Significato</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Adattamento</p></td>
<td><p>Il sistema modifica la propria struttura o comportamento in risposta all’ambiente o a pressioni interne.</p>
<p><strong>Esempi:</strong> Algoritmi genetici, ecosistemi, sistemi software self-adaptive.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Sensibilità alla topologia delle interazioni</p></td>
<td><p>La forma della rete di connessioni influisce profondamente sulla dinamica del sistema.</p>
<p><strong>Esempi:</strong> Reti small-world (diffusione rapida), reti scale-free (robuste ma fragili ai nodi-hub), reti multilivello.</p>
</td>
</tr>
<tr class="row-even"><td><p>Dinamiche collettive lontane dall’equilibrio</p></td>
<td><p>Il sistema opera in condizioni non stazionarie, mantenute da flussi costanti di energia, materia o informazione.</p>
<p><strong>Esempi:</strong> Reazioni chimiche oscillanti (Belousov–Zhabotinsky), mercati finanziari, sistemi distribuiti event-driven.</p>
</td>
</tr>
</tbody>
</table>
<section id="la-sinergetica">
<h3>La sinergetica<a class="headerlink" href="#la-sinergetica" title="Permalink to this heading">¶</a></h3>
<p>Una delle cornici interpretative fondamentali per comprendere la natura dei sistemi complessi
è la <a class="reference external" href="https://en.wikipedia.org/wiki/Synergetics_(Haken)">sinergetica</a>, introdotta da <strong>Hermann Haken</strong>, l’invetore del <em>Laser</em>.</p>
<p>La sinergetica descrive come l’auto-organizzazione emerga tramite parametri d’ordine,
modi instabili e il principio di asservimento, secondo cui il comportamento collettivo domina
e coordina quello dei singoli componenti.
E’ uno dei “ponti” più eleganti tra:</p>
<ul class="simple">
<li><p>fenomeni fisici quali: auto-organizzazione, emergenza, dinamiche collettive, transizioni ordine/disordine,
asservimento</p></li>
</ul>
<p>e</p>
<blockquote>
<div><ul class="simple">
<li><p>l’ingegneria di sistemi autonomi e distribuiti, in cui un insieme di microservizi o attori autonomi
può generare spontaneamente <em>parametri d’ordine</em> quali sincronizzazione, consenso, oscillazioni, propagazioni,
<em>asservimento</em> tramite orchestrazione e coreografia, <em>transizioni critiche</em> collegabili
alla resilienza dei microservizi, ai circuit breakers, alle cascading failures, alle reti scale-free.</p></li>
</ul>
</div></blockquote>
<p>Il video: <a class="reference external" href="https://www.youtube.com/watch?v=p4jwj8IJjNg">Il Sorprendente Segreto della Sincronizzazione</a> fornisce una panoramica di alcuni
interessanti (e fondamentali) fenomeni di sincornizzazione naturale.
Se ne consiglia vivamente la visione.</p>
</section>
<section id="id26">
<h3>Teoria delle reti<a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h3>
<p>Un modo ritenuto efficace per descrivere sistemi (complessi) e la loro dimensione
globale/emergente è ricorrere ai modelli di rete (o teoria dei grafi).</p>
<section id="griglie-e-grafi">
<h4>Griglie e grafi<a class="headerlink" href="#griglie-e-grafi" title="Permalink to this heading">¶</a></h4>
<p>Una <strong>griglia</strong>, o reticolo regolare (lattice), è un tipo specifico di grafo caratterizzato da una
topologia altamente regolare e locale.:</p>
<ul class="simple">
<li><p>ogni nodo è collegato allo stesso numero fisso di vicini (es. <code class="docutils literal notranslate"><span class="pre">4</span></code> in una griglia <code class="docutils literal notranslate"><span class="pre">2D</span></code>, <code class="docutils literal notranslate"><span class="pre">6</span></code> in una 3D)</p></li>
<li><p>l’informazione si diffonde lentamente e in modo prevedibile</p></li>
<li><p>non mostrano un’emergenza forte o un comportamento a “piccolo mondo”;
descrivono sistemi complicati o al massimo semplici-complessi.</p></li>
</ul>
<p>Un <strong>grafo</strong> generico non ha restrizioni sulla sua topologia</p>
<ul class="simple">
<li><p>il numero di connessioni per nodo varia enormemente</p></li>
<li><p>possono esistere “salti” o hub che collegano nodi lontani</p></li>
<li><p>descrivono sistemi complessi e autoorganizzati.
Mostrano emergenza, resilienza e vulnerabilità (dipendente dalla topologia).</p></li>
</ul>
<p>La teoria delle reti basata su grafi è la <strong>grammatica formale della complessità</strong>, e permette di spostare la discussione
dalla specificità dei componenti (Java, router, gene) alla topologia che determina il comportamento globale
(complesso, autoorganizzato, caotico).</p>
<p>Ad esempio, modelli che descrivono come l’organizzazione (l’ordine) emerge in reti complesse sono:</p>
<ol class="arabic simple">
<li><p><strong>Reti Casuali</strong> (<em>Erdős-Rényi</em>)</p></li>
</ol>
<blockquote>
<div><p>Queste reti servono da base di confronto. Le connessioni sono disposte in modo puramente casuale.</p>
<ul class="simple">
<li><p><strong>Limitazione</strong>: Non descrivono adeguatamente la maggior parte dei sistemi reali
(Internet, reti biologiche, reti sociali) che hanno strutture molto più organizzate.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><strong>Reti a Piccolo Mondo</strong> (<em>Watts e Strogatz</em>)</p></li>
</ol>
<blockquote>
<div><p>Le <a class="reference external" href="https://en.wikipedia.org/wiki/Small-world_network">Small world network</a> hanno un alto coefficiente di clustering (i miei amici sono amici tra loro,
come nelle reti sociali) ma anche una corta distanza media tra i nodi
(di veda la proprietà dei <a class="reference external" href="https://it.wikipedia.org/wiki/Sei_gradi_di_separazione">sei gradi di sperazione</a>).</p>
<ul class="simple">
<li><p><strong>Significato</strong>: Favoriscono la diffusione efficiente dell’informazione o delle malattie.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p><strong>Reti Scale-Free</strong> (<em>Barabási-Albert</em>)</p></li>
</ol>
<blockquote>
<div><p>Questo è il modello che meglio descrive Internet e molte reti biologiche.</p>
<ul class="simple">
<li><p><strong>Caratteristica</strong>: La distribuzione dei gradi dei nodi segue una <strong>legge di potenza</strong> (<a class="reference external" href="https://it.wikipedia.org/wiki/Legge_di_potenza">powerlaw</a>).
Ci sono pochissimi nodi con un numero estremamente elevato di collegamenti (gli hub)
e molti nodi con pochissimi collegamenti.</p></li>
<li><p><strong>Meccanismo</strong>: Nascono da un meccanismo di <strong>preferential attachment</strong>
(<em>effetto San Matteo</em>: “i ricchi diventano più ricchi”).</p></li>
<li><p>Proprietà Emergenti:</p>
<ul>
<li><p><strong>Robustezza</strong>: La rete è estremamente resistente al fallimento casuale dei nodi
(perché la maggior parte dei nodi non sono hub).</p></li>
<li><p><strong>Vulnerabilità</strong>: È estremamente vulnerabile a un attacco mirato contro gli hub.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</section>
</section>
</section>
<section id="verso-i-sistemi-software">
<h2>Verso i sistemi software<a class="headerlink" href="#verso-i-sistemi-software" title="Permalink to this heading">¶</a></h2>
<p>La citata progressiva evoluzione dei sistemi software verso
ecosistemi costituiti da molteplici componenti autonomi che possono presentare
proprietà simili a quelle dei sistemi naturali, non invalida il fatto
che il software nasce in relazione alla costruzione di macchine universali
capaci di ‘computare’.</p>
<p>Ciò che si modifica è il <strong>concetto stesso di ‘computazione’</strong> e a questo tema
verrà dedicato il capitolo successivo.</p>
</section>
</section>
<section id="cosa-vuol-dire-computare">
<h1>Cosa vuol dire computare<a class="headerlink" href="#cosa-vuol-dire-computare" title="Permalink to this heading">¶</a></h1>
<p><strong>Per descrivere qualcosa occorre un linguaggio.</strong></p>
<p>La necessità di modellare l’imprevedibile e l’emergente ha richiesto, nel caso dei sistemi
fisici,  nuovi strumenti matematici e, nel caso dei sistemi software, nuovi paradigmi computazionali.</p>
<p>Per i <strong>sistemi fisici</strong>, la <em>nuova matematica</em> è basata su dinamica non lineare (attrattori, biforcazioni, caos),
automi cellulari e sistemi discreti, teoria dei frattali, teoria delle reti complesse,
sinergetica.
Questi formalismi non sostituiscono la matematica classica, ma la estendono e la rendono applicabile
a fenomeni emergenti con molti gradi di libertà.</p>
<p>In modo analogo, per i <strong>sistemi software</strong>
l’approccio  classico alla progettazione e costruzione di sistemi
(<a class="reference internal" href="#paradigma-orientato-agli-oggetti-oop"><span class="std std-ref">OOP</span></a> + <a class="reference internal" href="#uml"><span class="std std-ref">UML</span></a> + programmazione sequenziale/imperativa)
risulta insufficiente per affrontare problemi in cui vi sono molti componenti che operano
come enti autonomi che interagiscono scambiandosi messaggi, in assenza di memoria comune.</p>
<p>Al concetto di <strong>oggetto</strong> come tipico componente-base per  molti linguaggi general purpose (<strong>GPL</strong>)
<strong>occorre affiancare</strong> oggi concetti quali  <strong>attore</strong> e <strong>agente</strong> come enti autonomi che interagiscono a messaggi.
Questi concetti permettono di ‘disgregare’ le tradizionali <strong>architetture monolitiche</strong> dei sistemi a favore
di archietture distribuite, quali quelle, oggi molto diffuse,  basate su
<strong>microservizi</strong>.</p>
<section id="il-motto-di-alan-kay">
<span id="id27"></span><h2>Il motto di Alan Kay<a class="headerlink" href="#il-motto-di-alan-kay" title="Permalink to this heading">¶</a></h2>
<p>Come ingegneri del software, è ncessario capire i dettagli e le motivazioni della continua evoluzione
dei linguaggi di programmazione, assumendo il quadro concettuale di riferimento enfatizzato da <a class="reference external" href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a>
(il promotore del linguaggio <strong>Smalltalk</strong>, uno dei progenitori della <em>OOP</em>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Un</span> <span class="n">linguaggio</span> <span class="n">di</span> <span class="n">programmazione</span> <span class="n">è</span> <span class="n">come</span> <span class="n">ali</span> <span class="n">per</span> <span class="n">i</span> <span class="n">nostri</span> <span class="n">pensieri</span><span class="p">,</span>
<span class="n">ma</span> <span class="n">è</span> <span class="n">anche</span> <span class="n">le</span> <span class="n">catene</span> <span class="n">che</span> <span class="n">non</span> <span class="n">ci</span> <span class="n">permettono</span>  <span class="n">di</span> <span class="n">volare</span> <span class="n">più</span> <span class="ow">in</span> <span class="n">alto</span><span class="o">.</span>
</pre></div>
</div>
<p>Questo riassume l’idea che i linguaggi (di programmazione, ma non solo) ci consentono di <strong>esprimere concetti</strong> che altrimenti
sarebbero inesprimibili (le <strong>ali</strong>), ma le loro limitazioni intrinseche (la loro sintassi/semantica) possono
impedirci (le <strong>catene</strong>) di concepire soluzioni più radicali o potenti .</p>
</section>
<section id="dai-modelli-ai-linguaggi">
<h2>Dai modelli ai linguaggi<a class="headerlink" href="#dai-modelli-ai-linguaggi" title="Permalink to this heading">¶</a></h2>
<p>L’evoluzione dei linguaggi di programmazione (<code class="docutils literal notranslate"><span class="pre">LdP</span></code>) si fonda  su una lunga storia di idee matematiche
che hanno cercato di definire in modo preciso che cosa significhi <strong>calcolare</strong>.
Prima ancora che il software esistesse come disciplina autonoma, matematici, logici e filosofi
si trovarono di fronte a un quesito fondamentale:
<strong>esiste un limite intrinseco a ciò che una procedura meccanica può fare?</strong></p>
<p>La risposta a questa domanda richiedeva di esplicitare che cosa fosse, esattamente,
una “procedura meccanica”. Ovvero: un <strong>modello formale</strong> del calcolo.</p>
<p>È in questo contesto che nasce, negli <strong>anni ‘30</strong> del Novecento, la <strong>Macchina di Turing</strong>
(proposta da <a class="reference external" href="https://it.wikipedia.org/wiki/Alan_Turing">Alan M. Turing</a>),
insieme ad altri formalismi equivalenti proposti quasi in parallelo:</p>
<ul class="simple">
<li><p>il <span class="math notranslate nohighlight">\(\lambda\)</span> <strong>calcolo</strong> di Alonzo Church,</p></li>
<li><p>le <strong>funzioni ricorsive</strong> di Gödel, Herbrand e Kleene,</p></li>
<li><p>i <strong>sistemi di riscrittura</strong> di Post e Markov.</p></li>
</ul>
<p>Pur diversi nella forma, questi modelli condividono una sorprendente convergenza:
definiscono tutti la stessa classe di funzioni calcolabili. Da qui il <strong>teorema di Church-Turing</strong>
e la tesi filosofica omonima: tutte le nozioni ragionevoli di “calcolo effettivo” coincidono.</p>
<p>Questa prima stagione dei formalismi nasce dunque <strong>prima dei linguaggi di programmazione</strong>,
e non per scopi ingegneristici, ma <strong>per rispondere a domande di logica matematica e fondamenti</strong>:
cosa può essere calcolato? cosa non può esserlo? cosa significa <em>“algoritmo”</em>?</p>
<p>I primi linguaggi di programmazione, come <code class="docutils literal notranslate"><span class="pre">Fortran</span></code>, <code class="docutils literal notranslate"><span class="pre">Lisp</span></code>, <code class="docutils literal notranslate"><span class="pre">Algol</span></code>, arriveranno <em>dopo</em>,
come reinterpretazione pragmatica dei formalismi astratti.
In alcuni casi (come <code class="docutils literal notranslate"><span class="pre">Lisp</span></code>) il riferimento alla teoria è diretto;
in altri (come <code class="docutils literal notranslate"><span class="pre">C</span></code> o <code class="docutils literal notranslate"><span class="pre">Java</span></code>) è implicito.</p>
</section>
<section id="macchine-astratte">
<h2>Macchine astratte<a class="headerlink" href="#macchine-astratte" title="Permalink to this heading">¶</a></h2>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Spesso si qualifica il comportamento di un componente facendo riferimento a tipi diversi di
<cite>macchine astratte</cite>, iniziando dalla
<a class="reference external" href="https://plato.stanford.edu/entries/turing-machine/">Turing Machine</a> (<strong>TM</strong>), che individua, in stile imperativo, le mosse-base (<em>primitive</em>)
di un automa che permette di <span class="remark">realizzare qualunque calcolo</span> (!).</p></td>
<td><p>.</p>
<a class="reference internal image-reference" href="_images/TuringMachine.PNG"><img alt="_images/TuringMachine.PNG" class="align-center" src="_images/TuringMachine.PNG" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Un tipo meno potente di macchina astratta rispetto alla <strong>TM</strong> è il <a class="reference external" href="https://it.wikipedia.org/wiki/Automa_a_pila">pushdown automaton</a> (<strong>PDA</strong>) che però è l’automa
di riferimento per il riconoscimento delle frasi di un inguaggio con <em>sintassi context-free</em>, di tipo 2 nella
<a class="reference external" href="https://it.wikipedia.org/wiki/Gerarchia_di_Chomsky">gerarchia di Chomsky</a> , che introdurremo nella sezione <a class="reference internal" href="#macchine-astratte-per-riconoscere-linguaggi"><span class="std std-ref">Macchine astratte per riconoscere linguaggi</span></a>.</p>
</section>
<section id="la-macchina-di-minsky">
<h2>La Macchina di Minsky<a class="headerlink" href="#la-macchina-di-minsky" title="Permalink to this heading">¶</a></h2>
<p>La macchina di Turing (TM) definisce un insiene di mosse con riferimento a un nastro e una testina.
Una classe di macchine astratte che si dimostrano equivalente alla TM è quella
delle macchine a registro o <a class="reference external" href="https://en.wikipedia.org/wiki/Counter_machine">Counter machine</a>.
Una macchina di questa classe possiede un numero finito (<code class="docutils literal notranslate"><span class="pre">N</span></code>) di registri (contatori)
(chiamati <code class="docutils literal notranslate"><span class="pre">R_1,</span> <span class="pre">R_2,...,</span> <span class="pre">R_N</span></code>).</p>
<p>La <em>Macchina di Minsky</em> è stata proposta da
<a class="reference external" href="https://en.wikipedia.org/wiki/Marvin_Minsky">Marvin Minsky</a> nel <strong>1961</strong>, dimostrando
soli due registri (<code class="docutils literal notranslate"><span class="pre">N=2</span></code>) bastano per
simulare qualsiasi TM (e quindi eseguire qualsiasi algoritmo).</p>
<p>La <em>Macchina di Minsky</em> è caratterizzata da solo due tipi di istruzioni:</p>
<blockquote>
<div><table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>INC(R_i, j)</strong></p></td>
<td><p>Incrementa il registro <code class="docutils literal notranslate"><span class="pre">R_i</span> <span class="pre">di</span> <span class="pre">1.</span> <span class="pre">Salta</span> <span class="pre">all'istruzione</span> <span class="pre">j</span></code>. (Senza condizione)</p></td>
</tr>
<tr class="row-even"><td><p><strong>DEC_JUMP(R_i, j, k)</strong></p></td>
<td><p>Se il registro <code class="docutils literal notranslate"><span class="pre">R_i</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">decrementalo</span> <span class="pre">di</span> <span class="pre">1</span> <span class="pre">e</span> <span class="pre">salta</span> <span class="pre">all'istruzione</span> <span class="pre">j</span></code>.
Altrimenti (se <code class="docutils literal notranslate"><span class="pre">R_i</span> <span class="pre">=</span> <span class="pre">0</span></code>), salta all’istruzione <code class="docutils literal notranslate"><span class="pre">k</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Notiamo come questo modo di esprimere le operazioni elementari che stanno alla base del calcolo
è più vicina alla nostra idea di computer come macchina capace di eseguire un insieme di
mosse elementari, funzionando come <strong>interprete</strong> del <a class="reference external" href="https://it.wikipedia.org/wiki/Linguaggio_assembly">Linguaggio assembly</a>.</p>
</section>
<section id="problemi-non-riducibili-indecidibili">
<h2>Problemi non riducibili (Indecidibili)<a class="headerlink" href="#problemi-non-riducibili-indecidibili" title="Permalink to this heading">¶</a></h2>
<p>Vi sono problemi per cui è stato dimostrato che una TM (o formulazioni equivalenti) <strong>non</strong>
può produrre una risposta in un tempo finito. Tra i più noti di questi ricordiamo:</p>
<ul class="simple">
<li><p>Il Problema dell’Arresto (<strong>Halting Problem</strong>):
Data una descrizione di un programma (o TM) e il suo input, esisterà un algoritmo in grado di
determinare se quel programma terminerà (si arresterà) o continuerà a funzionare indefinitamente
(loop infinito)?</p></li>
<li><p>Il Problema della Decidibilità (<strong>Entscheidungsproblem</strong>):
Esiste un algoritmo che possa decidere, data una proposizione logica espressa nella logica del primo ordine,
se quella proposizione è universalmente valida (vera in ogni modello)?</p></li>
<li><p>Equivalenza dei Linguaggi Liberi dal Contesto (<strong>CFG Equivalence</strong>):
Date due grammatiche libere dal contesto (CFG), generano esattamente lo stesso linguaggio?</p></li>
</ul>
<p>L’<em>Entscheidungsproblem</em> fu posto da <a class="reference external" href="https://it.wikipedia.org/wiki/David_Hilbert">David Hilbert</a> nel <code class="docutils literal notranslate"><span class="pre">1928</span></code>. Sotto la guida di <em>Hilbert</em>,
<a class="reference external" href="https://it.wikipedia.org/wiki/John_von_Neumann">John von Neumann</a>, nei suoi anni giovanili, si fece portabandiera dell’approccio assiomatico della matematica,
riconoscendo subito il valore dei contributi di   <a class="reference external" href="https://it.wikipedia.org/wiki/Kurt_G%C3%B6del">Kurt Gödel</a> (Teoremi di incompletezza )
che evidenziarono l’impossibilità di conseguire una dimostrazione completa della coerenza
dell’aritmetica nel contesto del pensiero matematico.</p>
<p>L’indecidibilità di un problema <code class="docutils literal notranslate"><span class="pre">P_2</span></code> viene di solito dimostrata riducendolo a un problema <code class="docutils literal notranslate"><span class="pre">P_1</span></code>
che è già noto come indecidibile.</p>
<p>La maggior parte delle prove di indecidibilità nel campo dei linguaggi di programmazione o
delle proprietà dei programmi fa riferimento a un potente strumento formale basato sul concetto di riduzione:
il <a class="reference external" href="https://it.wikipedia.org/wiki/Teorema_di_Rice">Teorema di Rice</a>.</p>
<section id="il-teorema-di-rice">
<h3>Il Teorema di Rice<a class="headerlink" href="#il-teorema-di-rice" title="Permalink to this heading">¶</a></h3>
<p>Il Teorema afferma che:</p>
<p>Qualsiasi proprietà <em>non banale</em> sul linguaggio (o sulla funzione) calcolato da una
Macchina di Turing è indecidibile.</p>
<ul class="simple">
<li><p><strong>Proprietà</strong>: Una caratteristica che un programma può avere
(es. “termina sempre”, “stampa sempre 10 numeri”, “non entra mai in loop”).</p></li>
<li><p><strong>Non banale</strong>: Una proprietà che non è posseduta da tutti i programmi né da nessun programma.
(Ad esempio, “essere un programma” è banale; “essere un programma che calcola <span class="math notranslate nohighlight">\(\pi\)</span> è non banale).</p></li>
</ul>
<p>Esempio: Vogliamo dimostrare che decidere se un programma <code class="docutils literal notranslate"><span class="pre">C++</span></code> stamperà “Hello World” è indecidibile.</p>
<p>Definiamo la proprietà <code class="docutils literal notranslate"><span class="pre">P</span></code>: “Il programma stampa ‘Hello World’.
<code class="docutils literal notranslate"><span class="pre">P</span></code> è non banale (esiste un programma che lo fa, e uno che non lo fa).
Per il Teorema di Rice, la decisione se un dato programma possiede la proprietà <code class="docutils literal notranslate"><span class="pre">P</span></code> è indecidibile.
Non si può costruire un algoritmo generale per questo.</p>
</section>
</section>
<section id="cosa-significa-costruire">
<h2>Cosa significa ‘costruire’<a class="headerlink" href="#cosa-significa-costruire" title="Permalink to this heading">¶</a></h2>
<p>Dunque, i formalismi servono non solo per costruire, ma anche per <strong>sapere cosa possiamo o non possiamo ottenere</strong>:</p>
<p>Questi limiti sono fondamentali per gli ingegneri: <strong>modellano il territorio</strong> in cui è possibile progettare.</p>
<p>Sulla base dei concetti introdotti, possiamo cercare di catturare meglio il significato del temine <em>‘costruire’</em>
nell’ambito del software:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Costruire</span> <span class="n">significa</span> <span class="n">combinare</span> <span class="n">elementi</span> <span class="n">di</span> <span class="n">base</span> <span class="n">secondo</span> <span class="n">regole</span> <span class="n">definite</span>
<span class="n">per</span> <span class="n">ottenere</span> <span class="n">nuove</span> <span class="n">entità</span> <span class="n">o</span> <span class="n">comportamenti</span><span class="o">.</span>
<span class="n">Quando</span> <span class="n">queste</span> <span class="n">combinazioni</span> <span class="n">sono</span> <span class="n">lineari</span><span class="p">,</span> <span class="n">otteniamo</span> <span class="n">strutture</span> <span class="n">prevedibili</span><span class="o">.</span>
<span class="n">Quando</span> <span class="n">invece</span> <span class="n">le</span> <span class="n">interazioni</span> <span class="n">tra</span> <span class="n">componenti</span> <span class="n">generano</span> <span class="n">proprietà</span> <span class="n">non</span> <span class="n">deducibili</span>
<span class="n">dai</span> <span class="n">singoli</span><span class="p">,</span> <span class="n">la</span> <span class="n">costruzione</span> <span class="n">diventa</span> <span class="n">sorgente</span> <span class="n">di</span> <span class="n">complessità</span> <span class="n">ed</span> <span class="n">emergenza</span><span class="o">.</span>
</pre></div>
</div>
<p>Notiamo che gli elementi-base nella costruzione di sistemi software sono le istruzioni interpretabili
da un computer, che, per la <em>tesi di Church Turing</em>, definiscono anche di fatto ciò che è ‘costruibile’
mediante il software.</p>
<section id="computazionalmente-completo">
<span id="id28"></span><h3>Computazionalmente completo<a class="headerlink" href="#computazionalmente-completo" title="Permalink to this heading">¶</a></h3>
<p>In informatica teorica si usa spesso il concetto di <strong>Turing completezza</strong>:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Un linguaggio è Turing-completo (<em>Computazionalmente completo</em>) se può simulare qualsiasi macchina di Turing.</p>
</div>
<p>Questo significa che:</p>
<ul class="simple">
<li><p>può <strong>leggere</strong> e <strong>scrivere</strong> memoria arbitraria</p></li>
<li><p>può eseguire <strong>controllo del flusso</strong> (cicli, ramificazioni, ricorsione)</p></li>
<li><p>può comporre operazioni in modo <strong>illimitato</strong></p></li>
</ul>
<p>I GPL conservano queste proproetà anche quando offrono la capacità di
costruire sistemi basati su componenti quali oggetti attori, etc.
Ciascun componente viene <em>alla fine</em> eseguito
(grazie ai compilatori e interpreti)
da istruzioni macchina e dunque mantiene la Turing-completezza del sistema.</p>
<p>Ci sono modelli di calcolo o anche:ref:<cite>Domain-Specific Languages (DSL)</cite>  <strong>deliberatamente</strong> non universali,
per tre motivi principali:</p>
<ul class="simple">
<li><p><strong>Verificabilità</strong> : SL reattivi senza ricorsione → analisi statica garantita</p></li>
<li><p><strong>Sicurezza</strong>:   Smart Contracts (e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Tezos">Tezos</a> <a class="reference external" href="https://docs.tezos.com/smart-contracts/languages/michelson">Michelson</a>) → prevenzione infinite loops</p></li>
<li><p><strong>Semplificazione concettuale</strong>  DSL dichiarativi per configurazione (SQL senza ricorsione)</p></li>
</ul>
</section>
</section>
<section id="teoria-algoritmica-dell-informazione">
<span id="id29"></span><h2>Teoria Algoritmica dell’Informazione<a class="headerlink" href="#teoria-algoritmica-dell-informazione" title="Permalink to this heading">¶</a></h2>
<p>La <strong>Teoria Algoritmica dell’Informazione</strong> (<strong>AIT</strong>) può essere vista come la versione “metrica”
della teoria di Turing.
Se Turing si occupava di ciò che può essere fatto (<strong>possibilità</strong>), la AIT si occupa di quanto costa farlo
in termini di bit (<strong>complessità</strong>). In sintesi:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Teoria della Computabilità</strong></p></td>
<td><p><strong>Teoria Algoritmica dell’Informazione</strong></p></td>
</tr>
<tr class="row-even"><td><p>Si chiede: “Esiste un algoritmo per questo?”</p></td>
<td><p>Si chiede: “Qual è l’algoritmo più breve per questo?”</p></td>
</tr>
<tr class="row-odd"><td><p>Si concentra sull’esistenza del calcolo.</p></td>
<td><p>Si concentra sulla compressione del calcolo.</p></td>
</tr>
<tr class="row-even"><td><p>Risultato chiave: Il Problema dell’Arresto.</p></td>
<td><p>Risultato chiave: L’Incomputabilità della Complessità.</p></td>
</tr>
</tbody>
</table>
<p>Fondata negli anni ‘60 da <em>Andrej Kolmogorov</em>, <em>Gregory Chaitin</em> e <em>Ray Solomonoff</em>,
la <strong>AIT</strong> definisce l’informazione non come una probabilità statistica (come faceva Shannon),
ma come <strong>struttura e contenuto</strong>.  Riportiamone i punti salienti:</p>
<ul>
<li><p><strong>pattern</strong></p>
<p>Nell’AIT, un oggetto è considerato “strutturato” (e quindi contenente un pattern)
se può essere compresso.
Data un stringa di dati <code class="docutils literal notranslate"><span class="pre">X</span></code>:</p>
<ul class="simple">
<li><p>Se <code class="docutils literal notranslate"><span class="pre">X</span></code> è casuale, la sua descrizione più breve è la stringa stessa (non c’è pattern).</p></li>
<li><p>Se <code class="docutils literal notranslate"><span class="pre">X</span></code> contiene un pattern, esiste un algoritmo/programma (P) molto più corto di <code class="docutils literal notranslate"><span class="pre">X</span></code>
che può generarlo. Questo è il modello formale di ciò che il filosofo <strong>Daniel Dennett</strong> chiama
“leverage” (leva predittiva):
il pattern è reale perché permette di “risparmiare” informazione senza perdere il contenuto essenziale.</p></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>La Complessità di Kolmogorov</strong></p>
<p>Il concetto cardine è che la complessità di un oggetto (come una configurazione del gioco <span class="xref std std-ref">Conway Game of Life</span>)
è definita dalla <strong>lunghezza del programma più breve che lo può produrre</strong>.</p>
<p>K(s) = min { <a href="#id226"><span class="problematic" id="id227">|p|</span></a> : U(p) = s }</p>
<p>Dove s è la stringa, p è il programma e U è una macchina di Turing universale.</p>
<ul class="simple">
<li><p><strong>Bassa Complessità (Senso):</strong> Una griglia piena di “Block” stabili ha una K molto bassa,
perché si può scrivere: <cite>“Disegna un quadrato ogni N pixel”</cite>.</p></li>
<li><p><strong>Alta Complessità (Caos):</strong> Una griglia di rumore casuale ha una K altissima, perché l’unico modo
per descriverla è elencare lo stato di ogni singolo cella: <cite>“Cella 1 viva, 2 morta, 3 morta…”</cite>.</p></li>
</ul>
<p>La Complessità di Kolmogorov K stabilisce un limite oggettivo alla comprimibilità di un sistema.
Anche se diversi osservatori usano diversi linguaggi di programmazione,
la lunghezza della descrizione più breve differisce solo per una costante fissa.</p>
</li>
<li><p><strong>La Casualità come Incomprimibilità</strong></p>
<p>Per l’AIT, un oggetto è <strong>casuale</strong> se non può essere compresso.
Se non trovi un algoritmo più breve della stringa stessa per descriverla, allora quella stringa non ha “senso”
o “struttura” logica; è rumore puro.</p>
<p>Questo si ricollega al fatto che il “senso” emerge quando l’osservatore trova
una <strong>compressione algoritmica</strong>
(una regola) in ciò che vede. Vedere un “Glider” nel <span class="xref std std-ref">Conway Game of Life</span>
è un atto di compressione:
invece di bit sparsi,  si ‘vede’ un’unica “entità” che si muove.</p>
</li>
<li><p><strong>L’Induzione di Solomonoff e il Rasoio di Occam</strong></p>
<p>Solomonoff ha usato l’AIT per formalizzare matematicamente il Rasoio di Occam. La teoria dice che:</p>
<p>“Tra tutte le ipotesi che spiegano i dati osservati, quella più probabile è la più corta
(quella con la minore complessità algoritmica).”</p>
<p>Nel <span class="xref std std-ref">Conway Game of Life</span>, se si vede uno schema che sembra muoversi,
il cervello sceglie l’ipotesi “È un oggetto semovente” perché è algoritmicamente più semplice che pensare
“Sono centinaia di pixel indipendenti che cambiano stato per puro caso in modo coordinato”.
<strong>Il ‘senso è la spiegazione più economica.</strong></p>
</li>
<li><p><strong>Il Numero Omega di Chaitin</strong></p>
<p>Gregory Chaitin ha portato la teoria verso l’ignoto con , la “probabilità di arresto”. <span class="math notranslate nohighlight">\(\Omega\)</span>
è un numero reale che esprime la probabilità che un programma generato casualmente si fermi.</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\Omega\)</span> è <strong>incalcolabile</strong> e racchiude in sé la soluzione a ogni problema matematico.</p></li>
<li><p>Rappresenta il limite estremo della conoscenza: esiste una saggezza (informazione) che nessuna logica può estrarre in modo sistematico.</p>
<p><strong>Senza un osservatore che cerchi la compressione, l’universo è solo una stringa incomprimibile di bit casuali.</strong></p>
</li>
</ul>
</li>
<li><p><strong>Il Problema della “Non-Computabilità”</strong></p>
<p>Un punto critico discusso nella letteratura del <code class="docutils literal notranslate"><span class="pre">2025</span></code> è che la complessità di Kolmogorov è non computabile
(non esiste un algoritmo generale per trovarla sempre).
Questo riflette l’idea di Dennett secondo cui non esiste una “prospettiva divina” per identificare
tutti i pattern;
la loro scoperta dipende dalla nostra capacità (limitata ma efficace) di trovare scorciatoie matematiche
e predittive nel caso dei dati.</p>
</li>
<li><p><strong>La Complessità di Kolmogorov come Misura della Realtà</strong></p>
<ul class="simple">
<li><p><strong>Definizione di Pattern</strong>: Negli studi recenti, un pattern dennettiano è definito come una descrizione
compressa dei dati. Se un sistema ha una complessità di Kolmogorov <code class="docutils literal notranslate"><span class="pre">K(x)</span></code> significativamente inferiore
alla lunghezza dei dati grezzi, allora quel sistema contiene un “real pattern”.</p></li>
<li><p><strong>Ontologia algoritmica</strong>: La realtà di un’entità (come un “glider” nel Gioco della Vita) non dipende
dalla sua sostanza, ma dal fatto che l’algoritmo per descrivere il sistema diventa drasticamente
più corto se includiamo quel pattern nella nostra “ontologia”.</p></li>
</ul>
</li>
<li><p><strong>Il Modello del “Minimum Description Length” (MDL)</strong></p>
<p>Nel volume del 2026 di Dennett <em>Real Patterns in Science and Nature</em> (MIT Press), i ricercatori utilizzano
il principio del <em>Minimum Description Length</em> per risolvere il dibattito tra realismo e strumentalismo:</p>
<ul class="simple">
<li><p><strong>Pattern e Rumore</strong>: MDL permette di bilanciare la precisione (aderenza ai dati) e la semplicità
(brevità della descrizione).</p></li>
<li><p><strong>Criterio di Oggettività</strong>: Un pattern è considerato “reale” se e solo se la sua inclusione nel modello
riduce la lunghezza totale della descrizione, pur “pagando” il costo di ignorare un po’ di rumore.</p></li>
</ul>
</li>
</ul>
<section id="applicazione-all-intelligenza-artificiale">
<h3>Applicazione all’Intelligenza Artificiale<a class="headerlink" href="#applicazione-all-intelligenza-artificiale" title="Permalink to this heading">¶</a></h3>
<p>Ricerche pubblicate tra il 2025 e l’inizio del 2026 collegano i pattern di Dennett al funzionamento
dei <em>Large Language Models</em> (LLM):</p>
<ul class="simple">
<li><p><strong>Emergenza</strong>: Le capacità di ragionamento “zero-shot” dei modelli transformer sono interpretate
come l’estrazione di pattern reali (strutture semantiche e logiche) da moltitudini di dati grezzi.</p></li>
<li><p><strong>Codifica Predittiva</strong>: La mente umana e l’IA sono viste come “motori di compressione”
che estraggono pattern reali per minimizzare l’errore di previsione, una tesi che unifica
l’epistemologia di Dennett con le neuroscienze computazionali moderne.</p></li>
</ul>
</section>
</section>
<section id="evoluzione-del-concetto-di-computazione">
<h2>Evoluzione del concetto di Computazione<a class="headerlink" href="#evoluzione-del-concetto-di-computazione" title="Permalink to this heading">¶</a></h2>
<p>Con l’evoluzione dei computer, è diventato evidente che i sistemi software reali non si riducono a
funzioni matematiche che trasformano un input in un output.</p>
<p>Dal <code class="docutils literal notranslate"><span class="pre">1940</span></code> al <code class="docutils literal notranslate"><span class="pre">1970</span></code>, il computer era visto essenzialmente come l’implementazione fisica della Macchina di Turing
o della Macchina di Von Neumann. A un computer veniva affidato il compito di eseguire un <strong>Algoritmo</strong>,
cioè una sequenza finita e ben definita di istruzioni per risolvere un problema specifico o eseguire un calcolo.</p>
<p>Un computer classico (CPU) opera eseguendo istruzioni codificate (linguaggio macchina),
agendo come un <strong>interprete di un linguaggio formale</strong>.
Ogni livello software (dal linguaggio di alto livello fino al microcodice) è un’astrazione
che viene <em>interpretata in istruzioni più fondamentali</em> (elementi di base).</p>
<p>Dopo il <code class="docutils literal notranslate"><span class="pre">1970</span></code>, con l’avvento dei sistemi interattivi, delle reti e di Internet,
i problemi da risolvere non erano più solo di calcolo, ma di organizzazione e interazione con il mondo reale,
con gli utenti e con altre macchine. Vi sono state ‘forze’ che hanno sprinto
verso nuove frontiere:</p>
<ul class="simple">
<li><p><strong>Complessità Crescente</strong>: I programmi sono diventati troppo grandi per essere gestiti come un unico algoritmo,
portando alla necessità di modularità, astrazione e occultamento dell’informazione, come negli oggetti software
e nei (micro)servizi.</p></li>
<li><p><strong>Requisiti di Interazione</strong>: L’informatica si è spostata dal calcolo puro all’interazione continua
(sistemi operativi, reti, database, interfacce utente).
La “correttezza” non è solo la correttezza algoritmica, ma la correttezza comportamentale in un ambiente dinamico.</p></li>
<li><p><strong>Ingegneria del Software</strong>: Si è riconosciuta la necessità di discipline ingegneristiche per gestire
l’intero ciclo di vita del software, superando la sola logica algoritmica.</p></li>
</ul>
<p>Emergono nuove esigenze:</p>
<ul class="simple">
<li><p><strong>concorrenza</strong> e processi che evolvono in parallelo;</p></li>
<li><p><strong>comunicazione</strong> tra entità autonome;</p></li>
<li><p><strong>distribuzione</strong> e assenza di una memoria centrale;</p></li>
<li><p><strong>mobilità</strong> di codici e canali;</p></li>
<li><p><strong>stocasticità</strong> e incertezza;</p></li>
<li><p><strong>comportamenti globali emergenti</strong> da interazioni locali.</p></li>
</ul>
<p>La <em>Macchina di Turing</em> non basta più per descrivere questi fenomeni.
Non è sbagliata: è solo <strong>inadatta</strong> al nuovo dominio.</p>
<p>Il concetto di computazione si è amplia progressivamente, passando dall’idea di calcolo
simbolico/algoritmico a nuove forme, quali:</p>
<ul class="simple">
<li><p><strong>Computazione come processo strutturato</strong> (anni 60-80) in cui La computazione non è più solo trasformazione di simboli,
ma organizzazione di processi concettuali, legati alla evoluzione del software (Programmazione strutturata, oop, etc.).</p></li>
<li><p><strong>Computazione come concorrenza e comunicazione</strong> (anni 70-oggi) in cui computazione diventa interazione, non più solo calcolo
e calcolare significa “scambiare informazione”, non eseguire funzioni matematiche</p></li>
<li><p><strong>Computazione come sistema complesso</strong> (anni 90-oggi) in cui la la computazione viene vista come
entità che cooperano o competono, eventi asincroni, comportamento emergente, auto-organizzazione</p></li>
</ul>
<p>I paradimgi computazionali oggi studiati
dal <a class="reference external" href="https://en.wikipedia.org/wiki/Natural_computing">Natural computing</a> , vengono astratti da fenomenic naturali diversi come
l’auto-organizzazione, l’evoluzione Darwiniana, il comportamento di gruppo (Swarm intelligence),
il sistema immunitario, fino alla idea (<em>Zuse-Fredlink</em>) che l’informazione
sia più fondamentale della materia o dell’energia e che l’universo stesso sia un computer
quantistico (<em>Seth LLyod</em>) che computa il suo proprio comportamento.</p>
<p>Si assiste così a una esplosione di nuovi formalismi, ognuno dei quali nasce per rispondere a una “forza storica” precisa:</p>
<ul class="simple">
<li><p><strong>la concorrenza</strong> → <a class="reference external" href="https://en.wikipedia.org/wiki/Calculus_of_communicating_systems">CCS</a> (Milner) e <a class="reference external" href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> (Hoare), <span class="math notranslate nohighlight">\(\pi\)</span>-calcolo (<a class="reference external" href="https://it.wikipedia.org/wiki/Pi_calcolo">Pi calcolo</a>);</p></li>
<li><p><strong>il comportamento reattivo</strong> → automi, transizione di stato, model checking;</p></li>
<li><p><strong>la computazione distribuita</strong> → Actor Model (Hewitt, Agha), Join Calculus;</p></li>
<li><p><strong>la mobilità</strong> → Mobile Ambients (Cardelli), <span class="math notranslate nohighlight">\(\pi\)</span>-calcolo mobile;</p></li>
<li><p><strong>il caso e la variabilità</strong> → <span class="math notranslate nohighlight">\(\pi\)</span>-calcolo stocastico (Priami), Markov Processes;</p></li>
<li><p><strong>la computazione globale</strong> → Field Calculus, Aggregate Computing (Beal, Viroli).</p></li>
</ul>
<p>In ognuno di questi casi, il formalismo nasce <em>prima</em> dei linguaggi di programmazione che ne derivano.
Ad esempio:</p>
<ul class="simple">
<li><p><strong>Lisp</strong> come incarnazione del <span class="math notranslate nohighlight">\(\lambda\)</span>-calcolo;</p></li>
<li><p><strong>Erlang, Akka, Orleans</strong> come discendenti dell’Actor Model;</p></li>
<li><p><strong>Go, Rust async, CSP libraries</strong> ispirate a CSP;</p></li>
<li><p><strong>Proto, Scafi</strong> ispirati al Field Calculus;</p></li>
<li><p><strong>AmbientTalk, Klaim</strong> ispirati alla mobilità dei processi.</p></li>
</ul>
<section id="verso-la-definizione-di-sistemi-che-calcolano">
<h3>Verso la definizione di ‘sistemi che calcolano’<a class="headerlink" href="#verso-la-definizione-di-sistemi-che-calcolano" title="Permalink to this heading">¶</a></h3>
<p>La nozione di computazione, nata per descrivere ciò che una macchina può calcolare,
si è progressivamente trasformata in una teoria di ciò che un sistema può far emergere.</p>
<p>Il termine <em>‘computazione’</em> diventa <strong>polisemico</strong> e perde la nitidezza logico-matematica originaria.</p>
<p>Si può dire che oggi una <em>computazione</em> non è più intesa come la valutazione di una funzione,
ma come l’evoluzione controllata di uno stato collettivo sotto vincoli.</p>
<p>Una estrema sintesi dell’evoluzione storica è che si passa:</p>
<ol class="arabic simple">
<li><p><strong>dal calcolo come trasformazione di funzioni</strong>,</p></li>
<li><p><strong>al calcolo come parallelismo  e interazione</strong>,</p></li>
<li><p><strong>al calcolo come comportamento collettivo</strong>,</p></li>
<li><p><strong>al calcolo come fenomeno emergente</strong>.</p></li>
</ol>
<p>Questo cambiamento è profondamente legato alla trasformazione dell’ingegneria del software:
oggi non costruiamo più singoli algoritmi, ma <strong>sistemi distribuiti</strong>,  <strong>microservizi</strong>,
<strong>reti di attori</strong>, <strong>sistemi software complessi</strong>.</p>
</section>
</section>
<section id="famiglie-di-formalismi">
<h2>Famiglie di formalismi<a class="headerlink" href="#famiglie-di-formalismi" title="Permalink to this heading">¶</a></h2>
<p>Nel corso della storia dell’informatica teorica, i formalismi si sono evoluti in risposta
a esigenze sempre nuove: definire cosa significhi calcolo, modellare la concorrenza,
gestire sistemi distribuiti non affidabili, comprendere il ruolo della mobilità,
descrivere l’emergenza di comportamenti globali.</p>
<p>Questa evoluzione ha dato vita a una serie di <em>famiglie</em> di formalismi, ciascuna caratterizzata
da un’idea guida, da un ambito di applicazione privilegiato e da risultati teorici
che ne precisano potere espressivo e limiti.</p>
<p>L’insieme delle famiglie  mostra come i formalismi non siano strumenti puramente accademici:
sono la <strong>grammatica fondamentale</strong> con cui l’ingegneria del software comprende e progetta sistemi
sempre più complessi, autonomi, distribuiti e adattivi.</p>
<p>Ogni famiglia è nata in risposta a una tensione storica concreta, e ogni risultato teorico
ha contribuito a definire il perimetro del possibile e dell’impossibile in informatica.</p>
<section id="alcuni-dei-promotori">
<h3>Alcuni dei promotori<a class="headerlink" href="#alcuni-dei-promotori" title="Permalink to this heading">¶</a></h3>
<p>Dalla <em>Macchina di Turing</em> ai calcoli concorrenti, fino ai modelli per sistemi complessi,
la storia dei formalismi è la storia dell’evoluzione della computazione stessa:
da operazioni meccaniche a fenomeni collettivi autonomi.</p>
<p>Ricordiamo alucni degli studiosi che hanno aperto le diverse strade che oggi possiamo percorrere:</p>
<ul class="simple">
<li><p><strong>Alan Turing</strong>,  la computazione come processo meccanico sequenziale.</p></li>
<li><p><strong>Alonzo Church</strong>,  la computazione come trasformazione simbolica (<span class="math notranslate nohighlight">\(\lambda\)</span>-calcolo).</p></li>
<li><p><strong>Stephen Kleene</strong>, <strong>Gödel</strong>, <strong>Herbrand</strong>, computazione come ricorsione.</p></li>
<li><p><strong>Emil Post</strong>, <strong>Markov</strong>, riscrittura e manipolazione di stringhe.</p></li>
<li><p><strong>Robin Milner</strong>, <strong>Tony Hoare</strong>, processi concorrenti e comunicazione.</p></li>
<li><p><strong>Carl Hewitt</strong>, <strong>Gul Agha</strong>, attori come entità autonome.</p></li>
<li><p><strong>Luca Cardelli</strong>, <strong>Andrew Gordon</strong>, mobilità e confini (<em>Ambient Calculus</em>).</p></li>
<li><p><strong>Luca Cardelli</strong>, <strong>Gierz</strong>, <strong>Milner</strong>, transizioni di stato e sistemi dinamici.</p></li>
<li><p><strong>Radhika Nagpal</strong>, <strong>Beal</strong>, <strong>Viroli</strong>, computazione di campo e self-organization.</p></li>
<li><p><strong>Christopher Langton</strong>, <strong>Stuart Kauffman</strong>, <strong>Per Bak</strong>, sistemi complessi e auto-organizzazione.</p></li>
</ul>
<p>Queste figure non hanno solo inventato formalismi: hanno introdotto <strong>nuovi modi di pensare</strong> il calcolo;
vediamone una sintetica panoramica.</p>
</section>
<section id="formalismi-funzionali">
<h3>Formalismi funzionali<a class="headerlink" href="#formalismi-funzionali" title="Permalink to this heading">¶</a></h3>
<p>La prima grande famiglia è quella dei formalismi funzionali, nata negli <strong>anni ‘30</strong> con Alonzo Church e la definizione
del <span class="math notranslate nohighlight">\(\lambda\)</span> <strong>calcolo</strong>. L’idea fondamentale è che la computazione possa essere vista
come <em>applicazione di funzioni a valori</em>, senza memoria mutabile né effetti collaterali.</p>
<p>Questa visione è profondamente radicata nella logica matematica e nella teoria delle funzioni ricorsive.</p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<p>I formalismi funzionali servono principalmente a:</p>
<ul class="simple">
<li><p>descrivere la computazione in modo puramente simbolico,</p></li>
<li><p>ragionare su trasformazioni e riduzioni,</p></li>
<li><p>garantire proprietà come la <em>referential transparency</em>,</p></li>
<li><p>dimostrare equazioni e invarianti senza preoccuparsi dello stato.</p></li>
</ul>
<p>Sono fondamentali per discipline come la programmazione funzionale, gli strumenti di ottimizzazione
dei compilatori e i linguaggi basati su funzioni pure (<code class="docutils literal notranslate"><span class="pre">Haskell</span></code>, <code class="docutils literal notranslate"><span class="pre">ML</span></code>).</p>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>Equivalenza Church–Turing</strong>: il <span class="math notranslate nohighlight">\(\lambda\)</span>-calcolo è Turing-completo.</p></li>
<li><p><strong>Teorema di Church–Rosser (confluenza)</strong>: l’ordine di riduzione delle espressioni non influisce sul risultato finale (se questo esiste).</p></li>
<li><p><strong>Indecidibilità della normalizzazione</strong>: non si può decidere in generale se un termine del <span class="math notranslate nohighlight">\(\lambda\)</span>-calcolo ha una forma normale.</p></li>
<li><p><strong>Sistema di tipi</strong>: introduzione dei tipi semplici (Church) e dei sistemi polimorfi, fondamentali per linguaggi moderni.</p></li>
</ul>
<p>Questi risultati fondano l’intera disciplina della programmazione funzionale moderna.</p>
</section>
<section id="formalismi-concorrenti">
<h3>Formalismi concorrenti<a class="headerlink" href="#formalismi-concorrenti" title="Permalink to this heading">¶</a></h3>
<p>A partire dagli <strong>anni ‘60 e ‘70</strong>, con lo sviluppo dei sistemi time-sharing, emerge il problema
della <strong>concorrenza</strong>. Robin Milner, Tony Hoare ed altri introducono formalismi che trattano
i processi <em>non</em> come funzioni, ma come entità dinamiche in comunicazione.</p>
<p>Nascono così <strong>CSP</strong>, <strong>CCS</strong> e, più tardi, il <span class="math notranslate nohighlight">\(\pi\)</span> <strong>calcolo</strong>.</p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<p>Questi formalismi servono a:</p>
<ul class="simple">
<li><p>modellare processi che evolvono in parallelo,</p></li>
<li><p>formalizzare comunicazioni sincrone/asincrone,</p></li>
<li><p>verificare sicurezza (deadlock-freedom) e liveness,</p></li>
<li><p>definire equivalenze comportamentali (bisimulazione),</p></li>
<li><p>ragionare sul nondeterminismo operativo.</p></li>
</ul>
<p>Sono indispensabili per sistemi real-time, middleware concorrenti, modelli actor
e linguaggi come <code class="docutils literal notranslate"><span class="pre">Erlang</span></code>, <code class="docutils literal notranslate"><span class="pre">Occam</span></code>, <code class="docutils literal notranslate"><span class="pre">Go</span></code> (canali CSP-like).</p>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>Bisimulazione</strong> (Milner, Park): due processi sono equivalenti se non distinguibili da un osservatore esterno.</p></li>
<li><p><strong>Teoria delle transizioni strutturali</strong>: permette di definire formalmente il comportamento di
processi complessi con regole modulari.</p></li>
<li><p><span class="math notranslate nohighlight">\(\pi\)</span> <strong>calcolo Turing-completo</strong> con scambio dinamico di canali.</p></li>
<li><p><strong>Risultati di impossibilità</strong>: certi pattern di mobilità non sono esprimibili in CCS senza estensioni.</p></li>
</ul>
<p>Questi risultati segnano il passaggio decisivo dal calcolo come funzione al calcolo come <em>interazione</em>.</p>
</section>
<section id="formalismi-distribuiti">
<h3>Formalismi distribuiti<a class="headerlink" href="#formalismi-distribuiti" title="Permalink to this heading">¶</a></h3>
<p>Con lo sviluppo delle reti (ARPANET, Internet) emerge la necessità di modellare sistemi
in cui nessun processo possiede un punto di vista globale. <em>Hewitt</em> introdusse l’<strong>Actor Model</strong>
già negli <strong>anni ‘70</strong></p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<ul class="simple">
<li><p>modellare comunicazione asincrona senza memoria condivisa;</p></li>
<li><p>trattare fallimenti, partizioni di rete, ritardi imprevedibili;</p></li>
<li><p>descrivere algoritmi distribuiti e protocolli;</p></li>
<li><p>caratterizzare il comportamento di  microservizi e cluster.</p></li>
</ul>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>Teorema FLP (Fischer-Lynch-Paterson)</strong>: impossibile garantire consenso deterministico
in un sistema asincrono con un fallo possibile.</p></li>
<li><p><strong>Teorema CAP</strong>: impossibile garantire contemporaneamente <strong>Consistenza, Disponibilità e Tolleranza alla Partizione</strong>.</p></li>
<li><p><strong>Determinismo con attori isolati</strong>: gli attori sono Turing-completi ma con un forte controllo sull’interferenza.</p></li>
</ul>
<p>Questi risultati hanno avuto impatto diretto sul design dei sistemi cloud e dei <span class="xref std std-ref">Sistemi a microservizi</span>.</p>
</section>
<section id="formalismi-per-la-mobilita">
<h3>Formalismi per la mobilità<a class="headerlink" href="#formalismi-per-la-mobilita" title="Permalink to this heading">¶</a></h3>
<p>L’attenzione alla <strong>mobilità</strong> (di codice, processi, canali) emerge negli <strong>anni ‘90</strong> con gruppi
come quello di <em>Luca Cardelli</em> e <em>Andrew Gordon</em>. Nascono così formalismi come il <strong>Mobile Ambients</strong> e
le estensioni mobili del <span class="math notranslate nohighlight">\(\pi\)</span>-calcolo.</p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<ul class="simple">
<li><p>descrivere sistemi che cambiano struttura dinamicamente;</p></li>
<li><p>modellare agenti mobili, protocolli ad hoc, migrazione di processi;</p></li>
<li><p>rappresentare reti pervasive o IoT.</p></li>
</ul>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>Il mobile</strong> <span class="math notranslate nohighlight">\(\pi\)</span> <strong>calculus</strong> è più espressivo di <strong>CCS</strong>;</p></li>
<li><p><strong>alcune proprietà di sicurezza sono indecidibili</strong> in ambienti mobili;</p></li>
<li><p><strong>gerarchie di potere espressivo</strong> tra modelli nominali e strutturali;</p></li>
<li><p><strong>equivalenza con automi di mobilità</strong> in vari casi.</p></li>
</ul>
<p>Questi formalismi sono fondamentali nella modellazione di sistemi IoT e mobile-cloud.</p>
</section>
<section id="formalismi-stocastici">
<h3>Formalismi stocastici<a class="headerlink" href="#formalismi-stocastici" title="Permalink to this heading">¶</a></h3>
<p>La necessità di modellare comportamenti probabilistici, biologici o di rete porta alla
nascita (<strong>anni 2000</strong>) del <span class="math notranslate nohighlight">\(\pi\)</span> <strong>calcolo stocastico</strong>, delle <strong>CTMC</strong> (<em>continuous-time Markov chain</em>)
e <strong>DTMC</strong> (<em>Discrete-time Markov chain</em>),
dei modelli Markoviani e dei sistemi probabilistici.</p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<ul class="simple">
<li><p>descrivere sistemi soggetti a rumore, variabilità o fallimenti probabilistici;</p></li>
<li><p>associarne tempi medi, probabilità di stati, rischi;</p></li>
<li><p>supportare model checking probabilistico.</p></li>
</ul>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>ergodicità</strong> e <strong>stazionarietà</strong> delle catene di Markov;</p></li>
<li><p><strong>decidibilità</strong> del model checking probabilistico su <code class="docutils literal notranslate"><span class="pre">DTMC/CTMC</span></code> finite;</p></li>
<li><p><strong>indecidibilità</strong> per modelli con memoria illimitata;</p></li>
<li><p><strong>calcolo Turing-completo</strong> in alcune estensioni probabilistiche del <span class="math notranslate nohighlight">\(\lambda\)</span>-calcolo.</p></li>
</ul>
<p>Questi formalismi sono oggi fondamentali per sistemi autonomi, robotics e protocolli di rete.</p>
</section>
<section id="formalismi-field-based-e-global-behavior">
<h3>Formalismi field-based e global behavior<a class="headerlink" href="#formalismi-field-based-e-global-behavior" title="Permalink to this heading">¶</a></h3>
<p>Dagli <strong>anni 2000-2010</strong> nasce una nuova esigenza: modellare <strong>comportamenti globali emergenti</strong>
a partire da moltissime entità locali.
È la famiglia dei formalismi “a campo”, come il <strong>Field Calculus</strong>, il linguaggio <strong>Proto</strong>,
e le estensioni <strong>aggregate computing</strong>.</p>
<p>Il Field Calculus non calcola valori,
ma calcola configurazioni spaziali, dando come
risultato un pattern stabile.</p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<ul class="simple">
<li><p>descrivere sistemi auto-organizzanti;</p></li>
<li><p>modellare propagazione, stabilizzazione e gradienti;</p></li>
<li><p>controllare comportamenti globali senza un coordinatore centrale;</p></li>
<li><p>formalizzare sistemi complessi su larga scala: swarm robotics, reti self-organizing, large IoT.</p></li>
</ul>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>equivalenza del field calculus</strong> con un <span class="math notranslate nohighlight">\(\lambda\)</span> <strong>calcolo distribuito</strong> strutturato su spazio e tempo;</p></li>
<li><p><strong>teoremi di stabilizzazione</strong> in presenza di mobilità e fallimenti;</p></li>
<li><p><strong>limiti della computazione spaziale</strong>: impossibile ottenere global properties con vicinato insufficiente;</p></li>
<li><p><strong>convergenza garantita</strong> per classi di programmi auto-stabilizzanti.</p></li>
</ul>
<p>Questa famiglia rappresenta il ponte più diretto tra sistemi complessi naturali e sistemi complessi software.</p>
</section>
<section id="formalismi-per-sistemi-complessi-e-dinamiche-non-lineari">
<h3>Formalismi per sistemi complessi e dinamiche non lineari<a class="headerlink" href="#formalismi-per-sistemi-complessi-e-dinamiche-non-lineari" title="Permalink to this heading">¶</a></h3>
<p>Modelli come <strong>automi cellulari</strong>, <strong>agent-based models</strong>, <strong>reti complesse</strong> e <strong>sistemi dinamici non lineari</strong>
derivano da un’altra tradizione: fisica, biologia, teoria del caos. Il tema centrale è la <em>dinamica collettiva</em>.</p>
<p>Questa famiglia di formalismi serve principalmente a:</p>
<ul class="simple">
<li><p>analizzare emergenze non lineari;</p></li>
<li><p>studiare caos, biforcazioni, auto-organizzazione;</p></li>
<li><p>modellare popolazioni di agenti, ecosistemi artificiali, fenomeni di sincronizzazione.</p></li>
</ul>
<p><em>Principali risultati teorici</em></p>
<ul class="simple">
<li><p><strong>Turing-completezza</strong> dell’automa cellulare <a class="reference external" href="https://en.wikipedia.org/wiki/Rule_110">Rule 110</a>;</p></li>
<li><p><strong>Teorema di Li-Yorke</strong>: il caos è inevitabile in certi sistemi dinamici;</p></li>
<li><p><strong>criticitá auto-organizzata</strong> (Bak, Tang, Wiesenfeld) produce distribuzioni a <a class="reference external" href="https://it.wikipedia.org/wiki/Legge_di_potenza">Legge di potenza</a>;</p></li>
<li><p><strong>limiti alla predicibilità</strong> (sensibilità alle condizioni iniziali).</p></li>
</ul>
<p>Questi formalismi ispirano tecniche di simulazione su larga scala e modelli per “sistemi complessi software”.</p>
</section>
<section id="oltre-la-macchina-di-von-neumann">
<h3>Oltre la macchina di Von Neumann<a class="headerlink" href="#oltre-la-macchina-di-von-neumann" title="Permalink to this heading">¶</a></h3>
<p>L’architettura di Von Neumann — processore centrale (CPU) + memoria separata + esecuzione sequenziale di istruzioni —
rimane il modello di riferimento per la maggior parte dei computer moderni.
Tuttavia, pone limiti ben noti:</p>
<ul class="simple">
<li><p>buona flessibilità generale</p></li>
<li><p>colli di bottiglia nell’accesso alla memoria</p></li>
<li><p>limitata parallelizzazione</p></li>
<li><p>inefficienza energetica con carichi massivamente paralleli</p></li>
</ul>
<p>Da qui deriva la nascita di <strong>nuove architetture</strong>, orientate a superarne i limiti su compiti specifici.
Non è questa le sede per entrare nei dettagki di queste nuove architetture. Riportiamo solo un
quadro sintetico delle alternative oggi più diffuse:</p>
<blockquote>
<div><table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Architettura</strong></p></td>
<td><p><strong>Paradigma</strong></p></td>
<td><p><strong>Applicazioni</strong></p></td>
<td><p><strong>Limitazioni</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>GPU</strong></p></td>
<td><p>SIMD/SIMT massivo</p></td>
<td><p>Grafica, ML, fisica</p></td>
<td><p>Poco efficiente per logica complessa</p></td>
</tr>
<tr class="row-odd"><td><p><strong>TPU</strong></p></td>
<td><p>Matrici / systolic arrays</p></td>
<td><p>Inferenza e training AI</p></td>
<td><p>Poco efficiente per logica complessa</p></td>
</tr>
<tr class="row-even"><td><p><strong>Quantum</strong></p></td>
<td><p>Superposizione e entanglement</p></td>
<td><p>Problemi esponenziali selezionati</p></td>
<td><p>Rumore, scalabilità, algoritmi specifici</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="quantum-computer">
<span id="id30"></span><h3>Quantum computer<a class="headerlink" href="#quantum-computer" title="Permalink to this heading">¶</a></h3>
<p>La computazione legata sulle leggi  della <a class="reference external" href="https://it.wikipedia.org/wiki/Meccanica_quantistica">Meccanica quantistica</a>
(avanzata da <em>Richard Feynman</em> nel <code class="docutils literal notranslate"><span class="pre">1982</span></code> e poi formalizata da  <em>David Deutsch</em> nel <code class="docutils literal notranslate"><span class="pre">1985</span></code>)
ha promosso lo sviluppo del  <strong>Computer Quantistico (QC)</strong> e del <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_computing">Quantum computing</a>.</p>
<p>Una convergenza di idee emerse tra la fine degli anni ‘70 e l’inizio degli anni ‘80,
è culminata con l’indicazione di <em>Richard Feynman</em> (<code class="docutils literal notranslate"><span class="pre">1982</span></code>) che un computer basato sulle leggi della
meccanica quantistica potesse essere lo strumento necessario per simulare altri sistemi quantistici.</p>
<p>Su qusta base,
nel <code class="docutils literal notranslate"><span class="pre">1985</span></code>, <em>David Deutsch</em>  formalizzò l’idea di una Macchina di Turing Universale Quantistica,
dimostrando che i principi quantistici potevano essere applicati all’elaborazione dell’informazione,
aprendo la via all’idea di <strong>Computer Quantistico (QC)</strong>.</p>
<p>Nel <code class="docutils literal notranslate"><span class="pre">1994</span></code>, <em>Peter Shor</em> sviluppò
di un algoritmo quantistico in grado di fattorizzare numeri interi in modo esponenzialmente
più veloce dei migliori algoritmi classici.</p>
<p>Da quello momento, la ricerca nel campo del calcolo quantistico è progredita rapidamente,
portando allo sviluppo di prototipi di computer quantistici e alla sperimentazione di
algoritmi quantistici per problemi specifici.</p>
<p>Mentre la programmazione classica lavora con istruzioni che cambiano lo stato da <code class="docutils literal notranslate"><span class="pre">0</span></code> a <code class="docutils literal notranslate"><span class="pre">1</span></code> o viceversa,
la programmazione quantistica lavora con i <strong>qubit</strong>:</p>
<ul class="simple">
<li><p>Un qubit esiste in una sovrapposizione di stati, una combinazione probabilistica di 0 e 1.</p></li>
<li><p>Programmare un QC significa controllare e manipolare queste probabilità per allineare gli stati
quantistici in modo che, al momento della misurazione, lo stato desiderato (la soluzione)
abbia la probabilità massima.</p></li>
</ul>
<p>Ciò che rende il computer quantistico qualitativamente diverso da un computer classico
è l’<strong>entanglement</strong>.</p>
<p>L’entanglement è una correlazione quantistica che si verifica quando lo stato di due o più qubit
è così profondamente legato che non è possibile descrivere lo stato di ciascun qubit indipendentemente,
anche se sono separati da grandi distanze.</p>
<p>Quando un algoritmo quantistico crea entanglement tra <code class="docutils literal notranslate"><span class="pre">N</span></code> qubit, non sta semplicemente lavorando su <code class="docutils literal notranslate"><span class="pre">N</span></code>
bit indipendenti. Sta lavorando su un unico stato quantistico collettivo che può codificare
<code class="docutils literal notranslate"><span class="pre">2^N</span></code> combinazioni classiche contemporaneamente.</p>
<p>Questo significa che, grazie all’entanglement, le porte quantistiche (<strong>Quantum Gates</strong>)
applicate durante l’elaborazione
modificano simultaneamente tutte e <code class="docutils literal notranslate"><span class="pre">2^N</span></code> le possibili soluzioni.
Questo è il fondamento del parallelismo quantistico che accelera esponenzialmente la risoluzione
di alcuni problemi.</p>
<p>La programmazione quantistica viene eseguita utilizzando linguaggi o framework come Qiskit (IBM) o Cirq (Google),
che traducono istruzioni ad alto livello  in circuiti di <em>Quantum Gates</em>.</p>
<p>Ovviamente, la computazione quantistica apre nuove prospettive e nuovi campi di ricerca teorica
e applicate.
Tuttavia, allo stato attuale,
il computer quantistico non sostituisce quello classico, ma fornisce una capacità di calcolo
qualitativamente diversa per specifiche classi di problemi.</p>
<p>Il calcolo di un QC è probabilistico, unitario e non clonabile (No-Cloning Theorem).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>La crescente miniaturizzazione dei transistor che compongono un computer  ‘classico’
implica l’insorgere di alcuni fenomeni spiegabili solo con la <a class="reference external" href="https://it.wikipedia.org/wiki/Meccanica_quantistica">Meccanica quantistica</a>.
Ricordiamo al proposito il <strong>Tunneling Quantistico</strong>:</p>
<ul class="simple">
<li><p>responsabile di correnti di dispersione (<strong>leakage current</strong>), che generano calore e sprecano energia.</p></li>
<li><p>usato per spostare gli elettroni dentro e fuori le “floating gate” che
intrappolando elettroni in modo da paermettere
la memorizzazione dei dati nelle <strong>memorie flash</strong> (usate negli <code class="docutils literal notranslate"><span class="pre">SSD</span></code> e nei telefoni).</p></li>
</ul>
</div>
</section>
</section>
<section id="modelli-formali-necessari-ma-non-sufficienti">
<h2>Modelli formali: necessari ma non sufficienti<a class="headerlink" href="#modelli-formali-necessari-ma-non-sufficienti" title="Permalink to this heading">¶</a></h2>
<p>I modelli formali sono importanti perché
isolano l’essenza concettuale dei sistemi permettendo di capirli,
compararli e verificarli in modo rigoroso e universale.</p>
<p>I modelli formali sul calcolo non sono sufficienti perché non dicono <strong>come</strong> realizzare efficientemente
un sistema: sono i <strong>linguaggi di programmazione</strong> che colmano il divario, traducendo principi astratti
in meccanismi concreti, efficienti e utilizzabili nella pratica.</p>
<p>Consideriamo, ad esempio, il il <strong>processo</strong>, spesso introdotto come concetto fondamentale legato
alla computazione.</p>
<p>In <strong>CSP</strong>, <span class="math notranslate nohighlight">\(\pi calcolo\)</span> <strong>calcolo</strong>, ecc.:</p>
<ul class="simple">
<li><p>ciò che esiste sono <strong>processi matematici</strong>, non thread o coroutine;</p></li>
<li><p>un processo è un’entità astratta, definita da un insieme di transizioni o eventi;</p></li>
<li><p>lo stato del processo cambia tramite regole formali (“esegue un evento”, “comunica”, “si sincronizza”).</p></li>
</ul>
<p>In questi modelli:</p>
<ul class="simple">
<li><p><strong>non esistono stack</strong>,</p></li>
<li><p><strong>non esistono scheduler</strong>,</p></li>
<li><p><strong>non esiste il concetto di sospensione volontaria</strong> come <cite>yield</cite> o <cite>await</cite>,</p></li>
<li><p><strong>non c’è distinzione tra thread pesante o coroutine leggera</strong>.</p></li>
</ul>
<p>CSP dice:</p>
<ul class="simple">
<li><p>Esistono processi che comunicano per canali, in modo sincrono.</p></li>
</ul>
<p>Il <span class="math notranslate nohighlight">\(\pi\)</span>-calcolo dice:</p>
<ul class="simple">
<li><p>I processi possono scambiarsi anche canali, supportando mobilità.</p></li>
</ul>
<p>Ma nessuno dei due dice:</p>
<ul class="simple">
<li><p>come si deve gestire lo stack,</p></li>
<li><p>come evitare di creare migliaia di thread pesanti,</p></li>
<li><p>come sospendere una funzione senza bloccare un thread OS.</p></li>
</ul>
<p>Per implementare <em>processi concettuali</em> a basso costo, servivano meccanismi pragmatici.
Tradizionalmente, il concetto di processo è realizzato usando
<em>Thread</em> del sistema operativo o <em>Thread più leggeri</em> gestiti da <em>scheduler</em>.
Tuttavia questi, di solito: <strong>i)</strong> richiedono molta memoria (stack da ~1 MB) <strong>ii)</strong>
sono gestiti da kernel <strong>iii)</strong> hanno costi elevati di switching.</p>
<p>La possibilità pratica di attivare processi si riduce quindi a poche migliaia di <em>Thread</em> in uno stesso
sistema, mentre molte applicazioni moderne richiedono <strong>decine o centinaia di migliaia di attività concorrenti</strong>.</p>
<p>Meccanismi implementativi quali le <strong>callback</strong>
o le <strong>promesse/future</strong> si sono rivelati non ideali
(problema del “callback hell” e della frammentazione del codice).</p>
<p>Un concetto/meccanismo che risale agli albori dell’informatica —
introdotto negli <strong>anni ‘60</strong> come meccanismo di cooperazione tra routine —
poi quasi dimenticato con l’affermarsi dei <em>thread di sistema</em>
è quello di <strong>coroutine</strong>.</p>
<p>Questo meccanismo viene oggi riscoperto e potenziato perché fornisce una soluzione più leggera,
espressiva ed efficiente alla crescente esigenza di concorrenza su larga scala.</p>
</section>
<section id="la-coroutine-un-nuovo-vecchio-concetto">
<span id="id31"></span><h2>La coroutine un nuovo vecchio concetto<a class="headerlink" href="#la-coroutine-un-nuovo-vecchio-concetto" title="Permalink to this heading">¶</a></h2>
<p>La “rinascita” delle coroutine nasce dagli stessi problemi che avevano motiva la loro invenzione
negli anni ‘60:</p>
<ul class="simple">
<li><p>la necessità di gestire altissima concorrenza
(i thread OS sono troppo pesanti per scalare a centinaia di migliaia o milioni di attività)</p></li>
<li><p>la necessità di scrivere codice asincrono leggibile
(superare callback hell, future annidati, codice frammentato)</p></li>
<li><p>la necessità di modelli di concorrenza più sicuri
(riduzione di deadlock e race, privilegiando message passing)</p></li>
</ul>
<p>Introdotte in linguaggi pionieristici come <strong>Simula 67</strong> (uno dei padri della <strong>OOP</strong> e
dei primi concetti di concorrenti cooperativi), <strong>Modula-2</strong> e <strong>Modula-3</strong>
(di <a class="reference external" href="https://it.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>, padre anche del linguaggio <strong>Pascal</strong> )
e alcune versioni evolute del <em>Lisp</em>,
il concetto è stato oggi riscoperto e potenziato perché fornisce una soluzione più leggera,
espressiva ed efficiente alla crescente esigenza di concorrenza su larga scala.</p>
<p>Esso ritorna in linguaggi come:</p>
<ul class="simple">
<li><p>Go (goroutine, 2009)</p></li>
<li><p>Kotlin (coroutine suspend, 2017)</p></li>
<li><p>Python async/await (2015)</p></li>
<li><p>Java virtual threads (Loom), che di fatto sono coroutine del linguaggio (2023)</p></li>
<li><p>C# async/await (2012)</p></li>
<li><p>JavaScript async/await (2017)</p></li>
</ul>
</section>
<section id="un-esempio-csp-e-go">
<h2>Un esempio: CSP e GO<a class="headerlink" href="#un-esempio-csp-e-go" title="Permalink to this heading">¶</a></h2>
<p><strong>CSP</strong> (<em>Communicating Sequential Processes</em>) è un modello formale introdotto da <strong>Tony Hoare (1978)</strong>
per descrivere sistemi concorrenti.
È usato per <a href="#id32"><span class="problematic" id="id33">*</span></a>specificare, analizzare e verificare- protocolli di comunicazione tra processi.</p>
<p>Riportimo un quadro sintetico delle idee fondamentali di CSP</p>
<ul class="simple">
<li><p>Comunicazione sincrona per messaggi</p></li>
<li><p>Canali come entità di prima classe</p></li>
<li><p>Composizione parallela dei processi</p></li>
<li><p>Nessuna memoria condivisa</p></li>
<li><p>Sincronizzazione implicita nella comunicazione</p></li>
<li><p>Modello matematico verificabile</p></li>
</ul>
<section id="csp-processi-sequenziali">
<h3>CSP: Processi sequenziali<a class="headerlink" href="#csp-processi-sequenziali" title="Permalink to this heading">¶</a></h3>
<p>Le caratteristiche chiave di CSP (in sintesi) sono:</p>
<blockquote>
<div><table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Caratteristica</strong></p></td>
<td><p><strong>Descrizione</strong></p></td>
</tr>
<tr class="row-even"><td><p>Processi sequenziali</p></td>
<td><p>Il sistema è formato da <strong>processi</strong>, ciascuno dei quali è sequenziale: esegue azioni una dopo l’altra.</p></td>
</tr>
<tr class="row-odd"><td><p>Comunicazione per canali</p></td>
<td><ul>
<li><p>La comunicazione è <strong>sincrona</strong>: chi invia e chi riceve devono essere entrambi pronti
→ la comunicazione “si completa insieme”.</p></li>
<li><p>Il canale è un’astrazione matematica: niente buffer (di default).</p>
<p>Esempio :</p>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>P = c ! x     // processo P invia x sul canale c
Q = c ? y     // processo Q riceve un valore su c
</pre></div>
</div>
<p>La comunicazione avviene solo quando entrambi i processi sono pronti.</p>
</td>
</tr>
<tr class="row-even"><td><p>Composizione concorrente</p></td>
<td><p>La concorrenza si ottiene tramite <strong>composizione parallela</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">||</span> <span class="n">Q</span>
</pre></div>
</div>
<p>P e Q eseguono in parallelo e devono <em>sincronizzarsi</em> sugli eventi comuni.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Scelta</p></td>
<td><p>Ci sono due tipi di scelta:</p>
<ul class="simple">
<li><p><strong>Scelta esterna</strong> (determinata dall’ambiente)</p></li>
<li><p><strong>Scelta interna</strong> (non osservabile)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Verifica formale</p></td>
<td><p>CSP fornisce un <em>algebra formale</em> per ragionare su:</p>
<ul class="simple">
<li><p>deadlock</p></li>
<li><p>livelock</p></li>
<li><p>race conditions</p></li>
<li><p>equivalenza comportamentale</p></li>
</ul>
<p>È molto usato in contesti safety-critical.</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="come-csp-ha-influenzato-go">
<h3>Come CSP ha influenzato Go<a class="headerlink" href="#come-csp-ha-influenzato-go" title="Permalink to this heading">¶</a></h3>
<p>Il linguaggio <strong>Go</strong>, creato da Google (Pike, Thompson, Griesemer),
incorpora esplicitamente concetti provenienti da CSP.</p>
<p>La frase di Rob Pike è celebre:</p>
<p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong></p>
<p>Go reinterpreta CSP in modo <strong>pragmatico</strong>, rendendolo adatto alla programmazione industriale.
Le principali differenze sono riassunte nella seguente tabella:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Elemento</span>         <span class="o">|</span> <span class="n">CSP</span>                      <span class="o">|</span> <span class="n">Go</span>                             <span class="o">|</span>
<span class="o">|</span> <span class="o">----------------</span> <span class="o">|</span> <span class="o">------------------------</span> <span class="o">|</span> <span class="o">------------------------------</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Comunicazione</span>    <span class="o">|</span> <span class="n">Sincrona</span>                 <span class="o">|</span> <span class="n">Sincrona</span> <span class="o">+</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">asincrona</span><span class="p">)</span>  <span class="o">|</span>
<span class="o">|</span> <span class="n">Semantica</span>        <span class="o">|</span> <span class="n">Matematica</span><span class="p">,</span> <span class="n">formale</span>      <span class="o">|</span> <span class="n">Pratica</span><span class="p">,</span> <span class="n">implementativa</span>        <span class="o">|</span>
<span class="o">|</span> <span class="n">Processi</span>         <span class="o">|</span> <span class="n">Astratti</span><span class="p">,</span> <span class="n">infiniti</span>       <span class="o">|</span> <span class="n">Goroutine</span><span class="p">,</span> <span class="n">mappate</span> <span class="n">su</span> <span class="n">thread</span>   <span class="o">|</span>
<span class="o">|</span> <span class="n">Verifica</span> <span class="n">formale</span> <span class="o">|</span> <span class="n">Centrale</span>                 <span class="o">|</span> <span class="n">Non</span> <span class="n">è</span> <span class="n">obiettivo</span> <span class="k">del</span> <span class="n">linguaggio</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Scopo</span>            <span class="o">|</span> <span class="n">Specifica</span> <span class="n">e</span> <span class="n">modellazione</span> <span class="o">|</span> <span class="n">Programmazione</span> <span class="n">applicativa</span>     <span class="o">|</span>
</pre></div>
</div>
<p>Go <strong>si ispira</strong> a CSP, ma <strong>non è una sua implementazione formale</strong>.</p>
<section id="go-routine-come-processi-csp">
<h4>Go-routine come “processi CSP”<a class="headerlink" href="#go-routine-come-processi-csp" title="Permalink to this heading">¶</a></h4>
<p>Le <strong>goroutine</strong> sono entità concorrenti leggere, analoghe ai <em>processi di CSP</em>:
indipendenti, sequenziali, comunicano tramite canali.</p>
<p>I canali di Go sono ispirati direttamente ai canali CSP</p>
<p>Nei canali Go:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ch</span> <span class="o">:=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>la comunicazione può essere <strong>bloccante</strong> (sincrona), come in CSP.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">x</span>   <span class="o">//</span> <span class="n">invio</span>
<span class="n">y</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span> <span class="o">//</span> <span class="n">ricezione</span>
</pre></div>
</div>
<p>Il completamento avviene solo quando entrambi sono pronti (<em>sincronizzazione implicita</em>, come in CSP).</p>
<p>Ma Go introduce una differenza importante: i canali <strong>possono essere bufferizzati</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Dunque in Go, la comunicazione può essere anche <em>asincrona</em>, quindi più flessibile.</p>
</section>
<section id="select">
<h4>Select<a class="headerlink" href="#select" title="Permalink to this heading">¶</a></h4>
<p>La Select di Go deriva dalla scelta esterna di CSP</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch1</span><span class="p">:</span>
      <span class="o">...</span>
  <span class="k">case</span> <span class="n">ch2</span> <span class="o">&lt;-</span> <span class="n">y</span><span class="p">:</span>
      <span class="o">...</span>
  <span class="n">default</span><span class="p">:</span>
      <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Questo è la versione di Go dell’operatore di <em>scelta esterna di CSP</em>.</p>
</section>
<section id="composizione-concorrente">
<h4>Composizione concorrente<a class="headerlink" href="#composizione-concorrente" title="Permalink to this heading">¶</a></h4>
<p>La frase CSP: <code class="docutils literal notranslate"><span class="pre">`P</span> <span class="pre">||</span> <span class="pre">Q`</span></code></p>
<p>diventa in Go:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">go</span> <span class="n">f</span><span class="p">()</span>   <span class="o">//</span> <span class="n">esegue</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">parallelo</span>
</pre></div>
</div>
<p>La concorrenza nasce dalla creazione di <em>goroutine</em> indipendenti.</p>
</section>
<section id="assenza-di-memoria-condivisa-esplicita">
<h4>Assenza di memoria condivisa “esplicita”<a class="headerlink" href="#assenza-di-memoria-condivisa-esplicita" title="Permalink to this heading">¶</a></h4>
<p>Go permette la memoria condivisa, ma lo <em>stile idiomatico</em> promuove il modello CSP:</p>
<ul class="simple">
<li><p>evitare il locking manuale</p></li>
<li><p>preferire canali ai mutex</p></li>
</ul>
</section>
</section>
</section>
<section id="modelli-e-linguaggi">
<h2>Modelli e linguaggi<a class="headerlink" href="#modelli-e-linguaggi" title="Permalink to this heading">¶</a></h2>
<p>Un modello formale fonda la potenza espressiva, mentre
il linguaggio di programmazione governa l’uso pratico di tale potenza.</p>
<p>La storia rende evidente che a un singolo modello corrispondono di fatto molti linguaggi, ciascuno diverso
per architettura e filosofia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Si pensi ad esempio al <span class="math notranslate nohighlight">\(\lambda\)</span>-calcolo e ai linguaggi <code class="docutils literal notranslate"><span class="pre">Lisp,</span> <span class="pre">Scheme,</span> <span class="pre">ML,</span> <span class="pre">Haskell,</span> <span class="pre">F\#,</span> <span class="pre">Scala,</span> <span class="pre">Clojure</span></code>, etc.</p>
</div>
<p>La proliferazione segue spesso l’emergere di nuovi problemi e ogni linguaggio ‘congela’ una visione del mondo
e una <em>teoria implicita</em> del sistema che si vuole costruire.</p>
<p>I modelli formali delimitano ciò che è possibile; ma i linguaggi di programmazione proliferano perché ogni epoca,
dominio e comunità ha bisogno di un modo diverso per rendere quel possibile effettivamente costruibile.</p>
<p>E’ quindi il momento di esplorare più da vicino il mondo dei linguaggi.</p>
</section>
</section>
<section id="i-linguaggi">
<h1>I linguaggi<a class="headerlink" href="#i-linguaggi" title="Permalink to this heading">¶</a></h1>
<p>E’ importante avere chiara la distinzione tra <em>linguaggio naturale</em> e <em>linguaggio di programmazione</em>
e il ruolo che questo può avere nella definizione e costruzione di oggetti e ‘sistemi artificiali’.</p>
<section id="linguaggi-naturali">
<h2>Linguaggi naturali<a class="headerlink" href="#linguaggi-naturali" title="Permalink to this heading">¶</a></h2>
<p>Il linguaggio naturale (<strong>LN</strong>) come l’italiano, l’inglese, ecc. è lo strumento primario
degli esseri umani per interagire con il mondo e per <em>categorizzarlo</em>.
Il suo ruolo non è solo descrittivo, ma anche costitutivo e sociale, in quanto
un <code class="docutils literal notranslate"><span class="pre">LN</span></code> non è un semplice specchio che riflette oggetti esistenti.</p>
<p>Un <code class="docutils literal notranslate"><span class="pre">LN</span></code> è piuttosto un filtro categoriale che organizza e rende gestibile un flusso continuo di percezioni.
Le impostazioni filosofiche estreme suggeriscono che l’esistenza degli “oggetti” come li conosciamo
(con i loro confini e le loro identità) è un prodotto di questo filtro linguistico.
In questa visione, gli oggetti non esistono “in sé” ma solo come costrutti mentali e si pone il problema di
cosa sia “reale”.</p>
<p>Nonostante la sua potenza, il linguaggio naturale presenta alcune caratteristiche limitative:</p>
<ol class="arabic simple">
<li><p><strong>Vaghezza e Ambiguità</strong>: Molte parole hanno confini sfocati (<em>fuzzy boundaries</em>).
Non esiste un confine netto che determini, ad esempio, quando un “cespuglio” diventi un “albero”
o quando un “sasso” sia abbastanza grande da essere chiamato “roccia”. Questo è il limite della precisione.</p></li>
<li><p><strong>Dipendenza dal Contesto</strong>: La descrizione di un oggetto è sempre incompleta e dipendente dal contesto.
Descrivere un “tavolo” in fisica richiede la massa e la composizione molecolare;
descriverlo in un negozio di mobili richiede lo stile e il prezzo. Nessuna descrizione è totale.</p></li>
<li><p><strong>Problema del Riferimento</strong>: Il linguaggio non può esaurire tutte
le proprietà di un oggetto. Possiamo solo riferirci a un sottoinsieme di proprietà (<strong>l’intensione</strong>)
per identificare la collezione di oggetti (<strong>l’estensione</strong>).</p></li>
</ol>
<p>Gli oggetti reali (<strong>things-in-themselves</strong>) possono esistere fisicamente (cioè, esistono atomi e onde),
ma la loro divisione in categorie discrete e utilizzabili (es. “pianta”, “bottiglia”, “confine”, “matrimonio”)
è un atto imposto dal linguaggio e dalla cultura.</p>
<p>Per molti, non c’è un modo “oggettivo” di dividere il mondo in oggetti.
L’atto di riferimento linguistico a un oggetto è sempre vincolato al sistema linguistico e concettuale
che stiamo usando (la cosiddetta <em>underdetermination of reference</em> del filosofo  <a class="reference external" href="https://it.wikipedia.org/wiki/Willard_Van_Orman_Quine">Willard Van Orman Quine</a>).</p>
<p>In ogni caso, diverse evidenze empiriche indicano che
un <code class="docutils literal notranslate"><span class="pre">LN</span></code> influenza o orienta l’attenzione e la cognizione, rendendo più facile o frequente pensare in certi modi.
Ad esempio, il linguaggio fornisce le categorie che gli umani usano
per interpretare e comunicare la realtà dello spazio e del tempo e queste sono diverse in
contesti culturali diversi (<a class="reference external" href="https://it.wikipedia.org/wiki/Ipotesi_di_Sapir-Whorf">Ipotesi Sapir-Whorf</a>).</p>
<p>Tuttavia, l’ambiguità delle frasi dei linguaggi naturali
(ad esempio: <em>“Ho visto un uomo su una pianta col cannocchiale”</em>)
sono caratteristiche intrinseche e necessarie per la flessibilità e l’espressione umana
e può anche essere vista come un vantaggio:</p>
<ol class="arabic simple">
<li><p><strong>Efficienza e Velocità di Trasmissione</strong>. utilizzando la conoscenza condivisa e il contesto.</p></li>
<li><p><strong>Creatività, Espressione Artistica e Ironia</strong>. Nuovi significati e usi delle parole emergono
proprio grazie alla loro flessibilità e ambiguità, consentendo al linguaggio di evolvere
per adattarsi a nuove realtà sociali e tecnologiche.</p></li>
<li><p><strong>Flessibilità e Adattabilità Sociale</strong>.</p>
<ul class="simple">
<li><p>Mantenere relazioni positive, di negoziare o di evitare il conflitto.</p></li>
<li><p>Identificazione del Contesto (Pragmatica): L’ambiguità ci costringe a interagire
con l’ambiente e con l’altro per risolverla.</p></li>
<li><p>Il processo di disambiguazione contestuale è una funzione cruciale della nostra
intelligenza e della nostra capacità di adattarci a situazioni diverse.</p></li>
</ul>
</li>
</ol>
</section>
<section id="i-large-language-models">
<h2>I Large Language Models<a class="headerlink" href="#i-large-language-models" title="Permalink to this heading">¶</a></h2>
<p>Gli ormai onnipresenti <strong>Large Language Models</strong> (<strong>LLM</strong>) si fondano su concetti di statistica e probabilità
applicate al linguaggio naturale.</p>
<p>Un <strong>LLM</strong> è una rete neurale trasformatrice (<strong>Transformer</strong>), addestrata su miliardi di parole e testi
provenienti da Internet, libri e altre fonti.</p>
<p>Il modello non lavora su singole lettere o parole intere, ma su <strong>token</strong>
(una parola intera, una parte di una parola, un segno di punteggiatura o uno spazio).</p>
<p>Quando il modello elabora un <em>token</em> nel <strong>prompt</strong> dato in input dall’utente, non lo guarda isolatamente,
ma valuta quanto sono importanti tutti gli altri token nel prompt per “dare significato” al token corrente.
Questo modo di procedere è denominato <strong>attenzione</strong> e costruisce una
rappresentazione numerica finale del prompt che include il contesto e l’importanza di ogni parte
del testo di input.</p>
<p>L’ultima rappresentazione numerica del prompt funge da stato iniziale.
A partire da questo stato, il modello fa una <strong>previsione del token successivo</strong>
utilizzando una tecnica chiamata campionamento stocastico o <strong>sampling</strong>
(spesso controllato da un parametro denominato <strong>Temperatura</strong>).</p>
<p>Il processo si ripete, ma questa volta, il nuovo input per la previsione successiva è
l’intero prompt più il token appena generato.</p>
<p>Con questo modo di procedere, un <strong>LLM</strong> non “capisce” nel senso umano.
Il suo successo deriva dalla sua capacità di:</p>
<ul class="simple">
<li><p><strong>Imitare la Sintassi e la Semantica del Testo Umano</strong>: Avendo analizzato enormi quantità di testo,
ha imparato quali sequenze di parole sono statisticamente coerenti e significative.</p></li>
<li><p><strong>Mantenere il Contesto</strong>: Grazie al meccanismo di attenzione, ogni token generato è coerente
non solo con l’ultima parola, ma con l’intero contesto del prompt e della conversazione precedente.</p></li>
</ul>
</section>
<section id="linguaggi-di-programmazione">
<span id="id34"></span><h2>Linguaggi di programmazione<a class="headerlink" href="#linguaggi-di-programmazione" title="Permalink to this heading">¶</a></h2>
<p>I linguaggi di programmazione (<strong>LdP</strong>) sono costruiti per essere l’esatto opposto dei linguaggi naturali
in termini di precisione e ambiguità.</p>
<p>Questi linguaggi ‘artificiali’ non si preoccupano di come l’essere umano percepisce il mondo esterno.
La loro <a class="reference external" href="https://it.wikipedia.org/wiki/Ontologia">ontologia</a> (gli oggetti che esistono) è definita esplicitamente dal programmatore:</p>
<ul class="simple">
<li><p>Gli oggetti sono tipi di dati (<code class="docutils literal notranslate"><span class="pre">Int,</span> <span class="pre">String,</span> <span class="pre">Person</span></code>).</p></li>
<li><p>Lo spazio e il tempo sono gestiti da astrazioni matematiche precise (indirizzi di memoria, timestamp, cicli di CPU).</p></li>
<li><p>Non c’è spazio per la “percezione” individuale dei concetti.</p></li>
</ul>
<p>Se si usa un <code class="docutils literal notranslate"><span class="pre">LdP</span></code>, l’hardware sottostante (il <em>computer</em>) esegue la logica allo stesso modo;
ciò che cambia è l’efficienza e la facilità con cui l’umano esprime quella logica nel linguaggio usato.</p>
<section id="una-frase-misteriosa">
<h3>Una frase misteriosa<a class="headerlink" href="#una-frase-misteriosa" title="Permalink to this heading">¶</a></h3>
<p>Supponiamo che un esploratore abbia trovato una incisione rupestre che si presenta come segue:</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/FraseEnigmatica.jpg"><img alt="_images/FraseEnigmatica.jpg" class="align-center" src="_images/FraseEnigmatica.jpg" style="width: 60%;" /></a>
</div></blockquote>
<p>Cosa dovrà fare l’esploratore per comprenderne il significato? Certo dovrà occuparsi di sintassi e di semantica.</p>
</section>
<section id="sintassi-e-semantica">
<span id="id35"></span><h3>Sintassi e semantica<a class="headerlink" href="#sintassi-e-semantica" title="Permalink to this heading">¶</a></h3>
<p>Ogni frase di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> ubbidisce a una precisa sintassi, espressa da regole definite
con notazioni formali.</p>
<p>La frase di un LdP ha sempre una interpretazione univoca che permette al computer di
<strong>agire</strong> in un unico modo: questo modo di agire costituisce la <strong>semantica</strong> della frase.</p>
<ul class="simple">
<li><p><strong>Sintassi</strong>: Riguarda le regole strutturali che definiscono se una frase è legalmente formata
(es. le parentesi sono bilanciate? I punti e virgola sono al posto giusto?).
Se una frase non rispetta la sintassi, è un errore e il computer non può agire.</p></li>
<li><p><strong>Semantica</strong>: Riguarda il significato della frase sintatticamente corretta e le azioni che ne derivano.
La semantica è, in sostanza, la descrizione rigorosa e formale dell’effetto che l’esecuzione di una frase
ha sullo stato della macchina.</p></li>
</ul>
</section>
<section id="linguaggi-per-descrivere-linguaggi">
<span id="id36"></span><h3>Linguaggi per descrivere linguaggi<a class="headerlink" href="#linguaggi-per-descrivere-linguaggi" title="Permalink to this heading">¶</a></h3>
<p>C’è una connessione fondamentale tra linguaggi, macchine e la necessità di
notazioni formali per definire e studiare i linguaggi in modo non ambiguo.</p>
<p>Un <strong>computer</strong> è un sistema fisico. Ogni istruzione di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> si traduce in una serie di transizioni
di stato all’interno di circuiti e memoria.
Il <strong>linguaggio macchina</strong> di un computer è direttamente
<strong>interpretabile</strong> dalla CPU. Tutto il codice di alto livello deve essere ricondotto
a questo linguaggio di basso livello per l’esecuzione.</p>
<p>Prima che il computer possa eseguire le frasi di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code>, deve <strong>riconoscere</strong> tali frasi (fare il <strong>parsing</strong>)
cioè  determinare se la frase costituisce una sequenza di simboli valida di quel linguaggio.</p>
<p>Per descrivere le forme lecite assumbili dalle frasi di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> (<strong>sintassi</strong>) si usano
notazioni (dunque ulteriori linguaggi) dette <strong>Grammatiche Formali</strong> costituite da un
sistema di regole  che delineano matematicamente un insieme (di solito infinito)
di sequenze finite di simboli (<em>stringhe</em>) appartenenti ad un <a href="#id37"><span class="problematic" id="id38">*</span></a>alfabeto- anch’esso finito.</p>
<section id="macchine-astratte-per-riconoscere-linguaggi">
<span id="id39"></span><h4>Macchine astratte per riconoscere linguaggi<a class="headerlink" href="#macchine-astratte-per-riconoscere-linguaggi" title="Permalink to this heading">¶</a></h4>
<p>La <a class="reference external" href="https://it.wikipedia.org/wiki/Gerarchia_di_Chomsky">Gerarchia di Chomsky</a> è un insieme di classi di grammatiche formali che generano linguaggi formali.
Un concetto fondamentale nell’informatica teorica
è la corrispondenza tra la <strong>Gerarchia di Chomsky</strong>   e
una <strong>Gerarchia di Macchine Astratte</strong> in grado di riconoscere i linguaggi.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In informatica, una <a class="reference external" href="https://it.wikipedia.org/wiki/Macchina_astratta">Macchina astratta</a> è un modello teorico di sistema computazionale.</p>
<p>La corrispondeza tra tipi di grammatiche e macchine astratte in grado di riconescere
i linguaggi generati può essere riassunta come segue:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 15%" />
<col style="width: 25%" />
<col style="width: 40%" />
<col style="width: 20%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Tipo di Chomsky</strong></p></td>
<td><p><strong>Nome Grammatica</strong></p></td>
<td><p><strong>Macchina Astratta</strong></p></td>
<td><p><strong>Complessità di Riconoscimento</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Tipo0</strong></p></td>
<td><p>Unrestricted</p></td>
<td><p>Macchina di Turing</p></td>
<td><p>Indecidibile</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Tipo1</strong></p></td>
<td><p>Context-Sensitive</p></td>
<td><p>Macchina di Turing Limitata Linearmente (LBA)</p></td>
<td><p>Decidibile</p></td>
</tr>
<tr class="row-even"><td><p><strong>Tipo2</strong></p></td>
<td><p><strong>Context-Free</strong></p></td>
<td><p>Automa a Pila (Pushdown Automaton, PDA)</p></td>
<td><p>Decidibile, Tempo Polinomiale</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Tipo3</strong></p></td>
<td><p><strong>Regular</strong></p></td>
<td><p>Automa a Stati Finiti (Finite Automaton, FA)</p></td>
<td><p>Decidibile, Tempo Lineare</p></td>
</tr>
</tbody>
</table>
</div>
<p>Il riconoscimento delle frasi di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> deve avvenire rapidamente.
Quindi la sintassi di tutti gli <code class="docutils literal notranslate"><span class="pre">LdP</span></code> oggi uso è descritta grammatiche <strong>Context-Free</strong> o <strong>Regular</strong>.</p>
</section>
</section>
<section id="la-analisi-sintattica">
<h3>La analisi sintattica<a class="headerlink" href="#la-analisi-sintattica" title="Permalink to this heading">¶</a></h3>
<p>Le <strong>grammatiche formali</strong> definiscono in modo non ambiguo e matematicamente rigoroso quali sequenze di simboli
(parole chiave, identificatori, operatori, ecc.) costituiscono un programma sintatticamente corretto.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>La notazione più fondamentale è la <em>Forma di Backus-Naur</em> (<strong>BNF</strong>) e la <em>BNF Estesa</em> (<strong>EBNF</strong>).
Questa notazione definisce la sintassi attraverso un insieme di regole di produzione. Ad esempio</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">assegnazione</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">variabile</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">espressione</span><span class="o">&gt;</span> <span class="p">;</span>
<span class="o">&lt;</span><span class="n">espressione</span><span class="o">&gt;</span>  <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">termine</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">espressione</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">&lt;</span><span class="n">termine</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Le grammatiche sono essenziali per la costruzione dei traduttori (<strong>compilatori</strong> e <strong>interpreti</strong>):</p>
<ul class="simple">
<li><p><em>Analisi Lessicale</em> (<strong>Lexing</strong>): Il testo viene scomposto in <strong>token</strong> (simboli terminali).</p></li>
<li><p><em>Analisi Sintattica</em> (<strong>Parsing</strong>): Il <em>parser</em> utilizza le regole della grammatica
per verificare se la sequenza di <em>token</em> è strutturalmente corretta.
Se le regole vengono soddisfatte, il parser costruisce un
<strong>Albero Sintattico Astratto</strong> (<strong>AST</strong>), che è la rappresentazione strutturata del codice
che verrà poi usata per definire la semantica (il significato e l’azione) del programma.</p></li>
</ul>
</div>
<p>Sono stati creati tool che generano automaticamente un <em>parser</em> partendo dalla specifica
di un linguaggio di programmazione descritta con la <strong>BNF</strong>, ad esempio <strong>Yacc</strong>
(<em>Yet Another Compiler Compiler</em>).</p>
</section>
<section id="descrivere-la-semantica">
<h3>Descrivere la semantica<a class="headerlink" href="#descrivere-la-semantica" title="Permalink to this heading">¶</a></h3>
<p>Si distinguono diversi tipi di semantica formale, ciascuno con i suoi metodi e applicazioni specifiche.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>La semantica operazionale (<strong>Operational Semantics</strong>) definisce il significato di un programma descrivendo come viene eseguito.
L’attenzione è posta sui passaggi elementari di calcolo che un’istruzione innesca.</p>
<ul class="simple">
<li><p><em>Formalismo Principale</em>: Regole di transizione.</p></li>
<li><p><em>Utilità principale</em>:  Progettazione di interpreti e macchine virtuali</p></li>
</ul>
<p>La semantica denotazionale (<strong>Denotational Semantics</strong>) definisce il significato di un programma associando (o “denotando”)
a ogni costrutto una funzione matematica pura.</p>
<ul class="simple">
<li><p><em>Formalismo Principale</em>: Teoria dei Domini e Punti Fissi (Fixed Points).</p></li>
<li><p><em>Utilità principale</em>: Dimostrazione di equivalenza tra programmi</p></li>
</ul>
<p>La semantica assiomatica (<strong>Axiomatic semantics</strong>) definisce il significato di un programma specificando le proprietà logiche che devono
essere vere prima e dopo l’esecuzione dell’istruzione.</p>
<ul class="simple">
<li><p><em>Formalismo Principale</em>: La Logica di Tony Hoare.</p></li>
<li><p><em>Utilità principale</em>: Verifica e validazione di programmi</p></li>
</ul>
</div>
<p>Il tipo di semantica più utilizzato nella pratica ingegneristica e didattica della programmazione è la
<strong>Semantica Operazionale</strong>, per i seguenti motivi:</p>
<ol class="arabic simple">
<li><p><strong>Corrispondenza Diretta con l’Implementazione</strong>: Le regole della semantica operazionale
(es. “Quando incontri un’istruzione IF, valuta prima la condizione, se è vera esegui il blocco ‘then’,
altrimenti il blocco ‘else’”) sono quasi un blueprint diretto per l’implementazione di un interprete
o di un compilatore. È la forma più vicina a come una macchina esegue i calcoli.</p></li>
<li><p><strong>Facilità di Comprensione e Debug</strong>: I programmatori sono abituati a tracciare l’esecuzione del codice passo dopo passo,
proprio come farebbe un debugger. La semantica operazionale formalizza questa tracciabilità,
rendendo intuitivo capire cosa accadrà ad ogni istruzione.</p></li>
<li><p><strong>Definizione di Standard</strong>: Molte specifiche di linguaggi di programmazione, come C, C++, e Java
(in termini di esecuzione della Java Virtual Machine o JVM), si basano implicitamente o esplicitamente
su un modello operazionale per definire il comportamento del linguaggio in vari scenari.</p></li>
</ol>
</section>
</section>
<section id="compilatori-e-interpreti">
<h2>Compilatori e interpreti<a class="headerlink" href="#compilatori-e-interpreti" title="Permalink to this heading">¶</a></h2>
<p>Un <strong>compilatore</strong> è un programma che traduce l’intero codice sorgente di un LdP ad alto livello in un
programma equivalente in linguaggio macchina (o in un formato eseguibile intermedio),
prima della sua esecuzione.</p>
<p>Un <strong>interprete</strong> è un programma che esegue direttamente il codice sorgente istruzione per istruzione,
traducendo e valutando le frasi  una dopo l’altra.</p>
<p>Molti LdP usano approcci ibridi, come:</p>
<ul class="simple">
<li><p>Java → compilazione in bytecode + interpretazione/ottimizzazione <strong>JIT</strong> (<em>Just-In-Time Compilation</em>)</p></li>
<li><p>Python → bytecode + interprete (CPython)</p></li>
<li><p>JavaScript → interprete + compilazione dinamica <strong>JIT</strong> nei browser</p></li>
</ul>
</section>
<section id="general-processing-programming-languages">
<span id="id40"></span><h2>General Processing Programming Languages<a class="headerlink" href="#general-processing-programming-languages" title="Permalink to this heading">¶</a></h2>
<p>Il numero totale di linguaggi di programmazione (inclusi linguaggi esoterici, accademici e non più in uso)
è stimato in circa <code class="docutils literal notranslate"><span class="pre">2500</span></code>.</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>.</p>
<a class="reference internal image-reference" href="_images/historyHLPL.PNG"><img alt="_images/historyHLPL.PNG" class="align-center" src="_images/historyHLPL.PNG" style="width: 100%;" /></a>
</td>
<td><p>La figura  mostra una visione sintetica dello sviluppo nel tempo di questa evoluzione linguistica,
con riferimento ad alcuni dei linguaggi più noti.</p>
<p>—</p>
<p>L’avvento della programmazione ad oggetti sembra avere segnato il culmine di questo processo;
un motivo può certo essere il raggiungimento di una sufficiente maturità nella capacità espressiva
in ciascuna delle <a class="reference internal" href="#dimensioni"><span class="std std-ref">Dimensioni</span></a> in cui si articola la struttura interna di un sistema.</p>
</td>
</tr>
</tbody>
</table>
<p>Tuttavia, il numero di Linguaggi di Programmazione Generale (<strong>GPL</strong>) attivamente utilizzati in
ambiente industriale è molto più limitato,
probabilmente tra <code class="docutils literal notranslate"><span class="pre">20</span></code> e <code class="docutils literal notranslate"><span class="pre">50</span></code>. Solo una decina di questi domina oltre l’<code class="docutils literal notranslate"><span class="pre">80%</span></code> del mercato dello sviluppo;
tra essi vi sono:</p>
<p><strong>Python, Java, Javascript, C, C++, C#, TypeScript, GO</strong></p>
<p>Questi <code class="docutils literal notranslate"><span class="pre">GPL</span></code> sono quasi sempre utilizzati
in combinazione con <strong>framework</strong> e <strong>librerie</strong> che non solo forniscono funzionalità/utlilità
ma che possono anche alzare il livello di astrazione.
Doiscutermeo questo aspetto più avanti, nella sezione <a class="reference internal" href="#l-astrazione"><span class="std std-ref">L’astrazione</span></a>.</p>
<section id="stili-paradigni-di-programmazione">
<h3>Stili (paradigni) di programmazione<a class="headerlink" href="#stili-paradigni-di-programmazione" title="Permalink to this heading">¶</a></h3>
<p>I linguaggi di programmazione possono essere raggruppati in stili o paradigmi,
che definiscono il <strong>modo concettuale</strong> in cui si struttura un programma per risolvere un problema.</p>
<section id="paradigma-imperativo">
<h4>Paradigma Imperativo<a class="headerlink" href="#paradigma-imperativo" title="Permalink to this heading">¶</a></h4>
<p>Il paradigma imperativo si concentra sul come un programma debba operare. Si basa sul concetto di <strong>stato</strong> e
su istruzioni (o comandi) che modificano sequenzialmente tale stato (variabili, memoria).
Il codice descrive una serie di <strong>azioni esplicite</strong> che il computer deve eseguire.</p>
<p>Come Linguaggio Rappresentativo possiamo citare il <strong>C</strong>.</p>
<dl class="simple">
<dt><strong>Caratteristiche:</strong></dt><dd><ul class="simple">
<li><p><strong>Stato Mutabile:</strong> Le variabili possono essere modificate.</p></li>
<li><p><strong>Flusso di Controllo:</strong> Utilizzo massiccio di costrutti come <em>if/else</em>, <em>for</em>, <em>while</em>, ….</p></li>
<li><p><strong>Procedure/Funzioni:</strong> Raggruppano istruzioni per il riutilizzo.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="paradigma-orientato-agli-oggetti-oop">
<span id="id41"></span><h4>Paradigma Orientato agli Oggetti (OOP)<a class="headerlink" href="#paradigma-orientato-agli-oggetti-oop" title="Permalink to this heading">¶</a></h4>
<p>Derivato dal paradigma imperativo, l’Object Oriented Programming (<strong>OOP</strong>) organizza il software attorno a <strong>oggetti</strong>,
che combinano <strong>dati</strong> (attributi)
e le <strong>funzioni</strong> (metodi) che operano su quei dati. L’obiettivo è modellare entità del mondo reale.</p>
<p>Come Linguaggio Rappresentativo possiamo citare il <strong>C++</strong> o <strong>Java</strong>.</p>
<dl class="simple">
<dt><strong>Caratteristiche:</strong></dt><dd><ul class="simple">
<li><p><strong>Inscapsulamento</strong> (Encapsulation): Raggruppamento di dati e metodi che operano su di essi.</p></li>
<li><p><strong>Ereditarietà</strong> (Inheritance):  Le nuove classi ereditano le proprietà delle classi esistenti.</p></li>
<li><p><strong>Polimorfismo</strong> (Polymorphism):  Oggetti diversi possono rispondere allo stesso input in modi diversi.</p></li>
<li><p><strong>Astrazione</strong> (Abstraction):  Nascondere la complessità implementativa all’utente.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="paradigma-funzionale-fp">
<h4>Paradigma Funzionale (FP)<a class="headerlink" href="#paradigma-funzionale-fp" title="Permalink to this heading">¶</a></h4>
<p>Il paradigma funzionale tratta il calcolo come la valutazione di <strong>funzioni matematiche</strong>
(non nel senso di procedure imperative). Si concentra sul <strong>cosa</strong> calcolare, evitando cambiamenti
di stato e dati mutabili. Promuove l’uso di <strong>funzioni pure</strong>.</p>
<p>Come Linguaggio Rappresentativo possiamo citare il <strong>Lisp/Scheme</strong> o <strong>Haskell</strong>.</p>
<dl class="simple">
<dt><strong>Caratteristiche:</strong></dt><dd><ul class="simple">
<li><p><strong>Immutabilità:</strong> I dati non cambiano una volta creati.</p></li>
<li><p><strong>Funzioni Pure:</strong> Una funzione restituisce sempre lo stesso output per lo stesso input e non produce effetti collaterali (non modifica lo stato esterno).</p></li>
<li><p><strong>Funzioni di Ordine Superiore:</strong> Funzioni che accettano altre funzioni come argomenti o le restituiscono come risultato.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="paradigma-logico-dichiarativo">
<h4>Paradigma Logico (Dichiarativo)<a class="headerlink" href="#paradigma-logico-dichiarativo" title="Permalink to this heading">¶</a></h4>
<p>Questo paradigma si basa sulla <strong>logica formale</strong>. Il programmatore <strong>non</strong> specifica
<em>come</em> trovare la soluzione, ma descrive il problema in termini di <strong>fatti</strong> e <strong>regole</strong>.
Il motore di esecuzione (l’interprete <em>risolutore</em>) cerca le risposte che soddisfano queste regole.</p>
<p>Come Linguaggio Rappresentativo possiamo citare il <strong>Prolog</strong></p>
<dl class="simple">
<dt><strong>Caratteristiche:</strong></dt><dd><ul class="simple">
<li><p><strong>Asserzioni (Facts):</strong> Dichiarazioni vere sul dominio del problema.</p></li>
<li><p><strong>Regole (Rules):</strong> Definizioni di nuove verità basate su fatti esistenti.</p></li>
<li><p><strong>Query:</strong> Domande poste al sistema per dedurre nuove informazioni.</p></li>
<li><p><strong>Backtracking:</strong> Il meccanismo di ricerca automatico per trovare le soluzioni.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Molti linguaggi moderni (come <em>Python, JavaScript e Scala</em>) sono <strong>multi-paradigma</strong>,
supportando elementi di imperativo, OOP e funzionale.</p>
</div>
</section>
</section>
</section>
<section id="gli-attori-come-nuovo-paradigma">
<span id="id42"></span><h2>Gli attori come nuovo paradigma?<a class="headerlink" href="#gli-attori-come-nuovo-paradigma" title="Permalink to this heading">¶</a></h2>
<p>L’<strong>Actor Model</strong>, ideato da <em>Carl Hewitt</em> nel <code class="docutils literal notranslate"><span class="pre">1973</span></code> e reso popolare da linguaggi come <strong>Erlang</strong> e
framework come <strong>Akka</strong> (implementato in <em>Scala</em> e <em>Java</em>), offre una filosofia di calcolo
che molti vedono come un nuovo stile di programmazione per l’era del multicore e del cloud.</p>
<p>Il focus non è più su cosa fare (Funzionale) o come cambiare lo stato (Imperativo),
ma su come le entità computazionali (Attori) interagiscono
in un ambiente massivamente concorrente e potenzialmente fallibile.</p>
<p>In un modello computazionale ad attori, la priorità è la comunicazione e la gestione dei messaggi.</p>
<ul class="simple">
<li><p><strong>Inscapsulamento Forte e Isolamento</strong>
Ogni Attore è un’entità completamente
incapsulata. È “strutturalmente” un contenitore di stato e comportamento, ma il suo stato
è rigorosamente isolato. Questo significa che la struttura interna di un Attore
non è visibile o accessibile all’esterno. L’unico modo per interagire è attraverso
l’invio di messaggi asincroni.</p></li>
<li><p><strong>Il Messaggio come contratto</strong>
L’attenzione si sposta sulla definizione dei messaggi
che verranno scambiati. Questi messaggi definiscono l’interfaccia pubblica e
il contratto di <strong>interazione</strong> tra gli Attori. La logica del sistema diventa una complessa
rete di conversazioni e risposte a messaggi, piuttosto che una gerarchia di chiamate a metodi sincroni.</p></li>
<li><p><strong>Concorrenza per Composizione</strong>
Invece di preoccuparsi di <em>Lock</em> e <em>Thread</em> per gestire la concorrenza all’interno
di un singolo componente  ci si concentra su come comporre Attori indipendenti
che lavorano in parallelo e coordinano il loro lavoro tramite lo scambio di messaggi.</p></li>
</ul>
<p>Un linguaggio come <strong>Akka</strong> non solo sposta il focus sull’interazione, ma fornisce anche gli strumenti e i
modelli comportamentali intrinseci (isolamento, asincronicità, supervisione) che risolvono
le sfide più difficili della creazione di moderni  <a class="reference external" href="https://en.wikipedia.org/wiki/Microservices">Microservizi</a> resilienti e scalabili.</p>
</section>
<section id="non-determinismo">
<h2>Non determinismo<a class="headerlink" href="#non-determinismo" title="Permalink to this heading">¶</a></h2>
<p>Se una qualche frase di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> induce un computer ad agire in due o più modi
diversi, si ha una esecuzione non deterministica.</p>
<p>Esempi di forme di non determinsimo si hanno:</p>
<ul>
<li><p><a class="reference external" href="https://it.wikipedia.org/wiki/Edsger_Dijkstra">Edsger Dijkstra</a> ha definito un costrutto teorico che introduce la <strong>scelta non-deterministica</strong>
(usato per prove formali di correttezza)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">C1</span> <span class="o">-&gt;</span> <span class="n">S1</span> <span class="p">[]</span> <span class="n">C2</span> <span class="o">-&gt;</span> <span class="n">S2</span> <span class="n">fi</span><span class="o">.</span>
</pre></div>
</div>
<p>Se entrambe le condizioni (<code class="docutils literal notranslate"><span class="pre">C_1</span></code> e <code class="docutils literal notranslate"><span class="pre">C_2</span></code>) sono vere, il sistema sceglie non deterministicamente
se eseguire <code class="docutils literal notranslate"><span class="pre">S_1</span></code> o <code class="docutils literal notranslate"><span class="pre">S_2</span></code>.</p>
</li>
<li><p>in <strong>Prolog</strong>: La semantica di Prolog non specifica l’ordine in cui il motore di inferenza
deve provare le regole o i fatti per soddisfare un goal.
Il motore sceglie non deterministicamente (anche se le implementazioni reali seguono un ordine predefinito)
un percorso, e se fallisce, “torna indietro” (<strong>backtracking</strong>) e prova un’alternativa.</p></li>
<li><p>In <strong>Akka</strong>: L’ordine in cui gli attori ricevono i messaggi e l’esatto momento in cui elaborano i messaggi
è non-deterministico.</p>
<p>Ad esempio, se l’Actor <code class="docutils literal notranslate"><span class="pre">A</span></code> invia due messaggi all’Actor <code class="docutils literal notranslate"><span class="pre">B</span></code>, non c’è garanzia
che <code class="docutils literal notranslate"><span class="pre">B</span></code> elabori il Messaggio <code class="docutils literal notranslate"><span class="pre">1</span></code> prima del Messaggio <code class="docutils literal notranslate"><span class="pre">2</span></code> se c’è traffico di rete o ritardi.
Questo non-determinismo può essere visto come un forza del modello, poiché costringe gli sviluppatori a scrivere
codice resiliente a qualsiasi temporizzazione.</p>
</li>
</ul>
</section>
<section id="influenza-di-un-ldp-sul-progettista-del-software">
<h2>Influenza di un LdP sul progettista del software<a class="headerlink" href="#influenza-di-un-ldp-sul-progettista-del-software" title="Permalink to this heading">¶</a></h2>
<p>Come già evidenziato da <a class="reference internal" href="#il-motto-di-alan-kay"><span class="std std-ref">Il motto di Alan Kay</span></a>, la struttura di un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> può influenzare
notevolmente il modo in cui il programmatore modella e
risolve un problema. Ad esempio:</p>
<ul class="simple">
<li><p><strong>Prolog</strong> (Logico): Incoraggia a pensare in termini di fatti e regole di deduzione, costringendo
il programmatore a definire cosa è vero.</p></li>
<li><p><strong>Java/C++</strong> (OOP): Incoraggia a modellare il mondo in termini di oggetti, classi e relazioni gerarchiche.</p></li>
<li><p><strong>Lisp/Scala/Haskell</strong> (Funzionale): Incoraggia a pensare in termini di trasformazione di dati
immutabili e composizione di funzioni, riducendo gli effetti collaterali.</p></li>
<li><p><strong>Akka</strong> (Attori): Incoraggia a pensare a un sistema come una collezione di (Micro)servizi
che interagiscono usando Messaggi ed Eventi</p></li>
</ul>
<p>La scelta del linguaggio impone un modello mentale e un modello di oggetto specifico:</p>
<ul class="simple">
<li><p><strong>OOP</strong>: induce a pensare: “Quali entità esistono nel  sistema e quali azioni possono
eseguire su sé stesse?” Questo porta a un modello in cui lo stato (la realtà modellata)
è distribuito e potenzialmente volatile.</p></li>
<li><p><strong>FP</strong>: inducea pensare: “Quali trasformazioni (funzioni) devo applicare a un insieme di dati
immutabili per ottenere il risultato desiderato?”
Questo porta a un modello più robusto per la gestione della complessità e della concorrenza.</p></li>
<li><p><strong>Actor</strong>: inducea pensare: “Quali attori esistono nel sistema e quali messaggi
si devono scambiare e in quale modo?” Questo porta a un modello di sistema a (nano/micro)servizi
come avremo modo di approfondire in seguito.</p></li>
</ul>
<p>Il linguaggio non ha creato alcun oggetto reale,
ma la sua struttura ha creato la sua rappresentazione digitale (<em>Funzione, Classe, Actor</em>)
e ha dettato la logica di sistema (mutazione di stato vs. trasformazione pura vs. scambio di messaggi)
che il software seguirà.</p>
<p>In questo senso, un <code class="docutils literal notranslate"><span class="pre">LdP</span></code> <strong>orienta la soluzione architetturale</strong> che
il progettista sceglie per mappare un problema del mondo reale nella logica computazionale.</p>
</section>
<section id="l-astrazione">
<span id="id43"></span><h2>L’astrazione<a class="headerlink" href="#l-astrazione" title="Permalink to this heading">¶</a></h2>
<p>Un LdP crea i <strong>modelli di enti</strong> con cui la logica
del sistema opera.
Questa fase definisce il <strong>concetto di astrazione in informatica</strong> e la sua relazione con la realtà,
o, meglio, con l’insieme delle rappresentazioni umane del mondo perceptio come ‘reale’.</p>
<section id="realta-vs-modello">
<h3>Realtà vs. Modello<a class="headerlink" href="#realta-vs-modello" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>“Oggetti Reali” (Il <strong>Dominio del Problema</strong>): Sono le entità, i concetti e le interazioni che esistono
al di fuori del codice. Ad esempio, una persona, un conto bancario, un evento fisico
(come un click del mouse) o una transazione finanziaria.
Questi esistono indipendentemente dalla applicazione.</p></li>
<li><p>“Modelli di Oggetti” (Il <strong>Dominio della Soluzione</strong>): Sono le rappresentazioni, o astrazioni, di
quegli oggetti reali create all’interno del linguaggio di programmazione.</p></li>
</ul>
<p>Quando si utilizza la parola “automobile” nel linguaggio naturale, si evoca un’immagine vaga e ricca
di connotazioni. Quando si definisce una <code class="docutils literal notranslate"><span class="pre">Classe</span> <span class="pre">Automobile</span></code> in C++ o Java, si crea un modello preciso
che ha solo le proprietà (velocità, colore, motore) e i comportamenti (<em>accelera</em>, <em>frena</em>)
che sono stati esplicitamente codificati nel linguaggio.</p>
<ul class="simple">
<li><p>In C, un modello potrebbe essere la <em>struct</em> (struttura).</p></li>
<li><p>In C++, un modello può essere la <em>Classe automobile</em>.</p></li>
<li><p>In Prolog, fatti e le regole logiche definiscono le relazioni che coivolgono l’automobile.</p></li>
<li><p>In Akka, un modello potrebbe essere l’<em>Actor automobile</em> che differisce da tutti i precedenti
in quanto esprime l’automobile come un ente intrinsecamente attivo.</p></li>
</ul>
<p>In conclusione: <strong>la programmazione è un esercizio di modellazione</strong>.
I linguaggi di programmazione sono strumenti formali e rigorosi che permettono di creare
rappresentazioni manipolabili di entità per poter applicare una logica e risolvere un problema,
senza cadere nell’ambiguità o nella relatività del linguaggio umano.</p>
</section>
<section id="l-abstraction-gap">
<span id="id44"></span><h3>L’Abstraction gap<a class="headerlink" href="#l-abstraction-gap" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div></div></blockquote>
<p>L’<strong>Abstraction Gap</strong> (<em>Divario di Astrazione</em>) è la distanza concettuale tra:</p>
<ul>
<li><p>Il <strong>Dominio del Problema</strong>: I concetti, le regole e le entità come sono compresi e descritti dagli
esperti del dominio (es. un economista, un biologo, un esperto fiscale) usando il Linguaggio Naturale.</p>
<p><em>Esempio</em> in <code class="docutils literal notranslate"><span class="pre">LN</span></code>: “Ogni cliente della banca deve avere al più un conto corrente in rosso”.</p>
</li>
<li><p>Il <strong>Dominio della Soluzione</strong>: Il modo in cui tali concetti devono essere mappati in strutture,
tipi e logiche eseguibili nel <em>Linguaggio di Programmazione General Purpose</em>
(<span class="xref std std-ref">GPL</span>).</p>
<p><em>Esempio</em> in <code class="docutils literal notranslate"><span class="pre">LdP</span></code> (<em>Java/C++</em>): Il concetto di “Cliente della banca” può essere modellato come un <em>Actor</em>
che possiede uno o più (riferimenti a) <em>Oggetti</em> di classe <code class="docutils literal notranslate"><span class="pre">ContoCorrente</span></code>  oppure come una riga di
una tabella “Clienti” in un database relazionale in relazione con la tabella <code class="docutils literal notranslate"><span class="pre">ContoCorrente</span></code>
o in vari altri modi.</p>
</li>
</ul>
<section id="perche-esiste-l-abstraction-gap">
<h4>Perché esiste l’Abstraction Gap<a class="headerlink" href="#perche-esiste-l-abstraction-gap" title="Permalink to this heading">¶</a></h4>
<p>Nei GPL più comuni
<strong>non esistono</strong> tipi nativi come <em>Microservizio</em>, <em>ConttoCorrent</em>, <em>ContrattoAssicurativo</em>, o <em>EquazioneTermodinamica</em>.
Il programmatore deve tradurre manualmente il linguaggio del dominio nel linguaggio GPL,
un processo che richiede tempo, è soggetto a errori di interpretazione e
spesso diluisce l’intenzione originale del dominio.</p>
</section>
</section>
<section id="modelli-e-linguaggi-di-modellazione">
<span id="id45"></span><h3>Modelli e Linguaggi di modellazione<a class="headerlink" href="#modelli-e-linguaggi-di-modellazione" title="Permalink to this heading">¶</a></h3>
<p>Un <a class="reference external" href="https://it.wikipedia.org/wiki/Linguaggio_di_modellazione">Linguaggio di modellazione</a> è un <a class="reference external" href="https://it.wikipedia.org/wiki/Linguaggio_formale">Linguaggio formale</a>
che può essere utilizzato per descrivere (modellare) un sistema di qualche natura.</p>
<p>Nel linguaggio comune, il termine <cite>modello</cite> è spesso usato per denotare un’astrazione
di qualcosa che esiste nella realtà, come ad esempio il modello che posa per un artista,
una riproduzione in miniatura, un esempio di modo di svolgere un’attività, una forma
da cui ricavare vestiti, un ideale da seguire, etc..</p>
<p>Alcuni (tra cui gli ingegneri) intendono per modello un sistema matematico o fisico che ubbidisce
a specifici vincoli e che può essere utilizzato per descrivere e comprendere un sistema
(fisico, biologico, sociale, etc.) attraverso relazioni di analogia.</p>
<p><strong>Modello=rappresentazione dell’essenza di un sistema</strong></p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="_images/Modello.PNG"><img alt="_images/Modello.PNG" class="align-center" src="_images/Modello.PNG" style="width: 70%;" /></a>
</td>
<td><a class="reference internal image-reference" href="_images/ModelloNumeri.PNG"><img alt="_images/ModelloNumeri.PNG" class="align-center" src="_images/ModelloNumeri.PNG" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Nel concepire un modello come visione semplificata di un sistema software si assume che il sistema
abbia già una sua esistenza concreta.
In alcune fasi di lavoro (in particolare nella fase di analisi) il sistema è il modello;
un raffinamento o una variazione del modello corrisponde in questo caso ad una variazione del sistema.</p>
<p>La produzione esplicita di modelli si rivela utile in quanto i diversi attori di un processo
di produzione di software (committenti, analisti, progettisti, utenti, etc)
operano a diversi livelli di astrazione e con fini diversi.</p>
<p>Definendo opportuni modelli del sistema da realizzare, in ogni fase del processo di produzione
l’attenzione può essere focalizzata sugli aspetti rilevanti in quella fase, utilizzando una
forma di comunicazione comprensibile ad attori diversi.
Per garantire coesione e interoperabilità, si cerca di individuare regole di corrispondenza
e di trasformazione automatica tra modelli.</p>
</section>
<section id="uml">
<span id="id46"></span><h3>UML<a class="headerlink" href="#uml" title="Permalink to this heading">¶</a></h3>
<p>Il <a class="reference external" href="https://it.wikipedia.org/wiki/Unified_Modeling_Language">Linguaggio UML</a> (<em>Unified Modeling Language</em>) è un linguaggio di modellazione e di specifica
di sistemi software basato sul <a class="reference internal" href="#paradigma-orientato-agli-oggetti-oop"><span class="std std-ref">Paradigma Orientato agli Oggetti (OOP)</span></a>. Il linguaggio è definito in termini
di un <strong>linguaggio di meta-modellazione</strong> denominato <code class="docutils literal notranslate"><span class="pre">MOF</span></code> (si veda <a class="reference external" href="https://it.wikipedia.org/wiki/Meta-Object_Facility">Meta Object Facility</a>) .</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><a class="reference internal image-reference" href="_images/mofUml.PNG"><img alt="_images/mofUml.PNG" class="align-center" src="_images/mofUml.PNG" style="width: 100%;" /></a>
</td>
<td><p>La <a class="reference external" href="https://it.wikipedia.org/wiki/Meta-Object_Facility">Meta Object Facility</a> di <em>UML2</em> nella versione incorporata in Eclipse
è denominata <a class="reference external" href="https://wiki.eclipse.org/Ecore">Ecore</a>.</p></td>
</tr>
</tbody>
</table>
<p>Nel contesto dell’ingegneria del software, <code class="docutils literal notranslate"><span class="pre">UML</span></code> viene usato soprattutto per <strong>descrivere</strong>
il dominio applicativo
di un sistema software e/o il comportamento e la struttura del sistema stesso.</p>
<ul>
<li><p><strong>UML</strong> è nato per la documentazione e il disegno: è enorme, include diagrammi di stato,
di sequenza e molti concetti puramente grafici o metodologici.
È spesso “complicato” perché deve coprire ogni possibile scenario di progettazione.</p></li>
<li><p><strong>Ecore</strong> è nato per l’implementazione: è un sottoinsieme di UML
(spesso chiamato <strong>EMF - Essential MOF</strong>) ottimizzato per generare codice Java efficiente.
In pratica, Ecore è ciò che resta di UML quando si toglie tutto ciò che non serve a definire
strutture dati concrete.</p>
<p>Nel seguito, useremo <em>Ecore</em> per formalizzare la struttura di un nostro linguaggio
di modellazione ‘custom’: <span class="xref std std-ref">Il linguaggio qak</span>.</p>
</li>
</ul>
<p>Il modello è strutturato secondo un <strong>insieme di viste</strong> che rappresentano diversi aspetti della cosa modellata
(funzionamento, struttura, comportamento e così via), a scopo sia di analisi sia di progetto,
mantenendo la tracciabilità dei concetti impiegati nelle diverse viste.</p>
<p>Il <a class="reference external" href="https://it.wikipedia.org/wiki/Unified_Modeling_Language">Linguaggio UML</a> permette di definire modelli al termine di ogni fase
del processo di sviluppo software:</p>
<ul class="simple">
<li><p><em>Use Case Diagrams</em>: permettono di esprimre il risultato della fase di analisi dei requisiti;</p></li>
<li><p><em>class diagrams</em>, <em>sequence diagrams</em>, <em>activity diagrams</em>, <em>statechart diagram</em> permettono
di esprimre la struttura e il comportmento il sistema al termine della analisi del problema
e del progetto:</p></li>
<li><p><em>deployment diagrams</em> permettono di esprimere le modalità di distribuzione del prodotto.</p></li>
</ul>
</section>
<section id="estensioni-di-uml">
<h3>Estensioni di UML<a class="headerlink" href="#estensioni-di-uml" title="Permalink to this heading">¶</a></h3>
<p>Tecnicamente, UML non è limitato al  <a class="reference internal" href="#paradigma-orientato-agli-oggetti-oop"><span class="std std-ref">Paradigma Orientato agli Oggetti (OOP)</span></a>,
in quanto permette <strong>estensioni</strong> che lo possono rendere capace di
modellare anche sistemi basati sul <a class="reference internal" href="#gli-attori-come-nuovo-paradigma"><span class="std std-ref">Modello ad Attori</span></a>.
Inoltre esistono  <a class="reference external" href="https://en.wikipedia.org/wiki/Profile_(UML)">Profili UML</a>
definiti da comuità di sviluppattori, come è stato nel caso di Akka.</p>
<p>Un modello UML standard è una specifica, mentre un modello <strong>xUML</strong> (<em>Executable UML</em>)
o <strong>fUML</strong> (<em>Foundational UML</em>)
è una rappresentazione formale che può essere utilizzata da un tool
(come una piattaforma  <a class="reference external" href="https://en.wikipedia.org/wiki/Model-driven_engineering">MDE</a>: <em>Model-Driven Engineering</em>) per:</p>
<ul class="simple">
<li><p><strong>Interpretazione</strong>: Eseguire direttamente il modello per simulare o testare il sistema.</p></li>
<li><p><strong>Trasformazione</strong> (Generazione di Codice): Generare codice sorgente eseguibile completo
(codice della piattaforma) dal modello astratto.</p></li>
</ul>
<p>Questi aspetti sono però ua sorta di ‘add on’ al corpo principale di UML
e <span class="xref std std-ref">Il linguaggio qak</span> che introdurremo più avanti
vuole fornire uno strumento più adatto (in quanto esplicitamente
orientato allo scopo) ad
abbattere i costi di produzione di un sistema distribuito.</p>
</section>
</section>
<section id="domain-specific-languages-dsl">
<h2>Domain-Specific Languages (DSL)<a class="headerlink" href="#domain-specific-languages-dsl" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="#l-abstraction-gap"><span class="std std-ref">L’Abstraction gap</span></a> è un dato di fatto strutturale nell’informatica e
i <em>Domain-Specific Languages</em> (<strong>DSL</strong>) rappresentano oggi la tecnica più potente per riconciliare
il ricco e complesso linguaggio di un certo dominio applicativo con i rigidi e universali GPL.</p>
<p>I DSL sono linguaggi creati per esprimere in modo conciso e non ambiguo i concetti e le regole di un
dominio applicativo specifico. Il loro scopo primario è alzare il livello di astrazione per
colmare <a class="reference internal" href="#l-abstraction-gap"><span class="std std-ref">L’Abstraction gap</span></a> in modo più espressivo di quanto possa fare una libreria o
un framework di un GPL.</p>
<p><em>SQL</em> (<strong>Structured Query Language</strong>) È un primo esempio di <strong>DSL</strong>, strettamente <strong>dichiarativo</strong>,
poiché si concentra sulla descrizione del <strong>risultato desiderato</strong> (i dati da recuperare)
piuttosto che sulla sequenza di passi per ottenerlo.</p>
<p><strong>Caratteristiche:</strong></p>
<ul class="simple">
<li><p><strong>Non Procedurale:</strong> Non si specificano i cicli o le condizioni di flusso.</p></li>
<li><p><strong>Set-Oriented:</strong> Le operazioni agiscono su insiemi di dati (tabelle).</p></li>
<li><p><strong>Focus sui Dati:</strong> La logica è incentrata su come manipolare e interrogare i dati relazionali.</p></li>
</ul>
<p>I DSL possono essere classificati in base alla loro implementazione:</p>
<section id="dsl-interno">
<span id="id47"></span><h3>DSL Interno<a class="headerlink" href="#dsl-interno" title="Permalink to this heading">¶</a></h3>
<p>Un DSL costruito all’interno di un GPL esistente (l’Host Language) viene anche detto
<strong>Embedded DSL</strong>.
Utilizza la sintassi e la semantica dell’LdP host per creare astrazioni di livello superiore.</p>
<ul class="simple">
<li><p><em>Vantaggio</em>: Facile integrazione, sfrutta l’infrastruttura dell’Host Language (es. compilatore, debugger).</p></li>
<li><p><em>Esempi</em>: LINQ in C#, le API Funzionali di Scala (es. le collezioni), l’uso di Builder Pattern in Java.</p></li>
</ul>
</section>
<section id="dsl-esterno">
<span id="id48"></span><h3>DSL Esterno<a class="headerlink" href="#dsl-esterno" title="Permalink to this heading">¶</a></h3>
<p>Si tratta di un linguaggio completamente nuovo, con la sua sintassi, parser e motore di esecuzione.</p>
<ul class="simple">
<li><p><em>Vantaggio</em>: Massima espressività, può essere letto e scritto direttamente dagli esperti del dominio, totale indipendenza dal GPL.</p></li>
<li><p><em>Esempi</em>: SQL (per interrogare database), Regex (per pattern matching), YAML/JSON (per la configurazione).</p></li>
</ul>
<p>Il framework <strong>Xtext</strong> si basa sull’ecosistema <strong>Eclipse</strong> e offre strumenti per ampliare
Eclipse con appositi plugin per fornsre un editor guidato dalla sintassi, e
un generazione di codice (Java, Kotlin o altro) che realizza la semantica del linguaggio.</p>
<a class="reference internal image-reference" href="_images/factory.jpg"><img alt="_images/factory.jpg" class="align-center" src="_images/factory.jpg" style="width: 100%;" /></a>
<p>I DSL traducono direttamente concetti del <code class="docutils literal notranslate"><span class="pre">LN</span></code> in costrutti formali
che sono facili da comprendere sia dagli esperti del dominio che dai programmatori.</p>
<p><strong>Esempio</strong>: Nonostante Java non abbia una parola chiave “Microservizio”,
un Framework (come <em>Akka</em> o <em>Spring Cloud</em>) può essere visto come un insieme di astrazioni che creano un
DSL interno:</p>
<ul class="simple">
<li><p>Si usano annotazioni come <code class="docutils literal notranslate"><span class="pre">&#64;Service</span></code> o si definiscono <code class="docutils literal notranslate"><span class="pre">Actor</span></code> (come in <em>Akka</em>) che mappano direttamente
il concetto di unità isolata del microservizio.</p></li>
<li><p>Questo “Linguaggio” all’interno del Framework permette agli sviluppatori di pensare e scrivere in
termini di servizi anziché solo in termini di classi e thread.</p></li>
</ul>
<p><span class="xref std std-ref">Il linguaggio qak</span> che introdurremo più avanti costituisce una <a class="reference internal" href="#dsl-esterno"><span class="std std-ref">DSL Esterno</span></a> che permette di esprimere
in modo diretto concetti (attore, messaggio, etc.) particolarmente rilevanti per la costruzione di sistemi software
distribuiti a microserivizi.</p>
<p><strong>Vantaggi Principali a livello Applicativo</strong></p>
<p>L’uso di DSL per colmare <a class="reference internal" href="#l-abstraction-gap"><span class="std std-ref">L’Abstraction gap</span></a> offre vantaggi sostanziali:</p>
<ul class="simple">
<li><p><strong>Riduzione dell’Ambiguità</strong>: I concetti del dominio vengono espressi in modo formale e non ambiguo
(es. “calcolaInteressi” nel DSL fiscale è univoco, a differenza dell’LN).</p></li>
<li><p><strong>Aumento della Produttività</strong>: I programmatori lavorano con astrazioni più vicine al problema,
riducendo la quantità di “boilerplate code” (codice standardizzato e ripetitivo).</p></li>
<li><p><strong>Manutenibilità</strong>: Quando le regole del dominio cambiano (es. una nuova legge fiscale), si modificano
solo le definizioni nel DSL (che è ad alto livello), senza toccare gran parte della logica
di basso livello del GPL.</p></li>
</ul>
</section>
</section>
<section id="i-dsl-e-i-digital-twins">
<span id="id49"></span><h2>I DSL e i Digital Twins<a class="headerlink" href="#i-dsl-e-i-digital-twins" title="Permalink to this heading">¶</a></h2>
<p>I DSL consentono agli esperti di un dominio (ingegneri meccanici, fisici, chimici) di esprimere
la logica e le proprietà di un asset fisico senza dipendere da programmatori software
o da GPL.</p>
<p>Questo aspetto è particolarmente rilevante per un sistemi software che svolge il ruolo
di <a class="reference external" href="https://it.wikipedia.org/wiki/Gemello_digitale">Gemello Digitale</a>  (<strong>Digital Twin</strong> o <strong>DT</strong>) di un sistema fisico.</p>
<p>Il termine <em>Digital Twin</em> è stato introdotto nel <code class="docutils literal notranslate"><span class="pre">2003</span></code>  da <em>Michael Grieves</em>
per denotare la replica digitale di una qualsiasi Entità Fisica che
viene vista come la fonte dei dati
su cui il <strong>DT</strong> opera per realizzare alcune funzionalità chiave:</p>
<ul class="simple">
<li><p><strong>Monitoraggio in Tempo Reale</strong>: Il <code class="docutils literal notranslate"><span class="pre">DT</span></code> è alimentato da streaming data (telemetria)
che riflette costantemente lo stato operativo, la salute e le prestazioni dell’asset fisico.</p></li>
<li><p><strong>Simulazione e Previsione</strong>: Permette di eseguire scenari What-If (“Cosa succede se…”)
sul gemello virtuale senza rischiare danni all’entità fisica.</p></li>
<li><p><strong>Diagnostica e Ottimizzazione</strong>: Viene utilizzato per identificare le cause profonde
dei problemi e per testare le modifiche operative prima di implementarle nel mondo reale.</p></li>
<li><p><strong>Manutenzione Predittiva</strong>: Una delle applicazioni più potenti: il <code class="docutils literal notranslate"><span class="pre">DT</span></code> analizza
le prestazioni attuali, le confronta con i modelli di degrado e prevede
esattamente quando e dove un componente fallirà, permettendo la manutenzione prima del guasto.</p></li>
</ul>
<p>Il <code class="docutils literal notranslate"><span class="pre">DT</span></code> fornisce una rappresentazione concreta di un <a class="reference internal" href="#sistemi-complessi"><span class="std std-ref">Sistema complesso</span></a>.
Questo riduce l’<span class="xref std std-ref">Abstraction gap</span> tra l’utente finale (che lavora con l’asset fisico)
e il programmatore (che scrive il codice di controllo).</p>
<p>In questo campo, i DSL non sono solo strumenti di codifica, ma sono
strumenti indispendabili per la <strong>modellazione concettuale</strong> che rendono il
<code class="docutils literal notranslate"><span class="pre">DT</span></code> più accurato, manutenibile e interoperabile.</p>
<p>Un DSL può servire anche come linguaggio intermedio standardizzato per descrivere e
integrare i dati provenienti da fonti eterogenee di dati
generati da sistemi di controllo industriali (<em>PLC, SCADA</em>).</p>
<p>I <code class="docutils literal notranslate"><span class="pre">DT</span></code> sono intrinsecamente basati su <strong>eventi</strong>, guidati dal flusso continuo di dati
<strong>IoT</strong> (<a class="reference external" href="https://en.wikipedia.org/wiki/Internet_of_things">Internet of Things</a>).
I sistemi software che li gestiscono devono essere costruiti con architetture reattive
e asincrone (come l’Actor Model o l’architettura a microservizi) per gestire
l’alta velocità e la bassa latenza richieste.</p>
<p>Il <code class="docutils literal notranslate"><span class="pre">DT</span></code> eleva il ruolo del programmatore da semplice codificatore a <strong>modellatore di sistemi</strong>
e <strong>ingegnere di dominio</strong>. Il valore non risiede più solo nello scrivere codice, ma nel:</p>
<ul class="simple">
<li><p><strong>Creare Modelli Accurati</strong>: Sviluppare modelli matematici e fisici che replichino fedelmente
il comportamento del mondo reale.</p></li>
<li><p><strong>Ingegneria dei Dati</strong>: Progettare data pipelines efficienti e sistemi di time-series
database per gestire e pulire il volume massiccio di dati in tempo reale generato dal gemello.</p></li>
</ul>
</section>
<section id="id50">
<h2>Verso i sistemi software<a class="headerlink" href="#id50" title="Permalink to this heading">¶</a></h2>
<p>Il <em>Digital Twin</em>, quindi, è un caso emblematico di come l’obiettivo di molti moderni sistemi software
si sposta verso la proattività, la previsione e la conoscenza olistica dello stato operativo.
La transizione dagli algoritmi ai sistemi software evocata nella <a class="reference internal" href="#evoluzione-del-concetto-di-computazione"><span class="std std-ref">Evoluzione del concetto di Computazione</span></a>
trova qui il suo più evoluto compimento.</p>
<p>Ma prima può essere opportuno affrontare il tema dei sistemi software in modo incrementale,
procedendo dal semplice al complicato, fino a raggiungere livelli tipici dei sistemi complessi.</p>
<span class="target" id="computare"></span></section>
</section>
<section id="sistemi-software">
<span id="id51"></span><h1>Sistemi software<a class="headerlink" href="#sistemi-software" title="Permalink to this heading">¶</a></h1>
<p>In ambito informatico, un Sistema è spesso descritto come:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Una</span> <span class="n">combinazione</span> <span class="n">strutturata</span> <span class="n">di</span> <span class="n">componenti</span> <span class="n">che</span> <span class="n">raccolgono</span><span class="p">,</span> <span class="n">elaborano</span><span class="p">,</span>
<span class="n">memorizzano</span> <span class="n">e</span> <span class="n">distribuiscono</span> <span class="n">informazioni</span> <span class="n">per</span> <span class="n">supportare</span>
<span class="n">servizi</span> <span class="n">e</span> <span class="n">processi</span> <span class="n">decisionali</span> <span class="n">e</span> <span class="n">di</span> <span class="n">controllo</span><span class="o">.</span>
</pre></div>
</div>
<p>Storicamente, il software nasce come l’insieme di <strong>istruzioni-macchina</strong> che deve essere
eseguito da un computer su un insieme di <strong>dati</strong> per realizzare un algoritmo.</p>
<p>L’evoluzione di linguaggi ad alto livello ha visto la rapida introduzione di
costrutti capaci di esprimere semplici forme di aggregazioni di istruzioni e dati (componenti sofware).</p>
<p>L’uso del termine <strong>sistema software</strong> enfatizza,
in genere, prodotti costruiti o studiati in termini
della  organizzazione e della interazione tra i componenti che formano il prodotto.</p>
<p>Quando si ha a che fare con un sistema software, è utile distinguere <strong>due livelli</strong>:</p>
<ol class="arabic simple">
<li><p><strong>Descrizione esterna</strong> — come il sistema parla con l’esterno: API, messaggi, contratto di servizio.</p></li>
<li><p><strong>Comportamento interno</strong> — come ogni componente (oggetto, attore, microservizio) evolve nel tempo:
stato, transizioni, reazioni ai messaggi, logica interna.</p></li>
</ol>
<p>Molti strumenti coprono solo il primo livello (descrizione dell’interfaccia — es. <a class="reference external" href="https://it.wikipedia.org/wiki/Specifiche_OpenAPI">OpenAPI</a>),
altri solo il secondo (codice, FSM, logica interna).
Ma per sistemi non banali servono entrambi in modo coerente.</p>
<section id="viste-di-un-sistema-software">
<h2>Viste di un sistema software<a class="headerlink" href="#viste-di-un-sistema-software" title="Permalink to this heading">¶</a></h2>
<p>Un sistema software può essere descritto da diversi punti di vista:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>L’osservatore di un sistema software può
parlare di un sistema considerando
diversi punti di vista</p>
<ul class="simple">
<li><p><a class="reference internal" href="#vista-esterna"><span class="std std-ref">Vista esterna</span></a></p></li>
<li><p><a class="reference internal" href="#vista-interna"><span class="std std-ref">Vista interna</span></a></p></li>
<li><p><a class="reference internal" href="#vista-sommersa"><span class="std std-ref">Vista sommersa</span></a></p></li>
</ul>
</td>
<td><p>Quello che si vede e non</p>
<a class="reference internal image-reference" href="_images/Viste.PNG"><img alt="_images/Viste.PNG" class="align-center" src="_images/Viste.PNG" style="width: 80%;" /></a>
</td>
</tr>
</tbody>
</table>
<section id="vista-esterna">
<span id="id52"></span><h3>Vista esterna<a class="headerlink" href="#vista-esterna" title="Permalink to this heading">¶</a></h3>
<p>Il sistema  viene visto come una entità accessibile attraverso una  <a class="reference internal" href="#api"><span class="std std-ref">Le API</span></a>
(<strong>Application Programming Interface</strong>)
intesa come il punto di contatto che consente l’interazione tra codici in esecuzione</p>
</section>
<section id="vista-interna">
<span id="id53"></span><h3>Vista interna<a class="headerlink" href="#vista-interna" title="Permalink to this heading">¶</a></h3>
<p>Il sistema  viene visto come un insieme di enti computazionali (funzioni, oggetti, processi, etc.) che operano
interagendo tra loro e con il mondo esterno (clienti, dispositivi, etc.) usando adeguati supporti</p>
</section>
<section id="vista-sommersa">
<span id="id54"></span><h3>Vista sommersa<a class="headerlink" href="#vista-sommersa" title="Permalink to this heading">¶</a></h3>
<p>Il sistema  è l’ultimo livello (<em>ayer</em>) di uno stack i cui livelli sottostanti
(librerie, infrastrutura, etc.) forniscono il supporto alla esecuzione.</p>
<p>Nel corso degli anni sono stati proposti e usati diversi tipi di componenti software,
che hanno contribuito a formare lo <strong>spazio concettuale</strong> dei linguaggi di programmazione
di alto livello.</p>
</section>
</section>
<section id="componenti-software">
<h2>Componenti software<a class="headerlink" href="#componenti-software" title="Permalink to this heading">¶</a></h2>
<p>In generale, il concetto di <strong>componente software</strong> può essere definito come:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">una</span> <span class="n">unità</span> <span class="n">autonoma</span> <span class="n">e</span> <span class="n">riusabile</span> <span class="n">di</span> <span class="n">codice</span> <span class="n">che</span> <span class="n">svolge</span> <span class="n">una</span>
<span class="n">funzione</span> <span class="n">specifica</span> <span class="nb">all</span><span class="s1">&#39;interno di un sistema software,</span>
<span class="n">promuovendo</span> <span class="n">la</span> <span class="n">riusabilità</span><span class="p">,</span> <span class="n">la</span> <span class="n">modularità</span> <span class="n">e</span> <span class="n">la</span> <span class="n">manutenibilità</span> <span class="k">del</span> <span class="n">codice</span>
</pre></div>
</div>
<p>Questa idea di base ha subito una profonda evoluzione nel corso degli anni, tanto che
occrrerebbe un corso ad hoc per descriverla.</p>
<p>Trascurando molti rilevanti aspetti, noi cercheremo di
delinarne alcuni punti importanti sia sul piano concettuale, sia sul piano pragamatico,
relativi alle moderne pratiche di costruzione di sistemi sofwtare.</p>
<section id="componenti-software-di-base">
<h3>Componenti software di base<a class="headerlink" href="#componenti-software-di-base" title="Permalink to this heading">¶</a></h3>
<p>I linguaggi di programmazione più diffusi permettono di costruire sistemi software
composti da due principali specie di componenti-base:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>.</p>
<a class="reference internal image-reference" href="_images/funz.PNG"><img alt="_images/funz.PNG" class="align-center" src="_images/funz.PNG" style="width: 70%;" /></a>
</td>
<td><p>Una funzione rappresenta un componente che permette la definizione parametrica di
istruzioni e la loro esecuzione mediante trasferimento di controllo.</p>
<p><em>Linguaggio di riferimento</em>: <code class="docutils literal notranslate"><span class="pre">JavaScript</span></code> (<code class="docutils literal notranslate"><span class="pre">Node.js</span></code>)</p>
</td>
</tr>
<tr class="row-even"><td><p>pojo</p>
<a class="reference internal image-reference" href="_images/obj.PNG"><img alt="_images/obj.PNG" class="align-center" src="_images/obj.PNG" style="width: 80%;" /></a>
</td>
<td><p>Un oggetto incapsula uno stato e un insieme di funzioni (metodi), la cui esecuzione
avviene mediante chiamata di procedura (trasferimento di controllo).</p>
<p><em>Linguaggio di riferimento</em>: <code class="docutils literal notranslate"><span class="pre">Java</span></code>.</p>
<p>Un oggetto può essere dotato di comportamento autonomo incapsulando un <strong>Thread</strong>.</p>
</td>
</tr>
</tbody>
</table>
<section id="i-pojo">
<h4>I POJO<a class="headerlink" href="#i-pojo" title="Permalink to this heading">¶</a></h4>
<p>Nel seguito useremo il termine <strong>POJO</strong> (<em>Plain Old Java Object</em>) per denotare componenti software
‘vecchio stile’ che interagiscono mediante trasferimento del controllo (chiamate di procedera).</p>
</section>
</section>
<section id="oltre-gli-oggetti">
<h3>Oltre gli oggetti<a class="headerlink" href="#oltre-gli-oggetti" title="Permalink to this heading">¶</a></h3>
<p>Lo sviluppo delle reti informatiche e di Internet ha promosso la costruzione di <strong>sistemi software
distribuiti</strong> su più nodi di elaborazione, su ciascuno dei quali possono essere eseguiti
programmi espressi medianti linguaggi diversi.</p>
<ul class="simple">
<li><p>La costruzione di <strong>sistemi software distributi eterogenei</strong> è resa possibile dall’uso
(entro funzioni ed oggetti) di protocolli di comunicazione (come <code class="docutils literal notranslate"><span class="pre">UDP,</span> <span class="pre">TCP,</span> <span class="pre">HTTP,</span> <span class="pre">MQTT,</span> <span class="pre">CoAP</span></code>, etc.)
e richiede logicamente componenti  capaci di interagire
(spesso in modo <code class="docutils literal notranslate"><span class="pre">asincrono</span></code>) mediante <strong>scambio di messaggi</strong> e non più mediante trasferimento
di controllo con chiamate di procedura.</p></li>
<li><p>Ciò ha portato alla definizione di nuovi tipi di componenti software
quali gli <a class="reference internal" href="#gli-attori-come-nuovo-paradigma"><span class="std std-ref">Attori</span></a>, gli <span class="xref std std-ref">agenti software (intelligenti)</span>,
i <a class="reference external" href="https://en.wikipedia.org/wiki/Microservices">Microservizi</a>, le <a class="reference external" href="https://it.wikipedia.org/wiki/Function_as_a_service">Funzioni serverless</a>, etc.</p></li>
</ul>
</section>
</section>
<section id="un-viaggio-nei-sistemi-software">
<span id="id55"></span><h2>Un viaggio nei sistemi software<a class="headerlink" href="#un-viaggio-nei-sistemi-software" title="Permalink to this heading">¶</a></h2>
<p>In questa sezione cercheremo di parlare, in linguaggio naturale, di un sistema denominato <strong>S</strong>
supponendo che sia un <em>sistema hardware/software</em> con cui sia possibile interagire via rete.</p>
<a class="reference internal image-reference" href="_images/SInU.jpg"><img alt="_images/SInU.jpg" class="align-center" src="_images/SInU.jpg" style="width: 55%;" /></a>
<p>Il sistema <strong>S</strong>  è posto in un ‘universo’ (<strong>U</strong>) in cui si trova anche un
osservatore (umano o meno) <strong>Obs</strong>, che
può interagire con <code class="docutils literal notranslate"><span class="pre">S</span></code>  in molti modi diversi.</p>
<section id="punti-di-vista">
<h3>Punti di vista<a class="headerlink" href="#punti-di-vista" title="Permalink to this heading">¶</a></h3>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>.</p>
<a class="reference internal image-reference" href="_images/VisteObs.PNG"><img alt="_images/VisteObs.PNG" class="align-center" src="_images/VisteObs.PNG" style="width: 100%;" /></a>
</td>
<td><p>La figura vuole rappresentare l’idea che due osservatori di uno stesso oggetto
possono avere viste diverse di esso
e quindi pensare che l’oggetto osservato abbia proprietà diverse.</p></td>
</tr>
</tbody>
</table>
<p>Dire che <strong>S</strong> è un sistema <strong>hardware/software</strong> induce a pensare che sia
costruito usando un <strong>computer</strong> (hardware) capace di elaborare <strong>istruzioni</strong> (software) che determinano
il comportamento osservabile del sistema.</p>
<p>Il  <em>sistema globale S + Obs</em> è un sistema distribuito di cui può essere
difficile <em>parlare in modo preciso</em> senza un opportuno linguaggio capace
di <strong>esprimere gli aspetti salienti della interazione/comunicazione</strong>, lasciando sullo sfondo dettagli importanti,
ma non essenziali.</p>
<p>In assenza di ulteriori informazioni, <code class="docutils literal notranslate"><span class="pre">S</span></code> potrebbe essere visto come un <strong>servizio</strong>,
pensando che il sistema sia in grado di <strong>fornire funzionalità</strong> a
<strong>clienti</strong> (umani o programmi) che ne fanno richiesta usando
protocolli di rete standard, come <code class="docutils literal notranslate"><span class="pre">HTTP</span></code> e <code class="docutils literal notranslate"><span class="pre">WS</span></code> (<em>WebSocket</em>) o altri.</p>
<p>Queste sommarie indicazioni sono già sufficienti a dare una idea
di cosa stiamo parlando comprensibile a <strong>molti</strong> esseri umani,
ed in particolare a coloro che sono abituati a usare <strong>Internet</strong>.
Osserviamo però che questo modo di ‘capire’ cosa sia <code class="docutils literal notranslate"><span class="pre">S</span></code>  era <strong>praticamente impossibile</strong>
solo pochi decenni fa, quando i <em>computer</em> e <em>Internet</em> non erano così diffusi e
facilmente accessibili.</p>
<p>Tuttavia, anche  in comunità umane in cui il termine <strong>servizio</strong> (software) è ormai di uso comune,
non è certo scontato che sia a tutti ‘chiaro’ cosa sia un <em>servizio</em>, come sia fatto e come funzioni.
Inoltre, anche i più esperti del settore potrebbero trovarsi in difficoltà di fronte a  domande del tipo:</p>
<p><strong>Domanda1</strong>: che differenza c’è’ tra un servizio e un normale <strong>programma</strong> che gira su un computer?
Certo si può presumere che un serivizio sia un programma, ma allora cosa lo rende un <strong>servizio</strong>?</p>
<p><strong>Domanda2</strong>: che differenza c’è’ tra un <em>servizio</em>  e un <strong>microservizio</strong> ?</p>
<p>In attesa di rispondere a domande di questo tipo, al momento osserviamo solo che:</p>
<ul class="simple">
<li><p><strong>tutti is sistemi software servono a qualcosa ma non tutti sono servizi</strong></p></li>
</ul>
</section>
<section id="sistemi-embedded-iot">
<span id="id56"></span><h3>Sistemi Embedded/IoT<a class="headerlink" href="#sistemi-embedded-iot" title="Permalink to this heading">¶</a></h3>
<p>I computer oggi in uso sono spesso
dotati di dispositivi di interazione con il mondo fisico (si pensi a un un <a class="reference internal" href="#raspberrypi"><span class="std std-ref">RaspberryPi</span></a>
e ai suoi  PIN <strong>GPIO</strong> (<em>General Purpose IO</em>)
e rappresentano una categoria qualitativamente diversa dai computer generici che elabora solo dati.</p>
<p>Un <strong>sistema embedded</strong> è un sistema di calcolo dedicato a svolgere una o poche funzioni specifiche,
integrato all’interno di un prodotto o dispositivo fisico.
Quando questi sistemi sono connessi in rete — spesso a Internet — e possono interagire con altri dispositivi
o servizi digitali, si parla di <strong>sistemi IoT</strong> (<a class="reference external" href="https://en.wikipedia.org/wiki/Internet_of_things">Internet of Things</a>).</p>
<section id="raspberrypi">
<span id="id57"></span><h4>RaspberryPi<a class="headerlink" href="#raspberrypi" title="Permalink to this heading">¶</a></h4>
<p>Il <a class="reference external" href="https://it.wikipedia.org/wiki/Raspberry_Pi">Raspberry Pi</a> è una piccola scheda computer, economica e a basso consumo, molto utilizzata per
realizzare sistemi embedded e IoT grazie a:</p>
<ul class="simple">
<li><p>un sistema operativo completo (generalmente Linux)</p></li>
<li><p>interfacce di comunicazione evolute (Wi-Fi, Bluetooth, Ethernet)</p></li>
<li><p>GPIO per la connessione diretta a sensori e attuatori fisici</p></li>
<li><p>una comunità e un ecosistema di librerie molto vasti</p></li>
</ul>
</section>
<section id="sistemi-cibernetici">
<span id="id58"></span><h4>Sistemi cibernetici<a class="headerlink" href="#sistemi-cibernetici" title="Permalink to this heading">¶</a></h4>
<p>Un computer interfacciato con il mondo fisico rappresenta
un <strong>sistema cibernetico</strong> la cui funzione primaria è modificare o preservare lo stato del mondo
reale. Come tale,  è un sistema — naturale, artificiale o misto — capace di
raggiungere o mantenere uno stato desiderato (un obiettivo):</p>
<ul class="simple">
<li><p>percependo l’ambiente attraverso sensori,</p></li>
<li><p>valutando l’errore rispetto all’obiettivo,</p></li>
<li><p>agendo sull’ambiente tramite attuatori,</p></li>
<li><p>chiudendo il ciclo tramite un meccanismo di <strong>feedback</strong>.</p></li>
</ul>
</section>
</section>
</section>
<section id="capire-sperimentando">
<h2>Capire sperimentando<a class="headerlink" href="#capire-sperimentando" title="Permalink to this heading">¶</a></h2>
<p>Il problema di capire/definire
cosa sia  <code class="docutils literal notranslate"><span class="pre">S</span></code> può essere affrontato seguendo un approccio analogo a quello di un ricercatore che
vuole studiare un nuovo oggetto fisico.
In questo caso, il ricercatore potrebbe iniziare a porsi alcune domande del tipo:</p>
<ol class="arabic simple">
<li><p>cosa fa questo oggetto?</p></li>
<li><p>come funziona?</p></li>
<li><p>come è fatto?</p></li>
<li><p>quali sono le sue proprietà più interessanti?</p></li>
</ol>
<p>Notiamo che le domande <code class="docutils literal notranslate"><span class="pre">1</span></code> e <code class="docutils literal notranslate"><span class="pre">2</span></code> implicano una certa <strong>osservazione</strong> dell’oggetto in azione,
mentre le domande <code class="docutils literal notranslate"><span class="pre">3</span></code> e <code class="docutils literal notranslate"><span class="pre">4</span></code> richiedono una certa <strong>analisi</strong> dell’oggetto, magari smontandolo per
vedere come è fatto dentro.</p>
<section id="capire-interagendo">
<h3>Capire interagendo<a class="headerlink" href="#capire-interagendo" title="Permalink to this heading">¶</a></h3>
<p>Sembra ragionevole pensare che, prima di ‘smontare’ un oggetto, sia  meglio intergire con
l’oggetto in una <em>fase di ‘pura osservarzione’</em>, per cercare di ricavarne informazioi utili
per il suo utilizzo
e per <strong>inferire</strong>, se possibile, alcune delle sue proprietà.</p>
<p>Siamo qui di fronte a una delle problematiche più interessanti e controverse della scienza:
come si fa a studiare un oggetto nuovo di cui non si sa nulla?
Anche una questione che sembra banale, come <em>la ‘semplice (!) osservazione</em>, è oggi un tema di ricerca
avanzata in molti campi, dopo che la <a class="reference external" href="https://it.wikipedia.org/wiki/Meccanica_quantistica">meccanica quantistica</a> ha mostrato che
l’atto stesso dell’osservazione
può influenzare  (prima ancora di ‘smontarlo’) l’oggetto osservato
o addirittura <strong>determinarne alcune proprietà</strong>.</p>
<p>Fortunatamente, per i nostri scopi, potremo trascurare queste proprietà che
sembrano caratterizzare il mondo in cui viviamo, almeno fino a quando non
dovremo occuparci di sistemi software che usano il <a class="reference internal" href="#quantum-computer"><span class="std std-ref">Quantum computer</span></a>.</p>
</section>
<section id="interagire-con-un-sistema-software">
<span id="id59"></span><h3>Interagire con un sistema software<a class="headerlink" href="#interagire-con-un-sistema-software" title="Permalink to this heading">¶</a></h3>
<p>Nel caso in cui <code class="docutils literal notranslate"><span class="pre">S</span></code> sia un sistema software, è implicito il fatto che la interazione richiede
l’uso di un computer e/o di una rete di comunicazione.</p>
<a class="reference internal image-reference" href="_images/SInUComputer.jpg"><img alt="_images/SInUComputer.jpg" class="align-center" src="_images/SInUComputer.jpg" style="width: 60%;" /></a>
</section>
<section id="capire-implica-opportuni-livelli-di-conoscenza">
<h3>Capire implica opportuni livelli di conoscenza<a class="headerlink" href="#capire-implica-opportuni-livelli-di-conoscenza" title="Permalink to this heading">¶</a></h3>
<p>L’informazione scambiata tra un sistema software <code class="docutils literal notranslate"><span class="pre">S</span></code> e <code class="docutils literal notranslate"><span class="pre">Obs</span></code> è di solito
rappresentata in forma di stringa usando caratteri
quali <a class="reference external" href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. Ma questo dettaglio di basso livello è piuttosto <strong>irrilevante per catturare gli aspetti
salienti</strong> della comunicazione.</p>
<p>Questo aspetto è ancora più evidente considerando che noi ‘sappiamo’
che <code class="docutils literal notranslate"><span class="pre">S</span></code> (o almeno il suo <em>hardware</em> è semza dubbio formato da <em>atomi</em> (su questo punto ci sarebbe da approfondire …) ;
tuttavia nessun essere umano penserebbe che
questo livello di conoscenza sia necessario (o meglio <strong>il livello ‘giusto’</strong>) per capire <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
<p>In altri termini, per capire <code class="docutils literal notranslate"><span class="pre">S</span></code> non è oggi necessario (al momento almeno)
studiare discipline come la <em>fisica</em> o la <em>chimica</em>
o la <em>biologia</em> o  la <em>psicologia</em>. Pensandoci bene, non è nemmeno necessario studiare
<strong>calcolatori elettronici</strong>, perchè è implicito che quello che fa <code class="docutils literal notranslate"><span class="pre">S</span></code> è determinato dal <em>software</em>,
che ha nell’hardware del computer, la sua premessa indispensabile, il suo ‘supporto vitale’
ma non gli elementi necessari per fornire una adeguata ‘spiegazione’ di <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
<p>Potrebbe anche non essere nemmeno necessario addentrarsi nella parte di software nota come <strong>sistema operativo</strong>:
per capire pienamente <code class="docutils literal notranslate"><span class="pre">S</span></code> sarebbe però necessario
conoscere  il <strong>linguaggio di programmazione</strong> (o i linguaggi)
con cui è stato specificato il comportamento di <code class="docutils literal notranslate"><span class="pre">S</span></code> : al più è necessario conoscere anche
il rapporto tra il linguaggio e il primo livello si software limitrofo sottostatnte.</p>
<p>Ma prima di ‘aprire il sistema’ per vedere come è fatto ‘dentro’, proviamo a capirlo seguendo l’idea
meno invasiva di <strong>comunicare</strong> con esso.</p>
<p>Tenendo conto del moderno punto di vista scientifico, non possiamo dimenticare che osservatore
e osservato sono parte dello stesoo ‘universo’ e che il funzionamento di <code class="docutils literal notranslate"><span class="pre">S</span></code> potrebbe essere legato
non solo al modo in cui l’osservatore interagisce direttamente con esso, ma anche da altri fattori,
ad esempio la temperatura e la pressione dell’ambiente, flare solari, etc.</p>
<p>Tuttavia è ragionevole pensare che, per studiare <code class="docutils literal notranslate"><span class="pre">S</span></code>, l’osservatore possa limitarsi a interagire con esso
usando un computer come unico ‘strumento di interazione’, senza preoccuparsi troppo di altri fattori esterni
(come ha proposto di fare per primo <em>Galileo</em>, al fine di distinguere ciò che è necessario
da ciò che può essere ignorato in prima istanza).</p>
</section>
<section id="conoscere-per-comunicare">
<span id="id60"></span><h3>Conoscere per comunicare<a class="headerlink" href="#conoscere-per-comunicare" title="Permalink to this heading">¶</a></h3>
<p>Per poter <strong>comunicare proficuamente</strong> con  <code class="docutils literal notranslate"><span class="pre">S</span></code>, l’osservatore <code class="docutils literal notranslate"><span class="pre">Obs</span></code> deve conoscere:</p>
<ol class="arabic simple">
<li><p>il <strong>protocollo di comunicazione (P)</strong> che permette al computer che supporta <code class="docutils literal notranslate"><span class="pre">S</span></code> di ricevere/trasmettere
informazione e quindi di iteragire con il computer usato da <code class="docutils literal notranslate"><span class="pre">Obs</span></code>;</p></li>
<li><p>il <strong>vocabolario/linguaggio</strong> che <code class="docutils literal notranslate"><span class="pre">S</span></code> usa per denotare l’informazione trasmessa/ricevuta
come <strong>messaggi</strong>  usando <code class="docutils literal notranslate"><span class="pre">P</span></code>;</p></li>
<li><p>il <strong>legame logico della interazione</strong> che si stabilisce in ogni particolare tipo di
comunicazione tra due enti.</p></li>
</ol>
<section id="la-interazione-come-vincolo">
<span id="id61"></span><h4>La interazione come vincolo<a class="headerlink" href="#la-interazione-come-vincolo" title="Permalink to this heading">¶</a></h4>
<p>La necessità di conoscere il <strong>legame logico della interazione</strong> nasce dal fatto che vi sono varie forme di
comunicazione e che queste comportano diverse forme
di interazione logica tra gli enti comunicanti. Ad esempio, il sistema <code class="docutils literal notranslate"><span class="pre">S</span></code>  potrebbe essere:</p>
<ol class="arabic">
<li><p>capace di rispondere a <strong>richieste</strong> provenienti da uno o più <code class="docutils literal notranslate"><span class="pre">Obs</span></code>, inviando
la risposta a chi ha fatto la richiesta. Se due <code class="docutils literal notranslate"><span class="pre">Obs</span></code> diversi inviano richieste a <code class="docutils literal notranslate"><span class="pre">S</span></code>,
ognuno di loro si aspetta di ricevere una risposta pertinente alla
propria richiesta, senza confusioni.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Notiamo che l’invio di una richiesta non implica che <code class="docutils literal notranslate"><span class="pre">Obs</span></code> si blocchi
in attesa delle risposta. in tal caso si avrebbe una <strong>operazione sincrona</strong> e il canale di comunicazione
rimarrebbe aperto fino alla risposta.</p>
<p><code class="docutils literal notranslate"><span class="pre">Obs</span></code> potrebbe inviare la richiesta come <strong>operazione asincrona</strong>; in tal caso il canale di comunicazione
potrebbe chiudersi subito dopo l’invio della richiesta e <code class="docutils literal notranslate"><span class="pre">S</span></code> dovrebbe trovare  modi opportuni per
inviare la risposta che  <code class="docutils literal notranslate"><span class="pre">Obs</span></code> si aspetta e che elaborerà quando
sarà ‘disposto a farlo’.</p>
</div>
</li>
<li><p><strong>emettere informazioni</strong>  (dette <strong>eventi</strong>) in modo spontaneo verso il mondo esterno, che potrebbero
essere ‘captate’ da uno o più <code class="docutils literal notranslate"><span class="pre">Obs</span></code> (si pensi ad esempio a un servizio che avvisa su allarmi,
congestione o blochhi stradali, etc.)
Questa forma di comunicazione viene detta <a class="reference external" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish–subscribe</a> e viene supportata da broker come
<code class="docutils literal notranslate"><span class="pre">RAbbitMQ,</span> <span class="pre">Mosquritto,</span> <span class="pre">HiveMQ</span> <span class="pre">,</span> <span class="pre">Kafka</span></code>.</p></li>
<li><p>capace di eleborare messaggi inviati in modo
<a class="reference external" href="https://medium.com/mandiri-engineering/fire-and-forget-e59b745c9f97">fire-and-forget</a> , impegnandosi a gestirli come <strong>comandi da eseguire</strong> e/o a restituire risultati
in forma di <strong>notifiche/eventi</strong>.</p></li>
</ol>
<p>Ognuna delle forme di comunicazione citate costituisce un <strong>vincolo</strong> tra gli enti comunicanti, che devono agire
ciascuno in modo coerente con l’altro. E’ simile al tipo di vincolo che lega due danzatori.</p>
<p>Anche questo semplice e vago elenco di possibiltà mostra come possa essere
difficile <em>parlare in modo preciso</em> di un sistema software senza un opportuno linguaggio capace
di <strong>esprimere gli aspetti salienti della interazione/comunicazione</strong>, lasciando sullo sfondo dettagli importantissimi,
ma non essenziali per la definizione e la comprensione del  <em>sistema globale S + Obs</em>.</p>
</section>
</section>
</section>
<section id="sistemi-software-come-servizi-ma-non-solo">
<h2>Sistemi software come servizi (ma non solo)<a class="headerlink" href="#sistemi-software-come-servizi-ma-non-solo" title="Permalink to this heading">¶</a></h2>
<p>Il sistema software <code class="docutils literal notranslate"><span class="pre">S</span></code> risulta accessibile a <code class="docutils literal notranslate"><span class="pre">Obs</span></code> attraverso l’uso di un particolare sistema fisico
(il <strong>computer</strong>) che ha la capacità di inviare/ricevere informazioni usando reti cablate e/o wireless e opportuni
<strong>protocolli</strong> di comunicazione quali <code class="docutils literal notranslate"><span class="pre">HTTP</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP</span></code>, <code class="docutils literal notranslate"><span class="pre">MQTT</span></code>, <code class="docutils literal notranslate"><span class="pre">WS</span></code> ed altri.</p>
<section id="l-infrastruttura">
<span id="infrastruttura"></span><h3>L’infrastruttura<a class="headerlink" href="#l-infrastruttura" title="Permalink to this heading">¶</a></h3>
<p>Perché il computer usato da <code class="docutils literal notranslate"><span class="pre">Obs</span></code> (<strong>Client</strong>) possa interagire con <code class="docutils literal notranslate"><span class="pre">S</span></code>
occorre disporre, allo stato attuale della tecnologia, di un ponte di comunicazione.</p>
<ul class="simple">
<li><p><strong>Networking</strong>: Entrambi i computer devono essere sulla stessa rete (LAN) o connessi tramite VPN/Internet.
Occorre conoscere l’Indirizzo IP del computer su cui gira S.</p></li>
<li><p><strong>Wrapping</strong>: Se S è un programma “chiuso” (es. uno script che gira solo da terminale),
occorre aggiungere uno strato software (un <em>Framework</em> come <strong>Flask</strong> per Python, <strong>Express</strong> per JS,
SpringBoot o  ASP.NET) che riceva le chiamate su rete e le “passi” a <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p></li>
<li><p><strong>Port</strong>: occorre scleglier un “canale” numerico (es. <code class="docutils literal notranslate"><span class="pre">8080</span></code>) su cui il server rimarrà in ascolto.</p></li>
<li><p><strong>Firewall</strong>: Sul computer di S, occorre aprire la porta scelta nel firewall per permettere il traffico in entrata.</p></li>
</ul>
<section id="i-framework">
<span id="framework"></span><h4>I framework<a class="headerlink" href="#i-framework" title="Permalink to this heading">¶</a></h4>
<p>Un <strong>framework</strong> è una struttura logica di supporto su cui uno sviluppatore può costruire software.</p>
<p>A differenza di una semplice libreria, il framework fornisce un’architettura predefinita e un insieme di strumenti,
componenti e regole che guidano lo sviluppo, permettendo di non dover riscrivere codice comune da zero</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Molti framework gestiscono le comunicazioni client-server, solitamente via <code class="docutils literal notranslate"><span class="pre">HTTP/HTTPS</span></code> o <a class="reference internal" href="#websockets"><span class="std std-ref">WebSocket</span></a>; tra questi:
<code class="docutils literal notranslate"><span class="pre">Node.js</span> <span class="pre">(Express)</span></code>, <code class="docutils literal notranslate"><span class="pre">FastAPI</span> <span class="pre">(Python)</span></code>, <span class="xref std std-ref">javalin</span>, <code class="docutils literal notranslate"><span class="pre">Spring</span> <span class="pre">Boot</span> <span class="pre">(Java)</span></code>.</p>
<p>Nel campo dei Web, <em>React</em> e <em>Angular</em> sono framework per <strong>Frontend</strong>, mentre Django (Python), Laravel (PHP), Spring (Java)
sono framework per <strong>Backend</strong>.</p>
</div>
<p>Le caratteristiche principali di un framework includono:</p>
<ul class="simple">
<li><p><strong>Inversione del controllo (IoC)</strong>: A differenza delle librerie, dove il programmatore chiama il codice esterno,
in un framework è la struttura stessa a chiamare il codice scritto dall’utente nei punti appropriati.</p></li>
<li><p><strong>Estendibilità</strong>: Permette di personalizzare specifiche parti del software per aggiungere funzionalità.</p></li>
<li><p><strong>Codice predefinito</strong>: Include soluzioni già pronte per compiti ripetitivi
(come la gestione dei database o l’autenticazione degli utenti).</p></li>
</ul>
<p>Un volta stabilita una connessione, il computer <strong>Client</strong> è analogo ai tipi di strumenti
telescopi, miscroscopi, acceleratori di particelle, etc.) usati dagli scienziati.</p>
<p>Ovviamente, la conoscenza di quale protocollo (<strong>P</strong>) usa  <code class="docutils literal notranslate"><span class="pre">S</span></code> per interagire con il mondo esterno
non è sufficiente: occorre anche conoscere la <a class="reference internal" href="#sintassi-e-semantica"><span class="std std-ref">Sintassi e semantica</span></a> delle ‘frasi’
veicolate tramire <strong>P</strong>. In altre parole, <code class="docutils literal notranslate"><span class="pre">S</span></code> definisce un <strong>proprio vocabolario</strong>, o più
in generale un  <strong>proprio linguaggio</strong> che <code class="docutils literal notranslate"><span class="pre">Obs</span></code> deve conoscere per interagire in modo
proficuo con <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</section>
</section>
<section id="le-api">
<span id="api"></span><h3>Le API<a class="headerlink" href="#le-api" title="Permalink to this heading">¶</a></h3>
<p>Nei sistemi software accessibili in rete, di solito si esegue un mappaing tra le capacità interne del sistema
e un’interfaccia esterna, l’<strong>API</strong> (<em>Application Programming Interface</em>) che stabilisce il “contratto”
che definisce quali informazioni il sistema può ricevere e cosa risponderà.</p>
<p>Senza <strong>API standardizzate</strong>, non ci sarebbe un accordo condiviso su come le diverse applicazioni o i servizi software comunicano.
I programmatori di due applicazioni separate dovrebbero parlare tra loro per determinare ogni volta
come sviluppare lo scambio di dati.</p>
<p>Di solito una API specifica almeno:</p>
<ul class="simple">
<li><p><strong>Input/Output</strong>: Quali argomenti accetta una specifica funzionalità di <code class="docutils literal notranslate"><span class="pre">S</span></code>? Che tipo di dati restituisce?
(Es. una stringa, un numero, un’immagine?).</p></li>
<li><p><strong>Protocollo</strong>: Il più comunen, nei servizi software, è <strong>HTTP</strong>,
seguendo lo stile architetturale <a class="reference internal" href="#rest"><span class="std std-ref">Representational State Transfer (REST)</span></a> (<strong>Representational State Transfer</strong>).</p></li>
</ul>
<p>Aspetti importanti in relazione all’uso di un sistema sono anche:</p>
<ol class="arabic simple">
<li><p>Gestione dello Stato</p>
<ul class="simple">
<li><p><strong>Stateless</strong>: Ogni richiesta è indipendente (es. una funzione che calcola la radice quadrata).</p></li>
<li><p><strong>Stateful</strong> : <code class="docutils literal notranslate"><span class="pre">S</span></code> ricorda le azioni precedenti (es. un carrello della spesa).
In questo caso, il client deve inviare un “ID sessione” per farsi riconoscere.</p></li>
</ul>
</li>
<li><p>Concorrenza</p></li>
</ol>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">S</span></code> è in grado di gestire più richieste contemporaneamente?
Se due client chiamano la stessa funzione nello stesso istante, <code class="docutils literal notranslate"><span class="pre">S</span></code> mette in coda le richieste?
Se <code class="docutils literal notranslate"><span class="pre">S</span></code> non è multi-thread, il <a class="reference internal" href="#framework"><span class="std std-ref">I framework</span></a> che funge da wrapper della
<a class="reference internal" href="#infrastruttura"><span class="std std-ref">L’infrastruttura</span></a>  dovrà realizzare e gestire la coda.</p>
</div></blockquote>
<p>Al giorno d’oggi esistono diverse soluzioni consolidate
per descrivere in modo formale (le interfacce di) servizi software,
alcune delle quali, largamente usate, sono descritte nel capitolo
<span class="xref std std-ref">APIDescription</span>.</p>
<p>Non tutte sono “formalismi puri” in senso teorico, ma piuttosto <strong>linguaggi di descrizione contrattuale</strong>
(interface description languages, IDL / API description languages).</p>
</section>
<section id="representational-state-transfer-rest">
<span id="rest"></span><h3>Representational State Transfer (REST)<a class="headerlink" href="#representational-state-transfer-rest" title="Permalink to this heading">¶</a></h3>
<p>REST è uno stile architetturale per sistemi distribuiti. L’espressione “representational state transfer”
e il suo acronimo, REST, fu introdotto nel 2000 nella tesi di dottorato di <strong>Roy Fielding</strong>.</p>
<p>REST rappresenta un sistema di trasmissione di dati su HTTP senza ulteriori livelli (quali ad esempio <a class="reference external" href="https://it.wikipedia.org/wiki/SOAP">SOAP</a>).
I sistemi REST non prevedono il concetto di sessione, ovvero sono <strong>stateless</strong>.</p>
<p>REST prevede che la scalabilità del Web e la sua crescita siano risultati di pochi principi chiave di progettazione:</p>
<ul class="simple">
<li><p>lo stato dell’applicazione e le funzionalità sono divisi in <strong>risorse</strong> web</p></li>
<li><p>ogni risorsa è unica e indirizzabile usando sintassi universale per uso nei link ipertestuali</p></li>
</ul>
<p>Il funzionamento di REST prevede una struttura degli <a class="reference external" href="https://it.wikipedia.org/wiki/Uniform_Resource_Locator">URL</a> (<em>Uniform Resource Locator</em>)
ben definita che identifica univocamente una <strong>risorsa</strong> o un insieme di risorse
e l’utilizzo dei metodi HTTP specifici per il recupero di informazioni,
per la modifica e per altri scopi (<code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code>, ecc.):</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>GET</strong>: “Dammi le informazioni” (non modifica nulla).</p></li>
<li><p><strong>POST</strong>: “Crea qualcosa di nuovo” (invia dati).</p></li>
<li><p><strong>PUT/PATCH</strong>: “Aggiorna qualcosa che esiste già”.</p></li>
<li><p><strong>DELETE</strong>: “Cancella una risorsa”.</p></li>
</ul>
</div></blockquote>
<p>REST è ideale per creare un’API pubblica per sviluppatori esterni o un servizio-web semplice.
È lo <strong>standard universale</strong> e il più facile da testare.</p>
<section id="hateoas">
<h4>HATEOAS<a class="headerlink" href="#hateoas" title="Permalink to this heading">¶</a></h4>
<p>HATEOAS è l’acronimo di <strong>Hypermedia as the Engine of Application State</strong> ed è un componente dell’architettura
e della progettazione delle API RESTful.</p>
<p>Utilizzando l’architettura HATEOAS, un client potrà accedere all’API di un’applicazione
tramite una semplice chiamata URL RESTful. Qualsiasi ulteriore azione che il client desideri
intraprendere sarà abilitata dai dati restituiti dal server nella chiamata originale.</p>
<p>I “dati”, all’interno della risposta, che consentono questo cambiamento di stato
sono semplici collegamenti ipermediali.
Ciò consentirà al client di passare da uno stato dell’applicazione al successivo semplicemente
interagendo con i dettagli contenuti nelle risposte del server.</p>
</section>
</section>
<section id="dai-servizi-ai-microservizi">
<h3>Dai servizi ai microservizi<a class="headerlink" href="#dai-servizi-ai-microservizi" title="Permalink to this heading">¶</a></h3>
<p>I sistemi software composti da microservizi rappresentano l’apice di un’evoluzione
che ha visto i sistemi informatici
trasformarsi da semplici programmi a complicate infrastrutture distribuite.</p>
<p>Le principali tappe che hanno segnato questo cambiamento possono essere visualizzate e riassunte come
riportato in <a class="reference external" href="_static/docs/msoIEEE.pdf">mshistory</a> .</p>
<a class="reference internal image-reference" href="_images/microservices.jpg"><img alt="_images/microservices.jpg" class="align-left" src="_images/microservices.jpg" style="width: 100%;" /></a>
<p>Le motivazioni che spingono le aziende verso i microservizi sono molteplici e spesso legate alla
necessità di gestire sistemi complessi e scalabili, migliorare la resilienza, accelerare l’innovazione,
e supportare la trasformazione digitale.</p>
<p>Il tema verrà approfondito nel capitolo dedicato ai <span class="xref std std-ref">Sistemi a microservizi</span></p>
<p><strong>Oltre HTTP</strong></p>
<p>Considerati i limiti di HTTP, vi sono molte applicazioni in cui
è preferibile utilizzare strumenti di interazione più efficienti ed ottimizzati, come
il protocollo <a class="reference internal" href="#coap"><span class="std std-ref">CoAP</span></a> le <a class="reference internal" href="#websockets"><span class="std std-ref">WebSocket</span></a> o, più recentemente, <span class="xref std std-ref">gRPC</span>.</p>
</section>
<section id="coap">
<span id="id62"></span><h3>CoAP<a class="headerlink" href="#coap" title="Permalink to this heading">¶</a></h3>
<p>Il protocollo <em>CoAP</em> (<strong>Constrained Application Protocol</strong>) è stato progettato specificamente per portare
il paradigma RESTful (risorse, metodi, URI) in ambienti dove l’overhead di HTTP e TCP sarebbe insostenibile.</p>
<p>Mentre HTTP è il protocollo del <strong>Web delle persone</strong>, CoAP è il protocollo del <strong>Web delle cose (IoT)</strong>.</p>
<p>REST tradizionale usa HTTP su TCP. Questo comporta un “peso” notevole per dispositivi alimentati a batteria
o con poca memoria. CoAP ottimizza questa struttura agendo su tre livelli:</p>
<ol class="arabic">
<li><p><strong>Dal Testo al Binario</strong></p>
<p>HTTP è testuale (leggibile dagli umani), il che lo rende verboso.
CoAP è binario e utilizza un header fisso di soli 4 byte.
In CoAP, un intero messaggio può stare in meno di 10-20 byte.</p>
</li>
<li><p><strong>Da TCP a UDP</strong></p>
<p>TCP richiede un “handshake” (3 passaggi) per stabilire la connessione e gestisce la
ri-trasmissione in modo complesso. CoAP gira su UDP, che è “senza connessione”.
CoAP implementa la propria affidabilità (<a class="reference internal" href="#messaggi-confirmable"><span class="std std-ref">Messaggi Confirmable</span></a>) solo quando serve,
risparmiando energia e traffico di rete.</p>
</li>
<li><p><strong>Non solo Request/Response</strong></p>
<p>In REST/HTTP, per un aggiornamento, occorre fare polling (chiedere continuamente).
CoAP introduce il <strong>meccanismo Observe</strong>: un client si “iscrive” a una <strong>risorsa</strong> e il server
invia un aggiornamento solo quando il valore cambia.
È un ibrido tra REST e Publish/Subscribe.</p>
</li>
</ol>
<section id="messaggi-confirmable">
<span id="id63"></span><h4>Messaggi Confirmable<a class="headerlink" href="#messaggi-confirmable" title="Permalink to this heading">¶</a></h4>
<p>I messaggi Confirmable (<strong>CON</strong>) rappresentano il meccanismo principale per garantire in CoAP
l’affidabilità della comunicazione sopra il protocollo di trasporto <code class="docutils literal notranslate"><span class="pre">UDP</span></code>, che di per sé non è affidabile.</p>
<p>Un messaggio contrassegnato come Confirmable richiede una conferma esplicita dal destinatario.</p>
<ul class="simple">
<li><p><strong>Acknowledge</strong> (ACK): Quando il server riceve un messaggio CON, deve rispondere con un pacchetto ACK.</p></li>
<li><p><strong>Message ID</strong>: Per collegare correttamente la conferma al messaggio originale,
l’ACK deve contenere lo stesso Message ID del messaggio CON inviato.</p></li>
<li><p><strong>Ritrasmissione</strong>: Se il mittente non riceve l’ACK entro un determinato intervallo (timeout),
il messaggio CON viene inviato nuovamente. Questo processo continua fino a quando non arriva
la conferma o viene raggiunto il numero massimo di tentativi.</p></li>
</ul>
<p>Se il server CoAP può elaborare la richiesta immediatamente, include i dati della risposta direttamente nel pacchetto ACK
(<strong>Piggybacked Response</strong>).
Altrimenti,  invia prima un ACK vuoto (per fermare le ritrasmissioni del client) e, una volta pronti i dati,
invia un nuovo messaggio CON verso il client, che a sua volta dovrà rispondere con un ACK (<strong>Separate Response</strong>).</p>
</section>
</section>
<section id="websockets">
<span id="id64"></span><h3>WebSocket<a class="headerlink" href="#websockets" title="Permalink to this heading">¶</a></h3>
<p>Il protocollo <em>WebSocket</em> (<strong>WS</strong>) è nato nato per risolvere il limite della comunicazione unidirezionale di HTTP.</p>
<p><strong>WS</strong> consente a due o più computer di comunicare tra loro in modo full-duplex
su una singola <strong>connessione TCP</strong>. È uno strato molto sottile su TCP che trasforma un flusso di byte
in un flusso di messaggi (testo o binario).</p>
<ul class="simple">
<li><p>Con REST, per sapere se ci sono novità, occorre chiedere continuamente (<strong>Polling</strong>).
In WebSockets, si apre la connessione una volta e il server emette i dati appena sono pronti.
Ciò aumenta l’efficienza.</p></li>
<li><p>Tuttavia, gestire migliaia di connessioni sempre aperte è costoso in termini di memoria del server.
REST è più efficiente per operazioni “mordi e fuggi” (es. leggere un articolo di un blog).
Dunque, <strong>WS</strong> non è un sostituto totale di REST:</p></li>
<li><p><strong>WS</strong> ha come uso ideale: Chat, notifiche live, cruscotti finanziari, giochi online.</p></li>
</ul>
<p>Nella sua forma più semplice,</p>
<p><strong>un WebSocket è solo un canale di comunicazione tra due applicazioni</strong></p>
<p>e non deve essere necessariamente coinvolto un browser.
Tuttavia l’uso più comune di WebSocket è facilitare la comunicazione tra un un’applicazione server
e un’applicazione basata su browser, avendo il vantaggio di realizzare comunicazioni asincrone bidirezionali
e in tempo reale.</p>
<p>Mentre in HTTP ogni singola richiesta porta con sé il “metodo” (<code class="docutils literal notranslate"><span class="pre">GET/POST</span></code>)
e il “path” (<code class="docutils literal notranslate"><span class="pre">/xxx</span></code>), nel protocollo WebSocket, una volta stabilita la connessione,
i messaggi sono solo <strong>sequenze di byte o testo</strong> senza alcun metadato di instradamento.</p>
<p>Sorge un problema:
una volta che aperta una <strong>WS</strong> verso un servizio, occorre sapere cosa inviare
e cosa aspettarsi. Senza uno standard, l’unico modo è leggere il codice Java o qualche documentazione scritta a mano.</p>
<p>A questo scopo è stato introdotto <span class="xref std std-ref">AsyncAPI</span>, di cui parliamo nell’apposito capitolo.</p>
<section id="la-fase-di-connessione-nelle-ws">
<span id="id65"></span><h4>La fase di connessione nelle WS<a class="headerlink" href="#la-fase-di-connessione-nelle-ws" title="Permalink to this heading">¶</a></h4>
<p>Ogni WebSocket inizia la sua vita come una normale richiesta <strong>HTTP GET</strong>.</p>
<ul class="simple">
<li><p>Il client invia: <cite>GET /xxx HTTP/1.1</cite> con l’intestazione <cite>Upgrade: websocket</cite>.</p></li>
</ul>
<p>Questo <strong>instradamento della connessione</strong> apre la via a diverse forme di <a class="reference internal" href="#instradamento-del-messaggio"><span class="std std-ref">Instradamento del messaggio</span></a>,
in accodo a diverse tecniche che permettono a un
<strong>server WebSocket</strong> di gestire molteplici funzionalità sulla stessa porta.</p>
</section>
<section id="instradamento-del-messaggio">
<span id="id66"></span><h4>Instradamento del messaggio<a class="headerlink" href="#instradamento-del-messaggio" title="Permalink to this heading">¶</a></h4>
<p>Volendo inviare ordini diversi (es. “fai questo”, “fai quello”)
sulla <strong>stessa</strong> connessione WebSocket, il protocollo non aiuta perché non ci sono “header” nei messaggi.
Per risolvere questo “vuoto” di informazioni, i server e gli sviluppatori usano tre strategie:</p>
<ul>
<li><ol class="upperalpha simple">
<li><p>Il modello “<strong>Un path, una funzione</strong>”</p></li>
</ol>
<p>È la soluzione più semplice. Creiamo connessioni diverse per scopi diversi.</p>
<ul class="simple">
<li><p>Connessione A -&gt; <cite>/xxx1</cite></p></li>
<li><p>Connessione B -&gt; <cite>/xxx2</cite></p></li>
</ul>
<p>Il “routing” avviene solo all’inizio. È adeguato se le funzionalità sono logicamente separate.</p>
</li>
<li><ol class="upperalpha simple" start="2">
<li><p><strong>Sotto-protocolli</strong> (Sub-protocols)</p></li>
</ol>
<p>Il protocollo WebSocket permette di definire un “sotto-protocollo” (es. <strong>STOMP</strong> o <strong>MQTT</strong>).
Questi aggiungono un piccolo header a ogni messaggio che dice: “Questo messaggio è per la coda X”.
Ciò complica il codice del client.</p>
</li>
<li><ol class="upperalpha simple" start="3">
<li><p>L’<strong>Envelope Pattern</strong> (Il “<strong>Facade</strong>” logico)</p></li>
</ol>
<p>Visto che il protocollo è “muto”, avvolgiamo il messaggio in una ‘busta’ (<em>envelope</em>) che contiene
le istruzioni di routing. È lo standard nell’industria moderna.</p>
<p><strong>Esempio di envelope JSON:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s2">&quot;xxx1&quot;</span><span class="p">,</span>
  <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;il mio input&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In questo caso, un server riceve il messaggio come stringa generica,
lo decodifica e usa uno <cite>switch</cite> nel codice Java per decidere cosa fare.</p>
<p><strong>Il routing non lo fa il protocollo, lo fai il codice applicativo.</strong></p>
</li>
</ul>
</section>
<section id="javalin-server">
<span id="id67"></span><h4>javalin server<a class="headerlink" href="#javalin-server" title="Permalink to this heading">¶</a></h4>
<p>Javalin è quello che in gergo viene definito un micro-framework per Java e Kotlin.
Javalin è per Java quello che <strong>Express.js</strong> è per <em>Node.js</em> o <strong>Flask</strong> è per <em>Python</em>.</p>
<p>A differenza di <a class="reference external" href="https://spring.io/projects/spring-boot">Spring Boot</a>, che è un “ecosistema” vasto e spesso pesante,
<em>Javalin</em> è progettato per essere estremamente leggero, semplice da imparare e
privo di configurazioni (niente file XML o annotazioni <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dalla <strong>versione 6</strong>, <em>Javalin</em> è diventato molto modulare, per cui è opportuno
usare la dipendenza <strong>javalin-bundle</strong>, che include tutto
il necessario per far girare WebSockets e rendering di template.</p>
</div>
<p><strong>Come opera javalin</strong></p>
<p>Javalin sfrutta il fatto che ogni WebSocket inizia la sua vita come una normale richiesta <strong>HTTP GET</strong>.</p>
<ol class="arabic simple">
<li><p>Il client invia: <cite>GET /xxx1 HTTP/1.1</cite> con l’intestazione <cite>Upgrade: websocket</cite>.</p></li>
<li><p>Javalin legge il path <cite>/xxx1</cite> come se fosse una normale pagina web.</p></li>
<li><p>In quel momento, Javalin “stacca” quella specifica connessione e la associa internamente
al blocco di codice che hai scritto per <cite>/xxx1</cite>.</p></li>
</ol>
<p>Da questo punto tutti i messaggi che arrivano su quella connessione
verranno passati alla funzione <cite>xxx11</cite>.
<strong>Il protocollo non instrada i messaggi, il server ricorda a quale “binario” appartiene la connessione.</strong></p>
<p><strong>In sintesi</strong></p>
<p>Javalin usa le informazioni dell’HTTP iniziale per separare i flussi.
Una volta che la connessione è aperta, il protocollo WebSocket è effettivamente un “tubo cieco”:</p>
<ul class="simple">
<li><p>Volendo  <strong>ordine e semplicità</strong>, è opportuno usare path diversi (<cite>/xxx1</cite>, <cite>/xxx2</cite>).</p></li>
<li><p>Volendo <strong>un solo path</strong>, occorre aggiungere  le informazioni di instradamento dentro
il messaggio (solitamente JSON) come detto in <a class="reference internal" href="#instradamento-del-messaggio"><span class="std std-ref">Instradamento del messaggio</span></a>.</p></li>
</ul>
<p>Javalin:</p>
<ul class="simple">
<li><p>è <strong>Imperativo/Bloccante</strong>: segue il modello “One Thread per Request”. Quando arriva una richiesta,
viene assegnato un thread che rimane occupato finché la funzione
non ha finito. È facile da leggere e da debuggare perché il codice segue un flusso lineare.</p></li>
<li><p>è un Framework Web: È progettato quasi esclusivamente per fare HTTP e WebSocket.
È un “guscio” attorno al <a class="reference internal" href="#server-jetty"><span class="std std-ref">Server Jetty</span></a>.</p></li>
<li><p>è ideale per trasformare una funzione semplice in un servizio accessibile</p></li>
</ul>
</section>
<section id="server-jetty">
<span id="id68"></span><h4>Server Jetty<a class="headerlink" href="#server-jetty" title="Permalink to this heading">¶</a></h4>
<p><a class="reference external" href="https://it.wikipedia.org/wiki/Jetty">Jetty</a> è un server web e un container di servlet Java, leggero, gratuito e open source,
gestito dalla Eclipse Foundation</p>
<p>A differenza di server più “monolitici” come Apache Tomcat, Jetty è nato per essere incorporato direttamente
nel codice di un’applicazione.</p>
<p>È ottimizzato per gestire un numero elevatissimo di connessioni simultanee con un basso consumo di memoria,
rendendolo ideale per applicazioni ad alta concorrenza.</p>
</section>
<section id="server-vert-x">
<span id="id69"></span><h4>Server Vert.x<a class="headerlink" href="#server-vert-x" title="Permalink to this heading">¶</a></h4>
<p>Un server javalin non è ideale se un sistema</p>
<ul class="simple">
<li><p>deve gestire decine di migliaia di connessioni WebSocket aperte contemporaneamente
(es. una chat massiva o un sistema di notifiche push)</p></li>
<li><p>ha bisogno di resilienza: se un componente fallisce, gli altri devono continuare a girare isolati</p></li>
<li><p>vuole usare più linguaggi di programmazione</p></li>
</ul>
<p>Una alternativa è impostare il server usando <a class="reference external" href="https://www.baeldung.com/vertx">Vert.x</a>:</p>
<ul class="simple">
<li><p>è <strong>Reattivo/Non-bloccante</strong>: i basa sul modello Event Loop (simile a Node.js).
Un solo thread (o pochissimi) gestisce migliaia di connessioni contemporaneamente.
Se la funzione richiesta deve attendere un dato, il thread non si blocca, ma passa subito a servire un’altra richiesta.</p></li>
<li><p>è un <strong>Toolkit per sistemi distribuiti</strong>: Non serve solo per il Web. Può essere usarlo per gestire protocolli
TCP, UDP, DNS, database, o persino per far comunicare diversi parti di software tramite un <strong>Event Bus</strong> interno.</p></li>
<li><p>non è solo un server, ma un insieme di <strong>Verticles</strong> (piccoli componenti isolati) che si scambiano messaggi.</p></li>
</ul>
</section>
</section>
</section>
<section id="sistemi-visti-dall-interno">
<h2>Sistemi visti dall’interno<a class="headerlink" href="#sistemi-visti-dall-interno" title="Permalink to this heading">¶</a></h2>
<p>Guardare un sistema software ‘dal di dentro’ significa poter capire meglio come è fatto e quali altre proprietà
abbia, oltre a quelle esposte nelle API.</p>
<p>Ovviamente l’interno di un sistema software è costituito da  un insieme di <em>istruzioni</em> (codice) scritte in qualche
linguaggio di programmazione e non è raro che, per molti sistemi, la lettura del codice risulti intricata
e <a class="reference internal" href="#sistemi-complicati"><span class="std std-ref">complicata</span></a> da capire.</p>
<p>Ma se un sistema software è ‘fatto bene’ il codice rivela subito una precisa <strong>architettura</strong> che ne rende
la comprensione più semplice.</p>
<section id="design-patterns">
<h3>Design patterns<a class="headerlink" href="#design-patterns" title="Permalink to this heading">¶</a></h3>
<p>I Design Pattern sono l’equivalente dei “modelli predefiniti” o delle “best practice”
consolidate nel mondo dell’ingegneria del software. Invece di reinventare ogni volta la ruota
per risolvere un problema ricorrente, si utilizza una <strong>soluzione architetturale</strong> che è già stata testata,
analizzata e raffinata da migliaia di sviluppatori.</p>
<p>Un pattern non è codice da copiare e incollare.
È piuttosto un <strong>progetto concettuale</strong> che descrive come risolvere un problema in una
determinata situazione.</p>
<p>Se l’architettura è la “strategia” (come dividiamo il sistema in grandi blocchi?),
i design pattern sono la “tattica” (come facciamo interagire questi blocchi in modo opportuno?).</p>
<p>I pattern vengono solitamente divisi in famiglie principali.
Ricordiamo qui le tre categorie classiche, la cui conoscenza diamo per scontata.</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Agli anni 90 del secolo scorso risale l’idea di <cite>pattern</cite>, culminata nella pubblicazione
nel <code class="docutils literal notranslate"><span class="pre">1995</span></code> dell’ormai famoso testo sui <a class="reference external" href="https://it.wikipedia.org/wiki/Design_pattern">Design Pattern</a>  della così detta <em>Gang-of-Four</em>
(<strong>GoF</strong>): <em>Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides</em>).</p></td>
<td><p>.</p>
<a class="reference internal image-reference" href="_images/DesignPatternGof.PNG"><img alt="_images/DesignPatternGof.PNG" class="align-center" src="_images/DesignPatternGof.PNG" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Un errore comune è cercare di “forzare” i pattern ovunque.
Questo porta alla cosiddetta <strong>Over-engineering</strong>: il codice diventa inutilmente complicato.
Un bravo architetto software usa i pattern solo quando la semplicità non è più sufficiente.</p>
<p>Dopo la introduzione dei pattern <strong>GoF</strong>, si sono susseguiti molte altre
proposte sui design pattern.
I riferimenti più noti sono i cinque testi <code class="docutils literal notranslate"><span class="pre">POSA</span></code>
sulle <em>Pattern oriented Software Architectures</em>
e i convegni <code class="docutils literal notranslate"><span class="pre">PLoP</span></code> (<em>Pattern Languages of Programming</em>).</p>
<section id="pattern-posa">
<h4>Pattern POSA<a class="headerlink" href="#pattern-posa" title="Permalink to this heading">¶</a></h4>
<p>Si riportano qui i pattern POSA (<em>Pattern oriented Software Architectures</em>) principali,
che intendono introdurre strutture nei
sistemi software, per superare il così detto <a class="reference internal" href="#big-ball-of-mud"><span class="std std-ref">Big Ball of Mud</span></a>.</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 2%" />
<col style="width: 98%" />
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><a class="reference internal image-reference" href="_images/Posa.PNG"><img alt="_images/Posa.PNG" class="align-center" src="_images/Posa.PNG" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Anche se non approfondiremo in modo sistematico questi pattern, ritroveremo
molte delle problematiche che motivano i vari pattern nei casi di studio
di sistemi distributi che affronteremo, poenendo particolare attenzione
sui <span class="xref std std-ref">Sistemi a Microservizi</span>.</p>
</section>
</section>
</section>
<section id="architettura-di-un-sistema">
<h2>Architettura di un sistema<a class="headerlink" href="#architettura-di-un-sistema" title="Permalink to this heading">¶</a></h2>
<p>Definire l’architettura software è sempre stato complicato perché il termine oscilla tra la struttura
tecnica e il processo decisionale. Oggi, la comunità scientifica e professionale converge
principalmente su due definizioni che si completano a vicenda.</p>
<section id="definizione-strutturale">
<h3>Definizione Strutturale<a class="headerlink" href="#definizione-strutturale" title="Permalink to this heading">¶</a></h3>
<p>Lo Standard ISO/IEC/IEEE 42010 recita:</p>
<ul class="simple">
<li><p>L’architettura software è l’organizzazione fondamentale di un sistema, definita dai suoi componenti,
dalle relazioni tra di essi e con l’ambiente, e dai principi che ne guidano il progetto e l’evoluzione.</p></li>
</ul>
</section>
<section id="definizione-pragmatica">
<h3>Definizione Pragmatica<a class="headerlink" href="#definizione-pragmatica" title="Permalink to this heading">¶</a></h3>
<p>Nel mondo dello sviluppo Agile e dei Microservizi, si sposta l’attenzione dal “disegno” alle scelte strategiche:</p>
<ul class="simple">
<li><p>L’architettura è l’insieme delle decisioni significative su come è costruito un sistema software;
sono le decisioni <strong>difficili da cambiare</strong> in un secondo momento</p></li>
</ul>
<p>Un’altra frase celebre nel settore dice:</p>
<ul class="simple">
<li><p>L’architettura è ciò che resta del sistema quando si rimuovono tutti i dettagli implementativi.</p></li>
</ul>
<p>Ovvero, è lo <strong>scheletro concettuale</strong> che permette di ragionare sul comportamento del software.</p>
</section>
<section id="evoluzione-delle-architetture">
<h3>Evoluzione delle architetture<a class="headerlink" href="#evoluzione-delle-architetture" title="Permalink to this heading">¶</a></h3>
<p>L’evoluzione delle architetture software è una storia di <em>astrazione crescente</em> e di <em>decentramento</em>.
Ogni fase è nata per risolvere un limite della precedente, passando da blocchi di codice indivisibili
a ecosistemi di funzioni atomiche che “vivono” nel cloud.</p>
<p>Un sintetico quadro di questa evoiluzione può essere tracciato come segue:</p>
<ol class="arabic">
<li><p>Il <strong>Monolite (Anni ‘60 - ‘80)</strong></p>
<p>Tutto il software risiede in un unico blocco logico.
Interfaccia utente, logica di business e accesso ai dati sono strettamente intrecciati.
Il software gira su un unico server (Mainframe)</p>
</li>
<li><p><strong>Client-Server (Anni ‘90)</strong></p>
<p>Con l’arrivo dei PC e delle reti locali, l’architettura si spacca in due (<strong>2-Tier</strong>).
Il Client (PC dell’utente) contiene l’interfaccia e la logica, mentre il Server gestisce solo il Database.</p>
</li>
<li><p><strong>Architettura N-Tier / Layered (Anni 2000)</strong></p>
<p>L’esplosione del Web induce a dividere il monolite in “strati” (<strong>layer</strong>) logici.
Si aggiunge uno strato intermedio (<strong>3-Tier</strong>):</p>
<p><code class="docutils literal notranslate"><span class="pre">Presentation</span> <span class="pre">(Browser)</span> <span class="pre">→</span> <span class="pre">Logic</span> <span class="pre">(Server</span> <span class="pre">Applicativo)</span> <span class="pre">→</span> <span class="pre">Data</span> <span class="pre">(Database)</span></code></p>
<p>Questo modello ha dominato l’era di Java EE e .NET, portando alla definizione di pattern come
il <em>Model-View-Controller</em> (<strong>MVC</strong>).</p>
</li>
<li><p><strong>SOA - Service Oriented Architecture (Metà anni 2000)</strong></p>
<p>Il sistema è un insieme di “servizi” che comunicano tramite un bus centrale (<strong>ESB</strong> - <em>Enterprise Service Bus</em>)
I servizi sono grandi e pesanti, spesso legati a protocolli complicati come SOAP e XML.</p>
</li>
<li><p><strong>Microservizi e Cloud-Native (2010 - Oggi)</strong></p>
<p>Il sistema è diviso in decine o centinaia di servizi minuscoli e autonomi.
Ogni servizio ha il suo DB, viene “impacchettato” in <strong>Docker</strong> e orchestrato da <strong>Kubernetes</strong>.
La comunicazione è leggera (REST, gRPC, WebSocket).</p>
</li>
<li><p><strong>Serverless ed Event-Driven (Il Presente)</strong></p></li>
</ol>
<blockquote>
<div><p>L’architettura non è più fatta di server sempre accesi, ma di singole funzioni che si attivano solo in risposta a un evento
(<strong>FaaS</strong> <em>Function as a Service</em>) gestito da un <em>Cloud Provider</em>.</p>
</div></blockquote>
</section>
<section id="big-ball-of-mud">
<span id="id70"></span><h3>Big Ball of Mud<a class="headerlink" href="#big-ball-of-mud" title="Permalink to this heading">¶</a></h3>
<p>Il concetto di <strong>Big Ball of Mud</strong> (<em>Grande Palla di Fango</em>) è stato evocatoo per la prima volta
in un saggio di <em>Brian Foote</em> e <em>Joseph Yoder</em> nel 1997.
Tuttavia, come problema sistematico, si è manifestato in momenti diversi dell’evoluzione architettonica,
diventando particolarmente critico durante la transizione tra gli anni ‘80 e ‘90.</p>
<p>Nel 1997, quando Foote e Yoder pubblicarono il loro saggio,
nonostante i nuovi Design Pattern, la maggior parte del software reale non era affatto “pulito”.</p>
<p>La fretta, i requisiti che cambiano continuamente e il turnover degli sviluppatori portavano
naturalmente il codice verso la “Palla di Fango”, cioè
verso uno stato di entropia massima del software: un sistema che cresce senza un’architettura definita,
dove ogni parte dipende da ogni altro parte.</p>
<p>Nella storia del software, il “Big Ball of Mud” si manifesta ogni volta che la velocità
di sviluppo prevale sulla disciplina architettonica.
Senza uno <strong>sforzo cosciente</strong> per applicare principi organizzivi
(come i <a class="reference internal" href="#principi-solid"><span class="std std-ref">Principi SOLID</span></a> o
le <a class="reference internal" href="#clean-architectures"><span class="std std-ref">Clean Architecture</span></a>, il sistema, inevitabilmente, si presenta internamente  una palla di fango.</p>
<p><strong>L’architettura è costosa, ma la mancanza di architettura costa molto di più.</strong></p>
</section>
<section id="principi-solid">
<span id="id71"></span><h3>Principi SOLID<a class="headerlink" href="#principi-solid" title="Permalink to this heading">¶</a></h3>
<p>I principi SOLID sono nati nel contesto della <em>Programmazione Orientata agli Oggetti</em> (OOP),
ma oggi sono considerati principi universali di progettazione software, applicabili a livello di architettura,
microservizi e persino organizzazione dei dati.</p>
<section id="srp-single-responsibility">
<span id="single-responsibility"></span><h4>SRP-Single responsibility<a class="headerlink" href="#srp-single-responsibility" title="Permalink to this heading">¶</a></h4>
<p><strong>Single responsibility principle</strong>:  in OOP, una classe dovrebbe avere una, e una sola, ragione per cambiare.</p>
<ul class="simple">
<li><p>Concetto Universale: <strong>Coesione</strong>. Ogni componente del sistema deve fare (bene) una cosa sola.</p></li>
<li><p>In Architettura: Un microservizio (o un modulo del Monolite Modulare) deve gestire una sola funzionalità
di business. Se il servizio “Ordini” gestisce anche la “Generazione PDF delle fatture” e il “Tracking GPS”,
si sta violando l’SRP a livello macroscopico.</p></li>
</ul>
</section>
<section id="ocp-open-closed">
<span id="open-closed"></span><h4>OCP-Open/closed<a class="headerlink" href="#ocp-open-closed" title="Permalink to this heading">¶</a></h4>
<p><strong>Open-closed principle</strong>:  in OOP, una classe dovrebbe essere aperta per l’estensione ma chiusa per la modifica.</p>
<ul class="simple">
<li><p>Concetto Universale: <strong>Estensibilità</strong>. Usare interfacce o “hook” per permettere l’evoluzione del sistema
senza toccare il codice sorgente originale.</p></li>
<li><p>In Architettura: Un sistema deve permettere l’aggiunta di nuove funzionalità senza riscrivere il nucleo esistente.
Si pensa ai Plugin o alle Estensioni dei browser.</p></li>
</ul>
</section>
<section id="lsp-liskov-substitution">
<span id="liskov-substitution"></span><h4>LSP-Liskov substitution<a class="headerlink" href="#lsp-liskov-substitution" title="Permalink to this heading">¶</a></h4>
<p><strong>Liskov’s substitution principle</strong>: in OOP, gli oggetti in un programma dovrebbero essere sostituibili
con istanze dei loro sottotipi senza alterare la correttezza di quel programma.</p>
<ul class="simple">
<li><p>Concetto Universale: <strong>Intercambiabilità</strong>. Il rispetto del “contratto” garantisce che il sistema
non collassi sostituendo un componente.</p></li>
<li><p>In Architettura: Questo è il principio cardine delle Interfacce API e dei Contratti (come AsyncAPI).
Se si sostituisce il servizio xxx1 versione A con la versione B, il client non deve accorgersi della differenza.</p></li>
</ul>
</section>
<section id="isp-interface-segregation">
<span id="interface-segregation"></span><h4>ISP-Interface segregation<a class="headerlink" href="#isp-interface-segregation" title="Permalink to this heading">¶</a></h4>
<p><strong>Interface segregation principle</strong>: in OOP, molte interfacce specifiche del client sono migliori di un’interfaccia generica.</p>
<ul class="simple">
<li><p>Concetto Universale: <strong>Minimo Privilegio Informativo</strong>. Fornire solo ciò che serve per quel compito specifico
(molto rilevante nella sicurezza e nelle performance).</p></li>
<li><p>In Architettura: Evitare i “Modelli Dati Giganti”. Se un client ha bisogno solo dell’indirizzo di un utente,
non inviargli l’intero oggetto JSON con password, storico acquisti e preferenze.</p></li>
</ul>
</section>
<section id="dip-dependency-inversion">
<span id="dependency-inversion"></span><h4>DIP-Dependency inversion<a class="headerlink" href="#dip-dependency-inversion" title="Permalink to this heading">¶</a></h4>
<p><strong>Dependency inversion principle</strong>: si dovrebbe dipendere dalle astrazioni, non dalle implementazioni.</p>
<ul class="simple">
<li><p>Concetto Universale: <strong>Disaccoppiamento</strong>. L’astrazione protegge la logica di business dalle tecnologie volatili.</p></li>
<li><p>In Architettura: È il fondamento della <a class="reference internal" href="#architettura-port-adapter"><span class="std std-ref">Architettura Port/Adapter</span></a>.
Il “cuore” logico della applicazione non deve dipendere dal database specifico (MySQL o MongoDB)
o dal protocollo (WebSocket o CoAP). Sono il database e il protocollo che devono “adattarsi” alle porte del sistema.</p></li>
</ul>
<p>Se il codice sorgetne di un componente di alto livello dipende da quello di un componente di basso livello,
i cambiamenti nei componenti di basso livello si diffonderanno al componente di alto livello.
Pertanto, poniamo un confine tra i due, usando il polimorfismo per invertire il flusso logico.</p>
</section>
</section>
<section id="clean-architectures">
<span id="id72"></span><h3>Clean Architecture<a class="headerlink" href="#clean-architectures" title="Permalink to this heading">¶</a></h3>
<p>E’ un’architettura che segue i principi SOLID.
L’idea chiave è quella di utilizzare il <a class="reference internal" href="#dependency-inversion"><span class="std std-ref">principio di inversione delle dipendenze</span></a> per tracciare
confini tra componenti di alto livello e componenti di basso livello.
Questo crea un’architettura “plug-in” che mantiene il sistema flessibile e manutenibile.</p>
<p>Vediamo un esempio, preso da :ref:Clean Architecture:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Le regole aziendali dipendono dall’interfaccia anziché dalla classe di database concreta.</p>
<p>Il database diventa un plug-in delle regole aziendali: un componente di basso livello
che può essere modificato senza influenzare le regole aziendali (componente di alto livello).</p>
</td>
<td><p>.</p>
<a class="reference internal image-reference" href="_images/EsempioInversioneDip.PNG"><img alt="_images/EsempioInversioneDip.PNG" class="align-center" src="_images/EsempioInversioneDip.PNG" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
<section id="architettura-port-adapter">
<span id="id73"></span><h4>Architettura Port/Adapter<a class="headerlink" href="#architettura-port-adapter" title="Permalink to this heading">¶</a></h4>
<p>L’architettura <strong>esagonale</strong> (anche nota come <em>Port-Adapter</em>) è, tra le tante Architetture di sistemi software
oggi in uso, quella cui noi faremo particolare attenzione.</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Si identificano quattro layer principali</p>
<ul class="simple">
<li><p>Entities: oggetti che contengono la logica aziendale critica.</p></li>
<li><p>Use-cases: regole aziendali specifiche dell’applicazione</p></li>
<li><p>Interface adapters: gateway, presentatori e controller.
Ad esempio, questo livello contiene l’architettura MVC della GUI e anche oggetti che trasformano
i dati tra il formato del database e i casi d’uso.</p></li>
<li><p>Frameworks and drivers: framework web, database, la vista di MVC</p></li>
</ul>
</td>
<td><p>.</p>
<a class="reference internal image-reference" href="_images/portAdapterArch.PNG"><img alt="_images/portAdapterArch.PNG" class="align-center" src="_images/portAdapterArch.PNG" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="bounded-context">
<span id="id74"></span><h3>Bounded Context<a class="headerlink" href="#bounded-context" title="Permalink to this heading">¶</a></h3>
<p>Il concetto di Bounded Context è stato introdotto da Eric Evans nel 2003
e da allora è diventato uno dei pilastri del <a class="reference external" href="https://it.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a> (<strong>DDD</strong>)
ed ha ha avuto grande influenza anche sull’evoluzione dei <span class="xref std std-ref">Sistemi a Microservizi</span>,
dove il concetto è stato ripreso e applicato in modo molto concreto.</p>
<p>Il <strong>Bounded Context</strong> rappresenta un <em>confine esplicito</em> entro il quale un modello di dominio
è definito e applicato in modo coerente. All’interno di questo perimetro, termini, regole di business e
significato dei concetti sono univoci e condivisi dal team che lavora su quel contesto.</p>
<p>Lo stesso termine può avere significati diversi in contesti differenti, senza creare ambiguità,
proprio grazie alla separazione dei confini.</p>
<p>Uno degli aspetti chiave è la <strong>gestione della complessità</strong>: suddividendo un sistema ampio in più Bounded Context,
si evitano modelli di dominio “onnicomprensivi” e difficili da mantenere.
Ogni contesto si concentra su una specifica area del dominio, favorendo chiarezza, evoluzione indipendente
e maggiore qualità del software.</p>
<p>Il Bounded Context è anche fondamentale per l’<strong>allineamento tra business e tecnologia</strong>.
Definendo un <em>linguaggio ubiquo</em> valido solo all’interno del contesto, sviluppatori ed esperti di dominio
comunicano in modo più efficace, riducendo incomprensioni e traduzioni errate dei requisiti.</p>
<ul class="simple">
<li><p>Ad esempio, se un sistema software amplia le proprie funzionalià,
si potrebbe avere una parte che si occupa di Vendite e una di Spedizioni.
Nel Bounded Context “Vendite”, la parola <em>Prodotto</em> implica “prezzo e descrizione”.
Nel Bounded Context “Spedizioni”, <em>Prodotto</em> implica “peso e dimensioni”.</p></li>
</ul>
<p>Infine, i Bounded Context hanno un ruolo centrale nell’<strong>architettura dei sistemi distribuiti</strong>,
come i microservizi: spesso esiste una forte corrispondenza tra un Bounded Context e un servizio,
permettendo indipendenza di deploy, scalabilità mirata e isolamento dei cambiamenti.</p>
<section id="bounded-context-e-clean-architecture">
<h4>Bounded Context e Clean Architecture<a class="headerlink" href="#bounded-context-e-clean-architecture" title="Permalink to this heading">¶</a></h4>
<p>Una volta stabilito che siamo dentro un Bounded Context (ad esempio “Vendite”),
il codice può essere organizzato secondo la Clean Architecture.</p>
<p>Mentre il Bounded Context (dal Domain-Driven Design) definisce i <strong>confini orizzontali</strong>
(le diverse aree di business),
la Clean Architecture definisce i <strong>confini verticali</strong> (all’interno di ogni singola area, tra logica e tecnologia).</p>
<p>Un (micro)servizio ben progettato è:</p>
<p>Un’unità di deploy che racchiude un singolo Bounded Context, organizzata internamente
secondo la Clean Architecture.</p>
</section>
</section>
</section>
<section id="costruiamo-sistemi-software">
<span id="costruiamo"></span><h2>Costruiamo sistemi software<a class="headerlink" href="#costruiamo-sistemi-software" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="#iltesting"><span class="std std-ref">Il testing</span></a></p>
<p>Il noto fisico <em>Richard Feynmann</em> (Premio Nobel per la fisica nel 1965 per l’elaborazione
dell’elettrodinamica quantistica) ha detto:</p>
<p><strong>Quello che non posso creare, non lo saprò mai capire</strong></p>
<p>Se è vero che <em>non creare implica non capire</em>, allore <strong>capire implica creare</strong>.</p>
<p>Il filosofo napoletano <em>Giambattista Vico</em> (1668-1744)
espreese il motto <strong>Verum ipsum factum</strong> (<em>la verità è nello stesso fare</em>)
sostenendo che l’uomo può conoscere perfettamente solo ciò che egli stesso ha costruito
(come la geometria, la matematica o la storia), mentre non potrà mai capire appieno la natura.
Il principio è considerato un esempio di <em>epistemologia costruttivista</em>,
dove il soggetto conoscente è la causa di ciò che conosce.</p>
<p><em>Seymour Papert</em>, co-creatore del linguaggio <a class="reference external" href="https://it.wikipedia.org/wiki/Logo_(informatica)">Logo</a>, ha coniato il termine <strong>Costruzionismo</strong>:</p>
<p><strong>L’apprendimento avviene in modo particolarmente efficace quando le persone
sono impegnate nella costruzione di un prodotto reale.</strong></p>
<p>In accordo a queste visioni, nel seguito affrontermo la progettazione e costruzione
di un insieme di sistemi software, scelti in modo da ‘capire meglio’
i temi esposti in precedenza in questo capitolo (e anche
per approfondire la comprensione dei sistemi complessi).</p>
<section id="il-filo-conduttore">
<span id="id75"></span><h3>Il filo conduttore<a class="headerlink" href="#il-filo-conduttore" title="Permalink to this heading">¶</a></h3>
<p>Il nostro filo conduttore sarà il gioco <a class="reference internal" href="#game-of-life-di-conway"><span class="std std-ref">Game of Life di Conway</span></a> che
nasce come un sistema <strong>semplice da capire e costruire</strong>, ma che
presenta <strong>risultati complessi</strong>.</p>
<p>Useremo questo gioco come <em>caso di studio</em> per costruire sistemi
organizzati secondo architetture diverse:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#game-of-life-di-conway"><span class="std std-ref">Game of Life di Conway</span></a>: un ‘normale’ programma Java ad oggetti.</p></li>
<li><p><span class="xref std std-ref">Una GUI HTML per Game of Life</span>: evoluzione del sistema precedente
in un sistema distribuito in stile MVC.</p></li>
<li><p><span class="xref std std-ref">Game of Life con protoattori</span>: una prima sperimentazione del concetto di attore,
limitata alla costruzione del controllore del gioco nella versione distribuita.</p></li>
<li><p><span class="xref std std-ref">Game of Life ad attori</span>: una versione in cui tutte le celle sono attori/microservizi
autonomi che producono il risultato tramite scambio di messaggi</p></li>
</ul>
<section id="altre-sperimentazioni">
<h4>Altre sperimentazioni<a class="headerlink" href="#altre-sperimentazioni" title="Permalink to this heading">¶</a></h4>
<p>Questo caso di studio sarà affiancato dalla costruzione di altri sistemi:</p>
<ul class="simple">
<li><p><span class="xref std std-ref">Da una funzione a un servizio</span>: come costruire non solo prodotti a sè stanti,
ma anche librerie e framework capaci di rendere i sistemi distributi indipendenti
dai dettagli tecnologici dei vari protocolli di comunicazione</p></li>
<li><p><span class="xref std std-ref">Costruzione del sistema_S in qak</span>: come definire un modello eseguibile
del sistema precedente con <span class="xref std std-ref">Il linguaggio qak</span>, da noi creato per dare una <strong>proiezione
semantica</strong> alle librerie introdotte in precedenza</p></li>
<li><p>firefly: ogni lucciola è un attore che sincronizza la propria emissione di luce con tutte
le altre lucciole</p></li>
<li><p>IOT su Raspberry</p></li>
<li><p>Robot (virtuale e/o reali) situati</p></li>
</ul>
</section>
</section>
</section>
<section id="processi-di-costruzione-del-software">
<h2>Processi di costruzione del software<a class="headerlink" href="#processi-di-costruzione-del-software" title="Permalink to this heading">¶</a></h2>
<p>Oggi si ritiene che un <strong>approccio INCREMENTALE</strong> sia  indispensabile per aggredire
i problemi applicativi e per
mettere in luce in primis gli aspetti
PIU’ IMPORTANTI e PIU’ CRITICI, senza perdersi in dettagli che possono distogliere
l’attenzione per formare un quadro generale di riferimento.</p>
<p>L’approccio <cite>AGILE</cite> descritto in <a class="reference external" href="https://scrumguides.org/">SCRUM Guide</a> è oggi un punto di riferimento.</p>
<a class="reference internal image-reference" href="_images/AgileDevelop.PNG"><img alt="_images/AgileDevelop.PNG" class="align-center" src="_images/AgileDevelop.PNG" style="width: 90%;" /></a>
<p>I vari SPRINT dovrebbero effettuare uno <strong>ZOOMING</strong> entro i MACRO-COMPONENTI
della architettura logica del sistema,
innescando un <strong>processo ITERATIVO</strong> di analisi, progetto , sviluppo e testing di
quel componente o del SOTTOSISTEMA  che lo SPRINT vuole costruire.</p>
</section>
<section id="il-testing">
<span id="iltesting"></span><h2>Il testing<a class="headerlink" href="#il-testing" title="Permalink to this heading">¶</a></h2>
<p>L’obiettivo della fase di testing è quello di trovare il maggior numero di situazioni
che conducono ad errori con il minimo numero di casi di prova.</p>
<p>La fase di testing del software è  attività imprescindibile per garantirne la qualità ed è anche
indispensabile per garantire all’utente una <em>user experience</em> soddisfacente.</p>
<p>In <a class="reference external" href="https://www.ibm.com/it-it/topics/software-testing">Software testing IBM</a>  leggiamo che:</p>
<ul class="simple">
<li><p>Negli anni ‘90 c’è stata una transizione dai test a un processo più completo denominato
<cite>controllo di qualità</cite>, che copre l’intero ciclo di sviluppo del software e riguarda
i processi di pianificazione, progettazione, creazione ed esecuzione di casi di test.</p></li>
<li><p>I test del software sono stati tradizionalmente separati dal resto dello sviluppo, ma
molti team di sviluppo  usano ora una metodologia nota come <strong>test continuo</strong>.</p></li>
</ul>
<p>E’ importante sottolienare che i test <strong>non vanno pensati ed eseguiti dopo</strong> aver scritto
il codice, ma sono modi per chiarire/formalizzare i requisiti di una applicazione
e anche per organizzare il lavoro di produzione.</p>
<p>Un  <em>piano di testing</em> (<strong>TestPlan</strong>)  ha di solito lo scopo di stabilire la gerarchia con cui i test
vanno eseguiti, i metodi di esecuzione, i criteri di accettazione e prevede diverse tipologie di test,
tra cui:</p>
<ul>
<li><p><strong>Unit test</strong> (Test di unità o di modulo)
Ha l’obiettivo di individuare gli errori nel singolo modulo software.</p></li>
<li><p><strong>Integration Test</strong> (Test di integrazione)
Ha l’obiettivo di individuare gli errori nel software quando tutti i moduli che compongono un sottosistema
o l’intero sistema vengono fatti lavorare assieme.</p></li>
<li><p><strong>System Test</strong> (Test di sistema)
Ha l’obiettivo di garantire che il prodotto software nel suo complesso soddisfi completamente
i requisiti iniziali. E’ un collaudo interno.</p></li>
<li><p><strong>Functional Test</strong> (Test legato ai requisit)
verifica che il sistema implementi correttamente le funzionalità specificate, producendo gli output attesi
a fronte di input noti, indipendentemente da come il sistema è implementato internamente.
In altre parole, verifica <strong>cosa fa</strong> il sistema, <strong>non come</strong> lo fa.</p></li>
<li><p><strong>User Acceptance Test</strong> (Test di accettazione)
Ha l’obiettivo di valutare la rispondenza dell’applicazione software rispetto ai requisiti
espressi inizialmente nel contratto e di ottenere l’accettazione formale del cliente di quanto realizzato.
Il test viene effettuato dal cliente nel suo ambiente di test, e da un gruppo di utenti.</p></li>
<li><p><strong>Alpha test e Beta test</strong>
Un <cite>alpha test</cite> è un test preliminare di un’applicazione software anche non ancora completa,
eseguito da alcuni potenziali utenti rappresentati da un team.</p>
<p>Un <cite>beta test</cite> ha l’obiettivo di far valutare al cliente, prima della distribuzione ufficiale del sistema,
la reale funzionalità, completezza ed operatività dell’applicazione.</p>
</li>
<li><p><strong>Regression Test</strong> (test di non regressione)
Ha l’obiettivo di verificare a valle di una manutenzione, dopo che un bug è stato individuato e corretto
e sono stati eseguiti esattamente gli stessi test che erano stati effettuati quando era stato individuato il problema.</p></li>
<li><p><strong>Stress test</strong> (test di carico)
Ha l’obiettivo di determinare il punto di rottura di un sistema software,
oltre il quale si verificano instabilità del sistema, perdita dei dati o interruzione del servizio.</p></li>
</ul>
<p>Sul problema del testing si trova moltissimo materiale in rete.
Riportiamo qui alcuni riferimenti utili sul ‘piano pragmatico’:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Software_testing">Software testing</a> (wikipedia)</p></li>
<li><p><a class="reference external" href="http://sqa.fyicenter.com/FAQ/Automated-Testing-Plan/">Automated-Testing-Plan FAQ</a></p></li>
</ul>
<p>Il <em>test continuo</em> è parte dell’approccio <a class="reference external" href="https://it.wikipedia.org/wiki/DevOps">DevOps</a>, in cui sviluppo e operazioni collaborano
per l’intero ciclo di vita del prodotto. L’obiettivo è quello di accelerare la fornitura del software,
bilanciando al tempo stesso i costi, la qualità e i rischi.</p>
<p>L’obiettivo di definire fin dalle fasi di analisi un  <strong>TestPlan</strong> con test automatizzabili
di un sistema applicativo, introduce di fatto, per il progettisto del sistema, un <strong>nuovo requisito</strong>:
<cite>rendere  l’applicazione osservabile</cite>, o meglio:</p>
<p><strong>rendere verificabili, da parte di una macchina, gli effetti di un sistema software</strong></p>
<section id="il-nostro-metodo-di-lavoro">
<span id="id76"></span><h3>Il nostro metodo di lavoro<a class="headerlink" href="#il-nostro-metodo-di-lavoro" title="Permalink to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Partiamo dall’insieme di <strong>requisiti forniti dal committente</strong> ed espressi in linguaggio naturale</p></li>
<li><p>Impostiamo lo <code class="docutils literal notranslate"><span class="pre">SPRINT0</span></code> come una <strong>analisi dei requisiti</strong> che mira a esprimerli in modo comprensibile anche alla macchina introducendo:</p>
<ul class="simple">
<li><p>un modello (eseguibile) dell’architattura del sistema desunta dai requisiti</p></li>
<li><p>un (primo) <em>TestPlan</em> di <strong>Functional Tests</strong></p></li>
</ul>
</li>
<li><p>Impostiamo una <strong>analisi del problema</strong> che mira a definire:</p>
<ul class="simple">
<li><p>una <strong>architettura logica</strong> del sistema come risultato dall’analisi</p></li>
<li><p>un piano di lavoro</p></li>
<li><p>una possibile estensione ai piani di testing funzionali</p></li>
<li><p>la definizione del <em>primo SPRINT</em> della produzione</p></li>
</ul>
</li>
<li><p>Impostiamo ogni SPRINT come un <strong>sottoprogetto</strong> con sua propria spiegazione e testing.</p>
<ul class="simple">
<li><p>Lo SPRINT <span class="math notranslate nohighlight">\(n+1\)</span> parte dai risultati dello sprint <span class="math notranslate nohighlight">\(n\)</span> e costruisce un sottosistema (funzionante)
che sarà l’input dello SPRINT <span class="math notranslate nohighlight">\(n+2\)</span>.</p></li>
</ul>
</li>
<li><p>Facciamo seguire ad ogni SPRINT una fase di <a class="reference external" href="https://www.agileway.it/sprint-review-meeting/">Sprint review</a> i cui meeting saranno</p>
<ul class="simple">
<li><p><strong>un nuovo modo di concepire le ore di ricevimento-studenti</strong></p></li>
</ul>
</li>
<li><p>Per ogni  SPRINT, compiliamo un documento (si veda <span class="xref std std-ref">La documentazione del lavoro</span>)
per <strong>rendere esplcite</strong> le conoscenze,
le decisioni, i modelli, etc. introdotti nello SPRINT,
fornendo indicazioni all’utente finale su come eseguire lo SPRINT.</p></li>
</ol>
<section id="il-diario-di-bordo">
<h4>Il diario di bordo<a class="headerlink" href="#il-diario-di-bordo" title="Permalink to this heading">¶</a></h4>
<p>Ogni porgetto da noi impostato, deve avere un <cite>diario di bordo</cite>,
organizzato secondo un preciso <a class="reference external" href="_static/templateToFill.html">template</a>. Questo diario deve essere compilato
<strong>in itinere</strong>
con indicazioni <strong>sintetiche ed essenziali</strong>, man mano si svolge
il processo di produzione e <cite>non dopo</cite> avere sviluppato il codice.</p>
</section>
<section id="il-template-del-diario">
<h4>Il template del diario<a class="headerlink" href="#il-template-del-diario" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">Introduction</span>
<span class="o">-</span> <span class="n">Requirements</span>

     <span class="n">Copy</span> <span class="n">here</span> <span class="n">the</span> <span class="n">EXACT</span> <span class="n">text</span> <span class="n">given</span> <span class="n">by</span> <span class="n">the</span> <span class="n">customer</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Requirement</span> <span class="n">analysis</span>
<span class="o">-</span> <span class="n">Problem</span> <span class="n">analysis</span>
<span class="o">-</span> <span class="n">Test</span> <span class="n">plans</span>
<span class="o">-</span> <span class="n">Project</span>
<span class="o">-</span> <span class="n">Testing</span>
<span class="o">-</span> <span class="n">Deployment</span>
<span class="o">-</span> <span class="n">Maintenance</span>
<span class="o">-</span> <span class="n">About</span> <span class="n">the</span> <span class="n">team</span> <span class="p">(</span><span class="n">massimo</span> <span class="mi">3</span> <span class="n">worker</span><span class="p">)</span>

   <span class="o">-</span> <span class="n">CognomeNomeMatricola</span> <span class="k">del</span> <span class="n">worker1</span>
   <span class="o">-</span> <span class="o">...</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="game-of-life-di-conway">
<span id="id77"></span><h1>Game of Life di Conway<a class="headerlink" href="#game-of-life-di-conway" title="Permalink to this heading">¶</a></h1>
<p>Affrontiamo la
costruzione di un sistema software ispirato al famoso automa cellulare di
<strong>John Horton Conway</strong>: il <strong>Game of Life</strong> (<em>GofLife</em>).</p>
<p>Questo gioco viene usato come <a class="reference internal" href="#il-filo-conduttore"><span class="std std-ref">Il filo conduttore</span></a> del nostro <em>“approccio costruttivistivco”</em>
alla comprensione dei problemi inerenti la realizzazione a la natura dei sistemi software moderni.
Infatti il gioco implica un sistema <strong>semplice</strong> da capire e costruire, ma che presenta
<strong>risultati complessi</strong>.</p>
<p>Il mondo di <em>GofLife</em> è una griglia infinita di celle quadrate. Ogni cella può trovarsi in soli due stati:
VIVA (accesa) o MORTA (spenta).</p>
<p>GofLife è un “zero-player game”: la sua evoluzione è determinata interamente dallo stato iniziale della griglia.
Ad ogni “tick” di un clock (<strong>generazione</strong> o <strong>Epoch</strong>), si applicano quattro <strong>regole</strong>
basate sui  vicini di ogni cella:</p>
<ul class="simple">
<li><p>Una cella viva con meno di due celle vive adiacenti muore (per isolamento).</p></li>
<li><p>Una cella viva con due o tre celle vive adiacenti sopravvive alla generazione successiva.</p></li>
<li><p>Una cella viva con più di tre celle vive adiacenti muore (per sovrappopolazione).</p></li>
<li><p>Una cella morta con esattamente tre celle vive adiacenti diventa una cella viva (per riproduzione).</p></li>
</ul>
<p>Nel caso di grigla infinita, ogni cella ha esattamente <code class="docutils literal notranslate"><span class="pre">8</span></code> vicini (orizzontali, verticali e diagonali).
Ovviamente, in una implementazione software, la griglia sarà finita e le celle potranno avere
<strong>3,5,o 8</strong> vicini.</p>
<p>Nonostante le regole parlino solo di “celle e vicini”, <strong>osservando una vista del sistema</strong>
emergono (si veda <span class="xref std std-ref">emergnza</span>) strutture che sembrano avere una propria identità
(si ricordi quanto detto per “Vedere un Glider” in <a class="reference internal" href="#teoria-algoritmica-dell-informazione"><span class="std std-ref">Teoria Algoritmica dell’Informazione</span></a>), come:</p>
<ul class="simple">
<li><p><strong>Still Lifes</strong>: Forme statiche che non cambiano (come rocce).</p></li>
<li><p><strong>Oscillatori</strong>: Forme che mutano ciclicamente (come un battito cardiaco).</p></li>
<li><p><strong>Spaceships</strong> (Astronavi): Aggregati che “espellono” delle strutture che viaggiano
all’infinito lontano dal centro della griglia. Il più famoso è il <strong>Glider</strong> (Aliante).</p></li>
</ul>
<p>E’ importante sottolinare che le strutture <em>Still Lifes</em> <strong>sembrano</strong> rimanere immutabili.
Infatti esse sono <strong>continuamente rigenerate</strong> dal ‘motore’ del gico, sempre uguali a sè stesse;
si veda: <span class="xref std std-ref">Evoluzione di GofLife</span>.</p>
<section id="il-gioco-in-javascript">
<h2>Il gioco in  JavaScript<a class="headerlink" href="#il-gioco-in-javascript" title="Permalink to this heading">¶</a></h2>
<p>Collegandosi al sito <a class="reference external" href="https://playgameoflife.com/">https://playgameoflife.com/</a> si può sperimentare il gioco. Riportiamo qui
alcune configurazioni iniziali interessanti:</p>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>oscilla</p>
<a class="reference internal image-reference" href="_images/demobase.png"><img alt="_images/demobase.png" class="align-center" src="_images/demobase.png" style="width: 100%;" /></a>
</td>
<td><p>stabilizza</p>
<a class="reference internal image-reference" href="_images/stabile.png"><img alt="_images/stabile.png" class="align-center" src="_images/stabile.png" style="width: 100%;" /></a>
</td>
<td><p>penatamini</p>
<a class="reference internal image-reference" href="_images/pentamini.png"><img alt="_images/pentamini.png" class="align-center" src="_images/pentamini.png" style="width: 100%;" /></a>
</td>
<td><p>glider</p>
<a class="reference internal image-reference" href="_images/glider.png"><img alt="_images/glider.png" class="align-center" src="_images/glider.png" style="width: 100%;" /></a>
</td>
<td><p>pentaminoR</p>
<a class="reference internal image-reference" href="_images/pentaminoR.png"><img alt="_images/pentaminoR.png" class="align-center" src="_images/pentaminoR.png" style="width: 100%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>I 12 <strong>pentamini</strong> esistenti si stabilizzano nei tre modi citati: Still Lifes, Oscillatori e Astronavi (Glider).</p>
<p>Il <strong>Pentamino-R</strong> è importante perché ha dimostrato che non era possibile prevedere a occhio nudo
se una forma sarebbe cresciuta all’infinito o meno. È il riflesso visivo del Problema della <em>Fermata di Turing</em>:
non si può sapere se un programma si fermerà (si stabilizzerà) senza farlo girare.
Viene definito un <em>Matusalemme</em>, perché esplode in un caos ribollente che dura per
ben <code class="docutils literal notranslate"><span class="pre">1103</span></code> generazioni prima di stabilizzarsi.</p>
</section>
<section id="il-gioco-produce-complessita">
<h2>Il gioco produce complessità<a class="headerlink" href="#il-gioco-produce-complessita" title="Permalink to this heading">¶</a></h2>
<p>Nonostante la semplità delle regole di base,
la previsione del comportamento a lungo termine del Gioco della Vita è un problema
che ha affascinato matematici e informatici per decenni e, nonostante numerosi studi,
non esiste ancora una soluzione definitiva e generale, per alcuni motivi:</p>
<ul class="simple">
<li><p><strong>Complessità esponenziale</strong>: Il numero di possibili configurazioni di una griglia di celle aumenta in modo
esponenziale con la dimensione della griglia stessa. Questo rende impraticabile un’analisi esaustiva
di tutte le possibili evoluzioni.</p></li>
<li><p><strong>Comportamento caotico</strong>: Piccole variazioni nella configurazione iniziale possono portare a risultati
completamente diversi nel lungo periodo, rendendo difficile stabilire delle leggi generali che governino
l’evoluzione del sistema.</p></li>
<li><p><strong>Emergenza</strong>: Dal semplice insieme di regole del gioco emergono comportamenti complessi e imprevedibili,
come la formazione di strutture stabili, oscillanti o in continua evoluzione.</p></li>
</ul>
<p>Anche con una griglia finita, prevedere il comportamento a lungo termine di una configurazione iniziale
rimane un <a class="reference internal" href="#sistemi-complessi"><span class="std std-ref">problema complesso</span></a>.
Il numero di possibili configurazioni, anche se finito, può essere enorme,
rendendo impraticabile un’analisi esaustiva.</p>
<p>Inoltre, a differenza di molti altri sistemi fisici, il Gioco della Vita <strong>non è sempre reversibile</strong>.
Ciò significa che, data una configurazione finale, non è sempre possibile risalire univocamente alla configurazione iniziale
che l’ha generata. Molte configurazioni finali possono avere più configurazioni iniziali che portano allo stesso risultato.</p>
<p>Dunque, determinare la configurazione iniziale che porta a una data configurazione finale nel
Gioco della Vita
è un <a class="reference internal" href="#sistemi-complessi"><span class="std std-ref">problema complesso</span></a> e, in generale, non esiste una soluzione
algoritmica efficiente.</p>
<p>Il gioco è un esempio di sviluppo e <strong>auto-organizzazione</strong>. È interessante per scienziati, matematici e economisti
osservare il modo in cui schemi complessi possono emergere dall’implementazione di regole assai semplici.</p>
<section id="il-gioco-e-turing-completo">
<h3>Il gioco è Turing-completo<a class="headerlink" href="#il-gioco-e-turing-completo" title="Permalink to this heading">¶</a></h3>
<p>È stato dimostrato che nel <em>Game of Life</em> si possono costruire circuiti logici (porte <code class="docutils literal notranslate"><span class="pre">AND,</span> <span class="pre">OR,</span> <span class="pre">NOT</span></code>)
ed è quindi <a class="reference internal" href="#computazionalmente-completo"><span class="std std-ref">Computazionalmente completo</span></a>.
Ciò significa che, con una griglia abbastanza grande e la giusta configurazione iniziale,
si pottrebbe costruire un computer capace di eseguire qualsiasi algoritmo che un PC attuale può eseguire.</p>
</section>
</section>
<section id="il-problema-della-vista-del-gioco">
<span id="id78"></span><h2>Il problema della vista del gioco<a class="headerlink" href="#il-problema-della-vista-del-gioco" title="Permalink to this heading">¶</a></h2>
<p>Se visualizziamo l’evoluzione dello stato delle celle con una sequenza di messaggi su una console,
come ad esempio:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cell</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">false</span>
<span class="n">cell</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">true</span>
<span class="n">cell</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">:</span><span class="n">false</span>
<span class="o">...</span>
</pre></div>
</div>
<p>possiamo capire che <a class="reference internal" href="#lifecontroller"><span class="std std-ref">LifeController</span></a> sta girando, ma non avremo certo alcuna
immediata percezione delle configurazioni ‘interessanti’.</p>
<p>il “senso” delle configurazioni non risiede solo nei dati, ma anche nella struttura dello spazio
in cui questi dati vengono proiettati.
Se la proiezione non rispetta la geometria delle regole del gioco,
l’emergenza (la nascita delle forme) svanisce per l’osservatore.</p>
<p>Per fare in modo che lo spazio della rappresentazione
sia “sintonizzato” sulla metrica delle leggi del gioco
occorre una matrice 2D.</p>
<p>La matrice non è solo un modo “comodo” per vedere il gioco;
è la chiave di <strong>decrittazione</strong> che permette alla logica di Conway di manifestarsi come “forma”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Il filosofo <strong>Daniel Dennet</strong> utilizza il Game of Life come metafora centrale nel suo saggio del <code class="docutils literal notranslate"><span class="pre">1991</span></code>,
<em>Real Patterns</em>, per illustrare come entità complesse possano essere considerate “reali”
senza dover essere riducibili a oggetti fisici fondamentali.</p>
<p>La descrizione dello stato delle celle come sequenza di stringhe è esaustiva ma priva di sintesi;
non permette di “vedere” il comportamento globale del sistema in modo efficiente.</p>
<p>Per Dennett, il <strong>glider</strong> che si muove su una rappresentazione a matrice
è un “pattern reale” perché riconoscerlo permette una <strong>compressione predittiva</strong>:
fornisce un vantaggio informativo enorme rispetto alla descrizione atomica delle celle.</p>
<p>I glider dunque “esistono”? La risposta di Dennet è che sono reali tanto quanto i nostri desideri
o le nostre credenze. Non sono entità fisiche separate, ma sono configurazioni oggettive
della materia che diventano visibili (e reali) solo quando adottiamo
un certo livello di astrazione necessario per navigare la complessità del mondo.</p>
<p>Dennet sostiene che noi identifichiamo modelli adottando diverse posizioni nei confronti di un sistema:</p>
<ul class="simple">
<li><p><strong>Posizione fisica</strong>: previsione basata su leggi fisiche e microdettagli.</p></li>
<li><p><strong>Posizione di progettazione</strong>: previsione basata sull’organizzazione funzionale
(ad esempio, “questa parte serve per il raffreddamento”).</p></li>
<li><p><strong>Posizione intenzionale</strong>: prevedere il comportamento attribuendo credenze, desideri e razionalità.</p></li>
</ul>
<p>Il collegamento tra i “Real Patterns” di Dennett e la <strong>Teoria algoritmica dell’informazione</strong>
è diventato un pilastro della filosofia della scienza contemporanea, con importanti sviluppi
nel 2025 e 2026 che formalizzano questa intuizione.</p>
<p>Per un approfondimento, si veda  la <a class="reference internal" href="#teoria-algoritmica-dell-informazione"><span class="std std-ref">Teoria Algoritmica dell’Informazione</span></a> come
l’apparato matematico che formalizza le idee di Dennet.</p>
</div>
</section>
<section id="il-gioco-come-caso-di-studio">
<h2>Il gioco come caso di studio<a class="headerlink" href="#il-gioco-come-caso-di-studio" title="Permalink to this heading">¶</a></h2>
<p>Nei capitoli seguenti faremo riferimento al gioco <em>Game of Life</em> (<strong>GofLife</strong>) come
caso di studio di sistemi software, dapprima concentrati e poi distribuiti.
L’elenco delle varie versioni è riportato in <a class="reference internal" href="#il-filo-conduttore"><span class="std std-ref">Il filo conduttore</span></a>:</p>
<p>Iniziamo costruendo il gioco assumendo come tecnologia di riferimento
il <a class="reference internal" href="#paradigma-orientato-agli-oggetti-oop"><span class="std std-ref">paradigma ad oggetti</span></a> e
il linguaggio Java.
L’obiettivo è anche mettere a punto gli strumenti (Eclipse, Gradle, Docker, etc.)
che usermo per la castruzione del software. A tal fine si veda: <a class="reference internal" href="Primi%20passi%20operativi.html#primi-passi-operativi"><span class="std std-ref">Primi passi operativi</span></a>.</p>
<section id="analsi-del-problema-goflife">
<h3>Analsi del problema GofLife<a class="headerlink" href="#analsi-del-problema-goflife" title="Permalink to this heading">¶</a></h3>
<p>Tratandosi di un gioco zero-player con controllo esterno, il sistema</p>
<ul class="simple">
<li><p>deve essere <strong>proattivo</strong>, in quanto deve realizzare il gioco come un comportamento autonomo</p></li>
<li><p>deve essere <strong>anche reattivo</strong>, in quanto deve percepire e gstire i comandi di configurazione
e di start/stop che l’utente inviarà  mediante un dispositivo di input</p></li>
<li><p>deve fornire una rappresentazione tenendo conto di quanto detto in
<a class="reference internal" href="#il-problema-della-vista-del-gioco"><span class="std std-ref">Il problema della vista del gioco</span></a></p></li>
</ul>
</section>
<section id="progetto-conwaylife26">
<span id="id79"></span><h3>Progetto ConwayLife26<a class="headerlink" href="#progetto-conwaylife26" title="Permalink to this heading">¶</a></h3>
<p>In accordo al principi di <span class="xref std std-ref">Separazione delle Responsabilità</span> e <a class="reference internal" href="#single-responsibility"><span class="std std-ref">SRP-Single responsibility</span></a>
proponiamo una architettura software basata sui seguenti componenti software:</p>
<ol class="arabic simple">
<li><p>Modelliamo il dominio cone le classi Java <code class="docutils literal notranslate"><span class="pre">Cell,</span> <span class="pre">Grid,</span> <span class="pre">Life</span></code></p></li>
<li><p>Definiamo un componente attivo <code class="docutils literal notranslate"><span class="pre">LifeController</span></code> che ha la responsabilità di far evolvere il gioco</p></li>
<li><p>Definiamo <a class="reference internal" href="#la-interfaccia-ioutdev"><span class="std std-ref">La interfaccia IOutDev</span></a>  per la visualizzazione dello stato di una <code class="docutils literal notranslate"><span class="pre">Cell</span></code>
e/o di tutta la <code class="docutils literal notranslate"><span class="pre">Grid</span></code></p></li>
<li><p>Definiamo <a class="reference internal" href="#la-interfaccia-gamecontroller"><span class="std std-ref">La interfaccia GameController</span></a>  per la interazione dei dispostivi di input cone  <code class="docutils literal notranslate"><span class="pre">LifeController</span></code></p></li>
<li><p>Definiamo i componenti di output che implementano <code class="docutils literal notranslate"><span class="pre">IOutDev</span></code> e quelli di input che si relazionano con <code class="docutils literal notranslate"><span class="pre">LifeController</span></code>
mediante l’interfaccia <code class="docutils literal notranslate"><span class="pre">GameController</span></code>.</p></li>
</ol>
<table class="docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>.</p>
<a class="reference internal image-reference" href="_images/LifeGameJava+.jpg"><img alt="_images/LifeGameJava+.jpg" class="align-center" src="_images/LifeGameJava+.jpg" style="width: 100%;" /></a>
</td>
<td><ul class="simple">
<li><p><strong>Cell</strong>: elemento fondamentale del gioco</p></li>
<li><p><strong>Grid</strong>: aggregato di <code class="docutils literal notranslate"><span class="pre">Cell</span></code></p></li>
<li><p><strong>Life</strong>: regole del gioco</p></li>
<li><p><strong>IOutDev</strong>: contratto per la visualizzazione dello stato di una <code class="docutils literal notranslate"><span class="pre">Cell</span></code></p></li>
<li><p><strong>LifeController</strong>: controllo del gioco e visualizzazione della <code class="docutils literal notranslate"><span class="pre">Grid</span></code></p></li>
<li><p><strong>Gamecontroller</strong>: contratto che <code class="docutils literal notranslate"><span class="pre">LifeController</span></code> impone ai dispositivi in input</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="lifecontroller">
<span id="id80"></span><h3>LifeController<a class="headerlink" href="#lifecontroller" title="Permalink to this heading">¶</a></h3>
<p>Osserviamo che <code class="docutils literal notranslate"><span class="pre">LifeController</span></code> è un componente</p>
<ul class="simple">
<li><p><strong>proattivo</strong>, in quanto fa evolvere il “zero-player game” attraverso il thread <strong>play</strong></p></li>
<li><p><strong>reattivo</strong>, in quanto dovrebbe essere capace di:</p>
<ul>
<li><p>percepire comandi per definire la configurazione iniziale della  <code class="docutils literal notranslate"><span class="pre">Grid</span></code></p></li>
<li><p>percepire comandi di <code class="docutils literal notranslate"><span class="pre">start/stop/clear</span></code> del gioco  emssi da un utente (umano) mediante un dispositivo di input.
A questo fine, <code class="docutils literal notranslate"><span class="pre">LifeController</span></code> implementa  <a class="reference internal" href="#la-interfaccia-gamecontroller"><span class="std std-ref">La interfaccia GameController</span></a></p></li>
</ul>
</li>
</ul>
<p>Osserviamo anche che i dispostivi di output e di input possono essere di tipi diversi. In particolare,
esamineremo le seguenti possibilità:</p>
<ol class="arabic simple">
<li><p>Dispositivo di output basato su console (<code class="docutils literal notranslate"><span class="pre">System.out</span></code>); lasciato come esercizio al lettore</p></li>
<li><p>Dispositivo di output (e input) basato su GUI swing: si veda <a class="reference internal" href="#una-gui-con-swing"><span class="std std-ref">Una GUI con Swing</span></a></p></li>
<li><p>Dispositivo di output (e input) basato su GUI HTML/JS:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>con rapprresentazione granulare della <code class="docutils literal notranslate"><span class="pre">Grid</span></code>; si veda <span class="xref std std-ref">Una griglia granulare</span></p></li>
<li><p>con rappresentazione sintetica della <code class="docutils literal notranslate"><span class="pre">Grid`</span></code> mediante canvas; si veda <span class="xref std std-ref">Una griglia globale</span></p></li>
</ul>
</div></blockquote>
<p>Il punto importante consiste nel fare in modo che <code class="docutils literal notranslate"><span class="pre">LifeController</span></code>
<strong>non dipenda</strong> da una specifica implementazione di <code class="docutils literal notranslate"><span class="pre">IOutDev</span></code>.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LifeController</span> <span class="kd">implements</span> <span class="n">GameController</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="nf">LifeController</span><span class="p">(</span> <span class="n">Life</span> <span class="n">game</span><span class="p">,</span> <span class="n">IOutDev</span> <span class="n">outdev</span> <span class="p">){</span>
  <span class="p">...</span>
  <span class="p">}</span>

  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">play</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">new</span> <span class="n">Thread</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//Evoluzione del gioco in epoche successive</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">running</span> <span class="p">)</span> <span class="p">{</span>
          <span class="p">...</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}.</span><span class="na">start</span><span class="p">();</span>
   <span class="p">}</span><span class="c1">//play</span>
</pre></div>
</div>
</section>
<section id="il-processo-di-evoluzione-del-gioco">
<span id="id81"></span><h3>Il processo di evoluzione del gioco<a class="headerlink" href="#il-processo-di-evoluzione-del-gioco" title="Permalink to this heading">¶</a></h3>
<p>Il thread <strong>play</strong> fa evolvere il gioco dalla configurazione iniziale in epoche successive.
Nella nostra implementazione attuale, il thread rimane <strong>running</strong>  fino a quando:</p>
<ul class="simple">
<li><p>la configurazione corrente diventa stabile</p></li>
<li><p>non ci sono più celle vive</p></li>
<li><p>l’utente invia un comando <code class="docutils literal notranslate"><span class="pre">stop</span></code> per fermare l’evoluzione del sistema</p></li>
</ul>
<p>Tuttavia si potrebbe pensare di <strong>non fermare</strong> <em>play</em> nei primi due casi, in quanto:</p>
<ul class="simple">
<li><p>l’utente che controlla il gioco potrebbe introdurre nuove celle ‘vive’ tra una epoca e l’altra</p></li>
<li><p>il thread <em>play</em> stesso potrebbe generare nuove celle ‘vive’ in modo casuale,
simulando un meccanisimo che nella teoria dei campi della fisica moderna
è collegato all’idea di ‘vuoto fisico’ della toria dei campi come entità dinamica,
che, come asserito dai mistici orientali,
è la ‘realtà prima’ che dà origine a tutte le forme del mondo fenomenico.</p></li>
</ul>
</section>
<section id="la-interfaccia-ioutdev">
<span id="id82"></span><h3>La interfaccia IOutDev<a class="headerlink" href="#la-interfaccia-ioutdev" title="Permalink to this heading">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">main.java.conway.domain</span><span class="p">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IOutDev</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">String</span> <span class="n">msg</span><span class="p">);</span>      <span class="c1">//For HMI</span>
  <span class="kt">void</span> <span class="nf">displayCell</span><span class="p">(</span><span class="n">Cell</span> <span class="n">cell</span><span class="p">,</span> <span class="n">Grid</span> <span class="n">grid</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">displayGrid</span><span class="p">(</span><span class="n">Grid</span> <span class="n">grid</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">display(String</span> <span class="pre">msg)</span></code> consente di visualizzare messaggi di testo
(per una migliore <strong>HMI</strong> - <em>HumanMachineInterface</em>)</p></li>
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">displayCell(Cell</span> <span class="pre">cell,</span> <span class="pre">Grid</span> <span class="pre">grid)</span></code> consente di visualizzare lo stato di una singola cella
(all’interno della griglia)</p></li>
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">displayGrid(Grid</span> <span class="pre">grid)</span></code> consente di visualizzare lo stato di tutta la griglia</p></li>
</ul>
</section>
<section id="la-interfaccia-gamecontroller">
<span id="id83"></span><h3>La interfaccia GameController<a class="headerlink" href="#la-interfaccia-gamecontroller" title="Permalink to this heading">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">main.java.conway.domain</span><span class="p">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GameController</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">onStart</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">onStop</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">onClear</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">switchCellState</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setOutDev</span><span class="p">(</span><span class="n">IOutDev</span> <span class="n">outdev</span><span class="p">);</span> <span class="c1">//injection</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>I metodi <code class="docutils literal notranslate"><span class="pre">onStart</span></code>, <code class="docutils literal notranslate"><span class="pre">onStop</span></code> e <code class="docutils literal notranslate"><span class="pre">onClear</span></code> consentono di avviare, fermare e azzerare il gioco.</p></li>
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">switchCellState</span></code> consente di commutare lo stato di una cella (viva/morta). Usato in particolare nella
fase di inizializzazione.</p></li>
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">setOutDev</span></code> consente di ‘iniettare’ una specifica implementazione di <code class="docutils literal notranslate"><span class="pre">IOutDev</span></code> nel <code class="docutils literal notranslate"><span class="pre">LifeController</span></code>.</p></li>
</ul>
</section>
<section id="mainconwaylifejava-java">
<span id="id84"></span><h3>MainConwayLifeJava.java<a class="headerlink" href="#mainconwaylifejava-java" title="Permalink to this heading">¶</a></h3>
<p>I diversi approcci per la realizzazione di dispostivi di output e input vengono sperimentati con il programma
<strong>MainConwayLifeJava.java</strong> nel package <code class="docutils literal notranslate"><span class="pre">main.java.conway.domain</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">void</span> <span class="n">configureTheSystemWitMockOutdev</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">configureTheSystemWithSwing</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">configureTheSystemWithHtmlWs</span><span class="p">(</span><span class="n">boolean</span> <span class="n">pageexternal</span><span class="p">){</span> <span class="o">...</span> <span class="p">}</span>

<span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
<span class="n">MainConwayLifeJava</span> <span class="n">app</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MainConwayLifeJava</span><span class="p">();</span>
  <span class="o">//</span><span class="n">app</span><span class="o">.</span><span class="n">configureTheSystemWitMockOutdev</span><span class="p">();</span>
  <span class="n">app</span><span class="o">.</span><span class="n">configureTheSystemWithSwing</span><span class="p">();</span>
  <span class="o">//</span><span class="n">app</span><span class="o">.</span><span class="n">configureTheSystemWithHtmlWs</span><span class="p">(</span><span class="n">false</span><span class="p">);</span>  <span class="o">//</span><span class="n">apre</span> <span class="n">la</span> <span class="n">pagina</span> <span class="n">automaticamente</span>
    <span class="o">//</span><span class="n">app</span><span class="o">.</span><span class="n">configureTheSystemWithHtmlWs</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>   <span class="o">//</span><span class="n">occorre</span> <span class="n">localhost</span><span class="p">:</span><span class="mi">8080</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Il programma propone diverse procedure di configurazion del sistema, tra cui :</p>
<ul class="simple">
<li><p><a class="reference internal" href="#configurazione-di-goflife-con-swing"><span class="std std-ref">Configurazione di GofLife con Swing</span></a></p></li>
<li><p><span class="xref std std-ref">Configurazione di GofLife con HTML</span> (più avanti)</p></li>
</ul>
</section>
<section id="una-gui-con-swing">
<span id="id85"></span><h3>Una GUI con Swing<a class="headerlink" href="#una-gui-con-swing" title="Permalink to this heading">¶</a></h3>
<p>Un primo modo per superare il limite dell’uso della console come dispositivo di output,
è introdurre una visualizzazione di tipo grafico,
realizzando una GUI in Java con Swing.
Un dispostivo di questo tipo è definito nella classe <code class="docutils literal notranslate"><span class="pre">main/java/conway/io/ConwayLifeGridClaude.java</span></code>
il cui codice è stato proposto da <strong>Claude AI</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Il prompt dato a Claude (<strong>requisiti</strong>): Vorrei una classe Java che realizza la rappresentazione grafica di
una griglia quadrata di <code class="docutils literal notranslate"><span class="pre">20x20</span></code> celle usando Swiing.
La griglia è relativa al gioco ConwayLife e quindi le celle possono assumere solo due colori (white - cella morta e red - cella viva).
La classe deve fornire metodi invocabili dall’esterno per visualizzare tutta la griglia e per commutare il colore di una cella
(da white a red e viceversa). Nella rappresentazione grafica devono comparire anche due pulsanti START e STOP,
facendo click sui quali la classe invia un comando a un componente esterno (un controllore del gioco)</p>
</div>
</section>
<section id="configurazione-di-goflife-con-swing">
<span id="id86"></span><h3>Configurazione di GofLife con Swing<a class="headerlink" href="#configurazione-di-goflife-con-swing" title="Permalink to this heading">¶</a></h3>
<p>Rispetto al codice proposto da Claude, abbiamo aggiunto i metodi per implementare l’interfaccia <code class="docutils literal notranslate"><span class="pre">IOutDev</span></code>
e la <strong>‘iniezione’</strong> dell’istanza di <code class="docutils literal notranslate"><span class="pre">LifeController</span></code>.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span> <span class="kn">package</span> <span class="nn">main.java.conway.domain</span><span class="p">;</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainConwayLifeJava</span>  <span class="p">{</span>
 <span class="p">...</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">configureTheSystemWithSwing</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Life</span> <span class="n">life</span>            <span class="o">=</span> <span class="k">new</span> <span class="n">Life</span><span class="p">(</span> <span class="mi">20</span><span class="p">,</span><span class="mi">20</span> <span class="p">);</span>
  <span class="n">IOutDev</span> <span class="n">swinggui</span>     <span class="o">=</span> <span class="k">new</span> <span class="n">ConwayLifeGridClaude</span><span class="p">(</span> <span class="p">);</span>   <span class="c1">//dispositivo di output (e anche di input)</span>
  <span class="n">GameController</span>  <span class="n">cc</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">LifeController</span><span class="p">(</span><span class="n">life</span><span class="p">,</span> <span class="n">swinggui</span><span class="p">)</span> <span class="p">;</span>   <span class="c1">//un GameController che deve usare un IOutDev</span>
  <span class="p">((</span><span class="n">ConwayLifeGridClaude</span><span class="p">)</span> <span class="n">swinggui</span><span class="p">).</span><span class="na">setController</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>          <span class="c1">//iniezione del controller nella GUI</span>
  <span class="c1">//Il sistema termina quando si chiude la swinggui</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Problemi di deployment</strong></p>
<p>Questa implementazione funziona bene in locale, ma non è adatta a essere eseguito in un container Docker.</p>
<p>Infatti, Java Swing tenta di disegnare la GUI, interroga il sistema operativo per trovare un Display Server
(come <em>X11</em> su Linux o <em>Window Manager</em> su Windows).
Non trovandolo, Java solleverà l’eccezione <strong>java.awt.HeadlessException</strong>.</p>
<p>Mettere una GUI Swing in Docker va contro la filosofia “Cloud Native”, se non altro
perchè l’immagine Docker diventa enorme, dovendo includere tutte le librerie grafiche.</p>
</section>
<section id="da-un-programma-a-un-servizio">
<h3>Da un programma a un servizio<a class="headerlink" href="#da-un-programma-a-un-servizio" title="Permalink to this heading">¶</a></h3>
<p>Meglio quindi realizzare la GUI del gioco come una pagina Web (HTML/JS)
come faremo in <span class="xref std std-ref">Una GUI HTML per Game of Life</span>.</p>
<p>Prima però è opportuno capire che la introduzione di una pagina HTML
cambia la natura del sistema, in quanto implica la introduzione di
supporti capaci di realizzare interazioni via rete tra componenti software.</p>
<p>Il gioco diventa molto simile a un ‘servizio’ e può quindi essere utile
approfondire le implicazioni di questa trasformazione nel prossimo capitolo.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Preludio</a><ul>
<li><a class="reference internal" href="#c-e-ancora-possibilita-di-lavoro">C’è ancora possibilità di lavoro?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cosa-si-intende-per-sistema">Cosa si intende per Sistema</a><ul>
<li><a class="reference internal" href="#descrivere-e-classificare">Descrivere e classificare</a></li>
<li><a class="reference internal" href="#sistemi-semplici">Sistemi semplici</a></li>
<li><a class="reference internal" href="#sistemi-complicati">Sistemi complicati</a></li>
<li><a class="reference internal" href="#sistemi-complessi">Sistemi complessi</a><ul>
<li><a class="reference internal" href="#il-termine-emergenza">Il termine ‘emergenza’</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sistemi-caotici">Sistemi caotici</a><ul>
<li><a class="reference internal" href="#macchine-agenti-organismi">Macchine, agenti, organismi</a><ul>
<li><a class="reference internal" href="#macchina">Macchina</a></li>
<li><a class="reference internal" href="#sistema-cibernetico">Sistema cibernetico</a></li>
<li><a class="reference internal" href="#agente">Agente</a></li>
<li><a class="reference internal" href="#agente-intelligente">Agente intelligente</a></li>
<li><a class="reference internal" href="#organismo">Organismo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#come-si-descrive-un-sistema">Come si descrive un sistema</a><ul>
<li><a class="reference internal" href="#visione-blackbox">Visione BlackBox</a></li>
<li><a class="reference internal" href="#visione-whitebox">Visione WhiteBox</a></li>
<li><a class="reference internal" href="#dimensioni">Dimensioni</a></li>
<li><a class="reference internal" href="#visione-sistemica">Visione sistemica</a><ul>
<li><a class="reference internal" href="#more-is-different">More is different</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#perche-i-sistemi-complessi">Perchè i sistemi complessi</a><ul>
<li><a class="reference internal" href="#la-sinergetica">La sinergetica</a></li>
<li><a class="reference internal" href="#id26">Teoria delle reti</a><ul>
<li><a class="reference internal" href="#griglie-e-grafi">Griglie e grafi</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#verso-i-sistemi-software">Verso i sistemi software</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cosa-vuol-dire-computare">Cosa vuol dire computare</a><ul>
<li><a class="reference internal" href="#il-motto-di-alan-kay">Il motto di Alan Kay</a></li>
<li><a class="reference internal" href="#dai-modelli-ai-linguaggi">Dai modelli ai linguaggi</a></li>
<li><a class="reference internal" href="#macchine-astratte">Macchine astratte</a></li>
<li><a class="reference internal" href="#la-macchina-di-minsky">La Macchina di Minsky</a></li>
<li><a class="reference internal" href="#problemi-non-riducibili-indecidibili">Problemi non riducibili (Indecidibili)</a><ul>
<li><a class="reference internal" href="#il-teorema-di-rice">Il Teorema di Rice</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cosa-significa-costruire">Cosa significa ‘costruire’</a><ul>
<li><a class="reference internal" href="#computazionalmente-completo">Computazionalmente completo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#teoria-algoritmica-dell-informazione">Teoria Algoritmica dell’Informazione</a><ul>
<li><a class="reference internal" href="#applicazione-all-intelligenza-artificiale">Applicazione all’Intelligenza Artificiale</a></li>
</ul>
</li>
<li><a class="reference internal" href="#evoluzione-del-concetto-di-computazione">Evoluzione del concetto di Computazione</a><ul>
<li><a class="reference internal" href="#verso-la-definizione-di-sistemi-che-calcolano">Verso la definizione di ‘sistemi che calcolano’</a></li>
</ul>
</li>
<li><a class="reference internal" href="#famiglie-di-formalismi">Famiglie di formalismi</a><ul>
<li><a class="reference internal" href="#alcuni-dei-promotori">Alcuni dei promotori</a></li>
<li><a class="reference internal" href="#formalismi-funzionali">Formalismi funzionali</a></li>
<li><a class="reference internal" href="#formalismi-concorrenti">Formalismi concorrenti</a></li>
<li><a class="reference internal" href="#formalismi-distribuiti">Formalismi distribuiti</a></li>
<li><a class="reference internal" href="#formalismi-per-la-mobilita">Formalismi per la mobilità</a></li>
<li><a class="reference internal" href="#formalismi-stocastici">Formalismi stocastici</a></li>
<li><a class="reference internal" href="#formalismi-field-based-e-global-behavior">Formalismi field-based e global behavior</a></li>
<li><a class="reference internal" href="#formalismi-per-sistemi-complessi-e-dinamiche-non-lineari">Formalismi per sistemi complessi e dinamiche non lineari</a></li>
<li><a class="reference internal" href="#oltre-la-macchina-di-von-neumann">Oltre la macchina di Von Neumann</a></li>
<li><a class="reference internal" href="#quantum-computer">Quantum computer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modelli-formali-necessari-ma-non-sufficienti">Modelli formali: necessari ma non sufficienti</a></li>
<li><a class="reference internal" href="#la-coroutine-un-nuovo-vecchio-concetto">La coroutine un nuovo vecchio concetto</a></li>
<li><a class="reference internal" href="#un-esempio-csp-e-go">Un esempio: CSP e GO</a><ul>
<li><a class="reference internal" href="#csp-processi-sequenziali">CSP: Processi sequenziali</a></li>
<li><a class="reference internal" href="#come-csp-ha-influenzato-go">Come CSP ha influenzato Go</a><ul>
<li><a class="reference internal" href="#go-routine-come-processi-csp">Go-routine come “processi CSP”</a></li>
<li><a class="reference internal" href="#select">Select</a></li>
<li><a class="reference internal" href="#composizione-concorrente">Composizione concorrente</a></li>
<li><a class="reference internal" href="#assenza-di-memoria-condivisa-esplicita">Assenza di memoria condivisa “esplicita”</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#modelli-e-linguaggi">Modelli e linguaggi</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-linguaggi">I linguaggi</a><ul>
<li><a class="reference internal" href="#linguaggi-naturali">Linguaggi naturali</a></li>
<li><a class="reference internal" href="#i-large-language-models">I Large Language Models</a></li>
<li><a class="reference internal" href="#linguaggi-di-programmazione">Linguaggi di programmazione</a><ul>
<li><a class="reference internal" href="#una-frase-misteriosa">Una frase misteriosa</a></li>
<li><a class="reference internal" href="#sintassi-e-semantica">Sintassi e semantica</a></li>
<li><a class="reference internal" href="#linguaggi-per-descrivere-linguaggi">Linguaggi per descrivere linguaggi</a><ul>
<li><a class="reference internal" href="#macchine-astratte-per-riconoscere-linguaggi">Macchine astratte per riconoscere linguaggi</a></li>
</ul>
</li>
<li><a class="reference internal" href="#la-analisi-sintattica">La analisi sintattica</a></li>
<li><a class="reference internal" href="#descrivere-la-semantica">Descrivere la semantica</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compilatori-e-interpreti">Compilatori e interpreti</a></li>
<li><a class="reference internal" href="#general-processing-programming-languages">General Processing Programming Languages</a><ul>
<li><a class="reference internal" href="#stili-paradigni-di-programmazione">Stili (paradigni) di programmazione</a><ul>
<li><a class="reference internal" href="#paradigma-imperativo">Paradigma Imperativo</a></li>
<li><a class="reference internal" href="#paradigma-orientato-agli-oggetti-oop">Paradigma Orientato agli Oggetti (OOP)</a></li>
<li><a class="reference internal" href="#paradigma-funzionale-fp">Paradigma Funzionale (FP)</a></li>
<li><a class="reference internal" href="#paradigma-logico-dichiarativo">Paradigma Logico (Dichiarativo)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#gli-attori-come-nuovo-paradigma">Gli attori come nuovo paradigma?</a></li>
<li><a class="reference internal" href="#non-determinismo">Non determinismo</a></li>
<li><a class="reference internal" href="#influenza-di-un-ldp-sul-progettista-del-software">Influenza di un LdP sul progettista del software</a></li>
<li><a class="reference internal" href="#l-astrazione">L’astrazione</a><ul>
<li><a class="reference internal" href="#realta-vs-modello">Realtà vs. Modello</a></li>
<li><a class="reference internal" href="#l-abstraction-gap">L’Abstraction gap</a><ul>
<li><a class="reference internal" href="#perche-esiste-l-abstraction-gap">Perché esiste l’Abstraction Gap</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modelli-e-linguaggi-di-modellazione">Modelli e Linguaggi di modellazione</a></li>
<li><a class="reference internal" href="#uml">UML</a></li>
<li><a class="reference internal" href="#estensioni-di-uml">Estensioni di UML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#domain-specific-languages-dsl">Domain-Specific Languages (DSL)</a><ul>
<li><a class="reference internal" href="#dsl-interno">DSL Interno</a></li>
<li><a class="reference internal" href="#dsl-esterno">DSL Esterno</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-dsl-e-i-digital-twins">I DSL e i Digital Twins</a></li>
<li><a class="reference internal" href="#id50">Verso i sistemi software</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sistemi-software">Sistemi software</a><ul>
<li><a class="reference internal" href="#viste-di-un-sistema-software">Viste di un sistema software</a><ul>
<li><a class="reference internal" href="#vista-esterna">Vista esterna</a></li>
<li><a class="reference internal" href="#vista-interna">Vista interna</a></li>
<li><a class="reference internal" href="#vista-sommersa">Vista sommersa</a></li>
</ul>
</li>
<li><a class="reference internal" href="#componenti-software">Componenti software</a><ul>
<li><a class="reference internal" href="#componenti-software-di-base">Componenti software di base</a><ul>
<li><a class="reference internal" href="#i-pojo">I POJO</a></li>
</ul>
</li>
<li><a class="reference internal" href="#oltre-gli-oggetti">Oltre gli oggetti</a></li>
</ul>
</li>
<li><a class="reference internal" href="#un-viaggio-nei-sistemi-software">Un viaggio nei sistemi software</a><ul>
<li><a class="reference internal" href="#punti-di-vista">Punti di vista</a></li>
<li><a class="reference internal" href="#sistemi-embedded-iot">Sistemi Embedded/IoT</a><ul>
<li><a class="reference internal" href="#raspberrypi">RaspberryPi</a></li>
<li><a class="reference internal" href="#sistemi-cibernetici">Sistemi cibernetici</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#capire-sperimentando">Capire sperimentando</a><ul>
<li><a class="reference internal" href="#capire-interagendo">Capire interagendo</a></li>
<li><a class="reference internal" href="#interagire-con-un-sistema-software">Interagire con un sistema software</a></li>
<li><a class="reference internal" href="#capire-implica-opportuni-livelli-di-conoscenza">Capire implica opportuni livelli di conoscenza</a></li>
<li><a class="reference internal" href="#conoscere-per-comunicare">Conoscere per comunicare</a><ul>
<li><a class="reference internal" href="#la-interazione-come-vincolo">La interazione come vincolo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#sistemi-software-come-servizi-ma-non-solo">Sistemi software come servizi (ma non solo)</a><ul>
<li><a class="reference internal" href="#l-infrastruttura">L’infrastruttura</a><ul>
<li><a class="reference internal" href="#i-framework">I framework</a></li>
</ul>
</li>
<li><a class="reference internal" href="#le-api">Le API</a></li>
<li><a class="reference internal" href="#representational-state-transfer-rest">Representational State Transfer (REST)</a><ul>
<li><a class="reference internal" href="#hateoas">HATEOAS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dai-servizi-ai-microservizi">Dai servizi ai microservizi</a></li>
<li><a class="reference internal" href="#coap">CoAP</a><ul>
<li><a class="reference internal" href="#messaggi-confirmable">Messaggi Confirmable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#websockets">WebSocket</a><ul>
<li><a class="reference internal" href="#la-fase-di-connessione-nelle-ws">La fase di connessione nelle WS</a></li>
<li><a class="reference internal" href="#instradamento-del-messaggio">Instradamento del messaggio</a></li>
<li><a class="reference internal" href="#javalin-server">javalin server</a></li>
<li><a class="reference internal" href="#server-jetty">Server Jetty</a></li>
<li><a class="reference internal" href="#server-vert-x">Server Vert.x</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#sistemi-visti-dall-interno">Sistemi visti dall’interno</a><ul>
<li><a class="reference internal" href="#design-patterns">Design patterns</a><ul>
<li><a class="reference internal" href="#pattern-posa">Pattern POSA</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#architettura-di-un-sistema">Architettura di un sistema</a><ul>
<li><a class="reference internal" href="#definizione-strutturale">Definizione Strutturale</a></li>
<li><a class="reference internal" href="#definizione-pragmatica">Definizione Pragmatica</a></li>
<li><a class="reference internal" href="#evoluzione-delle-architetture">Evoluzione delle architetture</a></li>
<li><a class="reference internal" href="#big-ball-of-mud">Big Ball of Mud</a></li>
<li><a class="reference internal" href="#principi-solid">Principi SOLID</a><ul>
<li><a class="reference internal" href="#srp-single-responsibility">SRP-Single responsibility</a></li>
<li><a class="reference internal" href="#ocp-open-closed">OCP-Open/closed</a></li>
<li><a class="reference internal" href="#lsp-liskov-substitution">LSP-Liskov substitution</a></li>
<li><a class="reference internal" href="#isp-interface-segregation">ISP-Interface segregation</a></li>
<li><a class="reference internal" href="#dip-dependency-inversion">DIP-Dependency inversion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#clean-architectures">Clean Architecture</a><ul>
<li><a class="reference internal" href="#architettura-port-adapter">Architettura Port/Adapter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bounded-context">Bounded Context</a><ul>
<li><a class="reference internal" href="#bounded-context-e-clean-architecture">Bounded Context e Clean Architecture</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#costruiamo-sistemi-software">Costruiamo sistemi software</a><ul>
<li><a class="reference internal" href="#il-filo-conduttore">Il filo conduttore</a><ul>
<li><a class="reference internal" href="#altre-sperimentazioni">Altre sperimentazioni</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#processi-di-costruzione-del-software">Processi di costruzione del software</a></li>
<li><a class="reference internal" href="#il-testing">Il testing</a><ul>
<li><a class="reference internal" href="#il-nostro-metodo-di-lavoro">Il nostro metodo di lavoro</a><ul>
<li><a class="reference internal" href="#il-diario-di-bordo">Il diario di bordo</a></li>
<li><a class="reference internal" href="#il-template-del-diario">Il template del diario</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#game-of-life-di-conway">Game of Life di Conway</a><ul>
<li><a class="reference internal" href="#il-gioco-in-javascript">Il gioco in  JavaScript</a></li>
<li><a class="reference internal" href="#il-gioco-produce-complessita">Il gioco produce complessità</a><ul>
<li><a class="reference internal" href="#il-gioco-e-turing-completo">Il gioco è Turing-completo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#il-problema-della-vista-del-gioco">Il problema della vista del gioco</a></li>
<li><a class="reference internal" href="#il-gioco-come-caso-di-studio">Il gioco come caso di studio</a><ul>
<li><a class="reference internal" href="#analsi-del-problema-goflife">Analsi del problema GofLife</a></li>
<li><a class="reference internal" href="#progetto-conwaylife26">Progetto ConwayLife26</a></li>
<li><a class="reference internal" href="#lifecontroller">LifeController</a></li>
<li><a class="reference internal" href="#il-processo-di-evoluzione-del-gioco">Il processo di evoluzione del gioco</a></li>
<li><a class="reference internal" href="#la-interfaccia-ioutdev">La interfaccia IOutDev</a></li>
<li><a class="reference internal" href="#la-interfaccia-gamecontroller">La interfaccia GameController</a></li>
<li><a class="reference internal" href="#mainconwaylifejava-java">MainConwayLifeJava.java</a></li>
<li><a class="reference internal" href="#una-gui-con-swing">Una GUI con Swing</a></li>
<li><a class="reference internal" href="#configurazione-di-goflife-con-swing">Configurazione di GofLife con Swing</a></li>
<li><a class="reference internal" href="#da-un-programma-a-un-servizio">Da un programma a un servizio</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="index.html"
                          title="previous chapter">Labiss2026 documentation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/TestoIssA.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Labiss2026 documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">iss26 1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Preludio</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2026, Antonio Natali.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>